<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
            touch-action: none;
        }
        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Dialogue Box */
        #dialogue-box {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 252, 245, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-radius: 20px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(196, 165, 116, 0.3);
            max-width: 85%;
            min-width: 260px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            z-index: 100;
        }
        #dialogue-box:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 6px 28px rgba(0, 0, 0, 0.25), 0 0 0 2px rgba(196, 165, 116, 0.5);
        }
        #dialogue-box:active {
            transform: translateX(-50%) scale(0.98);
        }
        #dialogue-box.fade-transition {
            animation: fadeMessage 0.3s ease;
        }
        @keyframes fadeMessage {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #dialogue-character {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8a7a60;
            margin-bottom: 6px;
        }
        #dialogue-text {
            font-size: 15px;
            line-height: 1.5;
            color: #3a3020;
        }
        #dialogue-hint {
            font-size: 11px;
            color: #a09080;
            margin-top: 8px;
            text-align: center;
        }

        /* Progress indicator */
        #progress-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 252, 245, 0.9);
            backdrop-filter: blur(8px);
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        #progress-label {
            font-size: 12px;
            color: #6a5a40;
            font-weight: 500;
        }
        #progress-track {
            width: 100px;
            height: 6px;
            background: #e8e0d0;
            border-radius: 3px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #7a9860, #a8c080);
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        #progress-percent {
            font-size: 12px;
            color: #5a8040;
            font-weight: 600;
            min-width: 32px;
        }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>

    <div id="progress-bar">
        <span id="progress-label">Growth</span>
        <div id="progress-track">
            <div id="progress-fill" style="width: 10%"></div>
        </div>
        <span id="progress-percent">10%</span>
    </div>

    <div id="dialogue-box">
        <div id="dialogue-character">Gentle Gardener</div>
        <div id="dialogue-text">Welcome to your garden. Every journey begins with a single seed.</div>
        <div id="dialogue-hint">tap to continue</div>
    </div>

    <script>
        // ===== TELEGRAM INTEGRATION =====
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        // ===== GARDEN STATE =====
        // This would come from the backend via Telegram initData
        let gardenState = {
            progress: 10, // 0-100, determines which stage
            stage: 1,     // 1-4 (Windowsill, Garden Corner, Blooming, Paradise)
            username: tg?.initDataUnsafe?.user?.first_name || 'Friend'
        };

        // Parse progress from URL query params (from Telegram WebApp URL)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('p')) {
            gardenState.progress = parseInt(urlParams.get('p')) || 10;
        }
        if (urlParams.has('s')) {
            gardenState.stage = parseInt(urlParams.get('s')) || 1;
        }

        // Also try Telegram initData start_param (base64 encoded JSON)
        if (tg?.initDataUnsafe?.start_param) {
            try {
                const params = JSON.parse(atob(tg.initDataUnsafe.start_param));
                gardenState.progress = params.progress || gardenState.progress;
                gardenState.stage = params.stage || gardenState.stage;
            } catch (e) {
                console.log('Using URL params or defaults');
            }
        }

        // Calculate stage from progress
        function getStageFromProgress(progress) {
            if (progress < 25) return 1;      // Windowsill (0-24%)
            if (progress < 50) return 2;      // Garden Corner (25-49%)
            if (progress < 75) return 3;      // Blooming Garden (50-74%)
            return 4;                          // Paradise (75-100%)
        }
        gardenState.stage = getStageFromProgress(gardenState.progress);

        // ===== DIALOGUE SYSTEM =====
        const dialogues = {
            1: [ // Windowsill stage
                "Every garden begins here. A single seed. A whisper of hope.",
                "This seedling is you, beginning your metabolic journey.",
                "Warm light through the window. Patient hands. That's all it needs.",
                "Small steps matter most. Log your meals. Move a little. Rest well.",
                "The soil is ready. The seed is planted. Growth will come.",
                "Some days the light is brighter. Some days it rains. Both nourish growth.",
                "Your body knows how to heal. We're just giving it the right conditions.",
                "No rushing. Plants don't grow faster when you watch them.",
                "This moment, right now, is part of your story.",
                "The gardener's secret? Consistency over intensity. Always."
            ],
            2: [ // Garden Corner stage
                "Look how far you've come. Your seedling has found its place in the garden.",
                "The glass cloche protects new growth. Self-compassion is your cloche.",
                "A small pond begins. Reflection is part of growth.",
                "The gardener kneels here often. Tending takes presence.",
                "Other plants are joining yours. You're building an ecosystem.",
                "Morning dew on leaves. Each day offers fresh beginnings.",
                "The soil is richer now. Your habits are taking root.",
                "Birds have noticed this corner. Life attracts life.",
                "Steady glucose, deeper ketosis - your garden responds.",
                "Not perfect. Growing. That's the only requirement."
            ],
            3: [ // Blooming Garden stage
                "The greenhouse stands now. You've built something lasting.",
                "So many flowers! Each one a choice you made for yourself.",
                "Koi in the pond. Even water has found its rhythm here.",
                "The path you've walked is becoming a trail for others.",
                "Abundance isn't about having more. It's about needing less.",
                "The gardener rests sometimes. Rest is productive too.",
                "Colors everywhere. Metabolic health makes life vivid.",
                "Trees provide shade now. You're creating shelter.",
                "The hard work is becoming easier. That's adaptation.",
                "Your body trusts you. It shows in how everything blooms."
            ],
            4: [ // Paradise stage
                "Welcome to paradise. You built this, one day at a time.",
                "The grand conservatory! A testament to patience.",
                "Mountains in the distance. New horizons always await.",
                "The gardener can rest now, watching everything flourish.",
                "This isn't an ending. It's a new way of being.",
                "Share what you've learned. Gardens spread through sharing.",
                "Every flower here started as that tiny seed on the windowsill.",
                "Metabolic health isn't a destination. It's this garden.",
                "The path winds on. There's always more beauty to discover.",
                "You are the garden. The garden is you. Growing, always."
            ]
        };

        let dialogueIndex = 0;
        let currentDialogues = dialogues[gardenState.stage];

        function updateDialogue() {
            const box = document.getElementById('dialogue-box');
            const text = document.getElementById('dialogue-text');

            box.classList.add('fade-transition');

            setTimeout(() => {
                dialogueIndex = (dialogueIndex + 1) % currentDialogues.length;
                text.textContent = currentDialogues[dialogueIndex];
                box.classList.remove('fade-transition');
            }, 150);
        }

        document.getElementById('dialogue-box').addEventListener('click', updateDialogue);

        // Update progress display
        function updateProgressDisplay() {
            document.getElementById('progress-fill').style.width = gardenState.progress + '%';
            document.getElementById('progress-percent').textContent = gardenState.progress + '%';
        }
        updateProgressDisplay();

        // ===== COLOR PALETTE =====
        const C = {
            sky1: '#b8d0e8', sky2: '#d0e0f0', sky3: '#e8f0f8',
            water1: '#5080a8', water2: '#6898b8', water3: '#88b8d0',
            grass1: '#4a7840', grass2: '#689858', grass3: '#88b070', grass4: '#a8c890',
            earth1: '#8a7058', earth2: '#a88868', earth3: '#c0a080',
            wood1: '#4a3828', wood2: '#6a5040', wood3: '#8a6850',
            terra1: '#a85838', terra2: '#c87048', terra3: '#e08860',
            glass1: '#a8c8e0', glass2: '#c0dce8', glass3: '#d8ecf8',
            rose1: '#c04858', rose2: '#d86878', rose3: '#e89098',
            orange1: '#d07830', orange2: '#e89848', orange3: '#f0b868',
            purple1: '#584888', purple2: '#7868a0', purple3: '#9888b8',
            yellow1: '#c8a030', yellow2: '#e0c048', yellow3: '#f0d870',
            leaf1: '#305828', leaf2: '#487838', leaf3: '#609848', leaf4: '#80b060',
            skin1: '#d8c0a8', skin2: '#e8d4c0', skin3: '#f0e0d0',
            cloth1: '#385068',
            hat1: '#b89050', hat2: '#d0a860', hat3: '#e0c078',
            outline: '#2a3038',
            white: '#ffffff'
        };

        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('garden-canvas');
        const ctx = canvas.getContext('2d');
        let w, h, dpr;

        function resizeCanvas() {
            dpr = window.devicePixelRatio || 1;
            w = window.innerWidth;
            h = window.innerHeight;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            render();
        }

        window.addEventListener('resize', resizeCanvas);

        // ===== DRAWING HELPERS =====
        function drawCurve(points, fill, strokeW = 2) {
            ctx.beginPath();
            ctx.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
                const p = points[i];
                if (p.length === 6) {
                    ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                } else if (p.length === 4) {
                    ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                } else {
                    ctx.lineTo(p[0], p[1]);
                }
            }
            ctx.closePath();
            ctx.fillStyle = fill;
            ctx.fill();
            if (strokeW > 0) {
                ctx.strokeStyle = C.outline;
                ctx.lineWidth = strokeW;
                ctx.stroke();
            }
        }

        // ===== PAINTERLY ELEMENTS =====
        function drawPot(x, y, pw, ph) {
            drawCurve([
                [x - pw * 0.35, y - ph],
                [x - pw * 0.42, y - ph * 0.7, x - pw * 0.45, y - ph * 0.3, x - pw * 0.38, y],
                [x + pw * 0.38, y],
                [x + pw * 0.45, y - ph * 0.3, x + pw * 0.42, y - ph * 0.7, x + pw * 0.35, y - ph]
            ], C.terra2, 2);

            drawCurve([
                [x - pw * 0.38, y - ph],
                [x - pw * 0.4, y - ph - 6, x - pw * 0.42, y - ph - 10, x - pw * 0.38, y - ph - 12],
                [x - pw * 0.2, y - ph - 14, x + pw * 0.2, y - ph - 14, x + pw * 0.38, y - ph - 12],
                [x + pw * 0.42, y - ph - 10, x + pw * 0.4, y - ph - 6, x + pw * 0.38, y - ph]
            ], C.terra3, 2);

            ctx.fillStyle = 'rgba(255, 220, 180, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x - pw * 0.3, y - ph * 0.9);
            ctx.quadraticCurveTo(x - pw * 0.35, y - ph * 0.5, x - pw * 0.28, y - ph * 0.15);
            ctx.quadraticCurveTo(x - pw * 0.15, y - ph * 0.5, x - pw * 0.2, y - ph * 0.85);
            ctx.closePath();
            ctx.fill();

            drawCurve([
                [x - pw * 0.32, y - ph + 8],
                [x - pw * 0.15, y - ph + 4, x + pw * 0.15, y - ph + 6, x + pw * 0.32, y - ph + 8],
                [x + pw * 0.2, y - ph + 12, x - pw * 0.2, y - ph + 14, x - pw * 0.32, y - ph + 8]
            ], C.earth1, 1.5);
        }

        function drawSeedling(x, y, scale) {
            const s = scale;
            ctx.strokeStyle = C.leaf2;
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x - 2 * s, y - 15 * s, x + 3 * s, y - 30 * s, x + 1 * s, y - 45 * s);
            ctx.stroke();
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            drawCurve([
                [x - 2 * s, y - 35 * s],
                [x - 25 * s, y - 30 * s, x - 30 * s, y - 40 * s, x - 22 * s, y - 48 * s],
                [x - 15 * s, y - 52 * s, x - 5 * s, y - 45 * s, x - 2 * s, y - 35 * s]
            ], C.leaf3, 1.5);

            ctx.strokeStyle = C.leaf1;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 4 * s, y - 38 * s);
            ctx.quadraticCurveTo(x - 18 * s, y - 42 * s, x - 22 * s, y - 46 * s);
            ctx.stroke();

            drawCurve([
                [x + 3 * s, y - 32 * s],
                [x + 28 * s, y - 28 * s, x + 32 * s, y - 38 * s, x + 24 * s, y - 46 * s],
                [x + 16 * s, y - 50 * s, x + 6 * s, y - 42 * s, x + 3 * s, y - 32 * s]
            ], C.leaf4, 1.5);

            ctx.strokeStyle = C.leaf2;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 5 * s, y - 35 * s);
            ctx.quadraticCurveTo(x + 20 * s, y - 38 * s, x + 23 * s, y - 44 * s);
            ctx.stroke();

            drawCurve([
                [x, y - 45 * s],
                [x - 8 * s, y - 52 * s, x - 6 * s, y - 62 * s, x, y - 68 * s],
                [x + 6 * s, y - 62 * s, x + 8 * s, y - 52 * s, x, y - 45 * s]
            ], C.leaf2, 1.5);
        }

        function drawHand(x, y, scale, flip = false) {
            const s = scale;
            const f = flip ? -1 : 1;

            drawCurve([
                [x, y],
                [x + f * 20 * s, y - 5 * s, x + f * 35 * s, y + 10 * s, x + f * 30 * s, y + 35 * s],
                [x + f * 20 * s, y + 45 * s, x - f * 5 * s, y + 40 * s, x, y]
            ], C.skin2, 2);

            drawCurve([
                [x + f * 5 * s, y + 5 * s],
                [x - f * 5 * s, y - 15 * s, x - f * 15 * s, y - 20 * s, x - f * 18 * s, y - 10 * s],
                [x - f * 20 * s, y, x - f * 10 * s, y + 10 * s, x + f * 5 * s, y + 5 * s]
            ], C.skin3, 1.5);

            const fingers = [
                { ox: 25, oy: -5, len: 28, ang: -0.3 },
                { ox: 32, oy: 8, len: 32, ang: -0.15 },
                { ox: 33, oy: 22, len: 30, ang: 0 },
                { ox: 28, oy: 34, len: 24, ang: 0.2 }
            ];

            fingers.forEach((fg, i) => {
                const fx = x + f * fg.ox * s;
                const fy = y + fg.oy * s;
                const tipX = fx + f * Math.cos(fg.ang) * fg.len * s;
                const tipY = fy + Math.sin(fg.ang) * fg.len * s;

                drawCurve([
                    [fx - f * 4 * s, fy + 3 * s],
                    [fx + f * 2 * s, fy - 4 * s, tipX - f * 5 * s, tipY - 3 * s, tipX, tipY],
                    [tipX + f * 3 * s, tipY + 5 * s, fx + f * 6 * s, fy + 8 * s, fx - f * 4 * s, fy + 3 * s]
                ], i % 2 === 0 ? C.skin2 : C.skin3, 1.5);
            });
        }

        function drawFlower(x, y, size, colors, petalCount = 5) {
            const s = size;
            const [c1, c2, c3] = colors;

            ctx.strokeStyle = C.leaf2;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(x, y + s * 2.5);
            ctx.bezierCurveTo(x - s * 0.3, y + s * 1.5, x + s * 0.2, y + s * 0.8, x, y + s * 0.3);
            ctx.stroke();
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 1.5;
            ctx.stroke();

            drawCurve([
                [x - s * 0.1, y + s * 1.5],
                [x - s * 0.8, y + s * 1.3, x - s * 0.9, y + s * 1.6, x - s * 0.5, y + s * 1.8],
                [x - s * 0.2, y + s * 1.7, x - s * 0.1, y + s * 1.6, x - s * 0.1, y + s * 1.5]
            ], C.leaf3, 1);

            for (let i = 0; i < petalCount; i++) {
                const angle = (i / petalCount) * Math.PI * 2 - Math.PI / 2;
                const px = x + Math.cos(angle) * s * 0.2;
                const py = y + Math.sin(angle) * s * 0.2;
                const tipX = x + Math.cos(angle) * s;
                const tipY = y + Math.sin(angle) * s;

                drawCurve([
                    [px, py],
                    [px + Math.cos(angle - 0.4) * s * 0.6, py + Math.sin(angle - 0.4) * s * 0.6,
                     tipX + Math.cos(angle - 0.2) * s * 0.2, tipY + Math.sin(angle - 0.2) * s * 0.2,
                     tipX, tipY],
                    [tipX + Math.cos(angle + 0.2) * s * 0.2, tipY + Math.sin(angle + 0.2) * s * 0.2,
                     px + Math.cos(angle + 0.4) * s * 0.6, py + Math.sin(angle + 0.4) * s * 0.6,
                     px, py]
                ], i % 2 === 0 ? c1 : c2, 1.5);
            }

            drawCurve([
                [x - s * 0.2, y],
                [x - s * 0.2, y - s * 0.2, x + s * 0.2, y - s * 0.2, x + s * 0.2, y],
                [x + s * 0.2, y + s * 0.2, x - s * 0.2, y + s * 0.2, x - s * 0.2, y]
            ], C.yellow2, 1.5);
        }

        function drawTree(x, y, size) {
            const s = size;

            drawCurve([
                [x - s * 0.08, y],
                [x - s * 0.1, y - s * 0.15, x - s * 0.12, y - s * 0.3, x - s * 0.06, y - s * 0.4],
                [x - s * 0.04, y - s * 0.42, x + s * 0.04, y - s * 0.42, x + s * 0.06, y - s * 0.4],
                [x + s * 0.12, y - s * 0.3, x + s * 0.1, y - s * 0.15, x + s * 0.08, y]
            ], C.wood2, 2);

            ctx.strokeStyle = C.wood1;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - s * 0.02, y - s * 0.35);
            ctx.bezierCurveTo(x - s * 0.15, y - s * 0.4, x - s * 0.2, y - s * 0.45, x - s * 0.18, y - s * 0.5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + s * 0.02, y - s * 0.32);
            ctx.bezierCurveTo(x + s * 0.12, y - s * 0.38, x + s * 0.18, y - s * 0.42, x + s * 0.15, y - s * 0.48);
            ctx.stroke();

            const foliage = [
                { cx: 0, cy: -0.6, rx: 0.18, ry: 0.14, c: C.leaf1 },
                { cx: -0.15, cy: -0.52, rx: 0.14, ry: 0.11, c: C.leaf2 },
                { cx: 0.15, cy: -0.5, rx: 0.13, ry: 0.1, c: C.leaf2 },
                { cx: -0.08, cy: -0.65, rx: 0.12, ry: 0.1, c: C.leaf3 },
                { cx: 0.08, cy: -0.63, rx: 0.11, ry: 0.09, c: C.leaf3 },
                { cx: 0, cy: -0.72, rx: 0.1, ry: 0.08, c: C.leaf4 }
            ];

            foliage.forEach(f => {
                const cx = x + f.cx * s;
                const cy = y + f.cy * s;
                const rx = f.rx * s;
                const ry = f.ry * s;

                drawCurve([
                    [cx - rx, cy],
                    [cx - rx, cy - ry * 0.8, cx - rx * 0.5, cy - ry, cx, cy - ry],
                    [cx + rx * 0.5, cy - ry, cx + rx, cy - ry * 0.8, cx + rx, cy],
                    [cx + rx, cy + ry * 0.8, cx + rx * 0.5, cy + ry, cx, cy + ry],
                    [cx - rx * 0.5, cy + ry, cx - rx, cy + ry * 0.8, cx - rx, cy]
                ], f.c, 1.5);
            });
        }

        function drawGreenhouse(x, y, size, stage) {
            const s = size;

            if (stage === 1) {
                // Glass cloche
                drawCurve([
                    [x - s * 0.3, y],
                    [x - s * 0.32, y - s * 0.1, x - s * 0.35, y - s * 0.3, x - s * 0.3, y - s * 0.5],
                    [x - s * 0.2, y - s * 0.7, x + s * 0.2, y - s * 0.7, x + s * 0.3, y - s * 0.5],
                    [x + s * 0.35, y - s * 0.3, x + s * 0.32, y - s * 0.1, x + s * 0.3, y]
                ], C.glass2, 2);
                drawCurve([
                    [x - s * 0.06, y - s * 0.68],
                    [x - s * 0.08, y - s * 0.75, x + s * 0.08, y - s * 0.75, x + s * 0.06, y - s * 0.68]
                ], C.wood2, 1.5);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.moveTo(x - s * 0.22, y - s * 0.15);
                ctx.quadraticCurveTo(x - s * 0.28, y - s * 0.4, x - s * 0.2, y - s * 0.55);
                ctx.quadraticCurveTo(x - s * 0.1, y - s * 0.35, x - s * 0.15, y - s * 0.15);
                ctx.closePath();
                ctx.fill();
            } else if (stage === 2) {
                // Small glass cabinet
                drawCurve([
                    [x - s * 0.4, y],
                    [x - s * 0.42, y - s * 0.08, x + s * 0.42, y - s * 0.08, x + s * 0.4, y]
                ], C.wood2, 2);
                drawCurve([
                    [x - s * 0.35, y - s * 0.08],
                    [x - s * 0.35, y - s * 0.45],
                    [x - s * 0.35, y - s * 0.45, x - s * 0.2, y - s * 0.6, x, y - s * 0.65],
                    [x + s * 0.2, y - s * 0.6, x + s * 0.35, y - s * 0.45, x + s * 0.35, y - s * 0.45],
                    [x + s * 0.35, y - s * 0.08]
                ], C.glass2, 2);
                ctx.strokeStyle = C.wood1;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - s * 0.08);
                ctx.lineTo(x, y - s * 0.65);
                ctx.moveTo(x - s * 0.35, y - s * 0.28);
                ctx.lineTo(x + s * 0.35, y - s * 0.28);
                ctx.stroke();
            } else if (stage === 3) {
                // Greenhouse
                drawCurve([
                    [x - s * 0.45, y],
                    [x - s * 0.45, y - s * 0.1],
                    [x + s * 0.45, y - s * 0.1],
                    [x + s * 0.45, y]
                ], '#a09888', 2);
                ctx.fillStyle = C.glass2;
                ctx.fillRect(x - s * 0.42, y - s * 0.5, s * 0.84, s * 0.4);
                ctx.strokeStyle = C.outline;
                ctx.lineWidth = 2;
                ctx.strokeRect(x - s * 0.42, y - s * 0.5, s * 0.84, s * 0.4);
                ctx.strokeStyle = C.wood1;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x - s * 0.14, y - s * 0.5);
                ctx.lineTo(x - s * 0.14, y - s * 0.1);
                ctx.moveTo(x + s * 0.14, y - s * 0.5);
                ctx.lineTo(x + s * 0.14, y - s * 0.1);
                ctx.moveTo(x - s * 0.42, y - s * 0.3);
                ctx.lineTo(x + s * 0.42, y - s * 0.3);
                ctx.stroke();
                drawCurve([
                    [x - s * 0.48, y - s * 0.5],
                    [x - s * 0.35, y - s * 0.75, x + s * 0.35, y - s * 0.75, x + s * 0.48, y - s * 0.5]
                ], C.glass2, 2);
                drawCurve([
                    [x - s * 0.1, y - s * 0.1],
                    [x - s * 0.1, y - s * 0.38],
                    [x - s * 0.1, y - s * 0.42, x + s * 0.1, y - s * 0.42, x + s * 0.1, y - s * 0.38],
                    [x + s * 0.1, y - s * 0.1]
                ], C.wood3, 2);
            } else {
                // Grand conservatory
                drawCurve([
                    [x - s * 0.55, y],
                    [x - s * 0.55, y - s * 0.1],
                    [x + s * 0.55, y - s * 0.1],
                    [x + s * 0.55, y]
                ], '#b8a898', 2);
                ctx.fillStyle = C.glass2;
                ctx.fillRect(x - s * 0.5, y - s * 0.45, s * 1.0, s * 0.35);
                ctx.strokeStyle = C.outline;
                ctx.lineWidth = 2;
                ctx.strokeRect(x - s * 0.5, y - s * 0.45, s * 1.0, s * 0.35);
                ctx.strokeStyle = C.wood1;
                ctx.lineWidth = 1.5;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(x + i * s * 0.25, y - s * 0.45);
                    ctx.lineTo(x + i * s * 0.25, y - s * 0.1);
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.moveTo(x - s * 0.5, y - s * 0.28);
                ctx.lineTo(x + s * 0.5, y - s * 0.28);
                ctx.stroke();
                drawCurve([
                    [x - s * 0.55, y - s * 0.45],
                    [x - s * 0.45, y - s * 0.7, x - s * 0.2, y - s * 0.88, x, y - s * 0.92],
                    [x + s * 0.2, y - s * 0.88, x + s * 0.45, y - s * 0.7, x + s * 0.55, y - s * 0.45]
                ], C.glass2, 2);
                ctx.fillStyle = 'rgba(255, 248, 230, 0.2)';
                ctx.beginPath();
                ctx.moveTo(x - s * 0.4, y - s * 0.5);
                ctx.quadraticCurveTo(x - s * 0.3, y - s * 0.75, x - s * 0.1, y - s * 0.85);
                ctx.quadraticCurveTo(x - s * 0.25, y - s * 0.65, x - s * 0.25, y - s * 0.5);
                ctx.closePath();
                ctx.fill();
                drawCurve([
                    [x - s * 0.12, y - s * 0.1],
                    [x - s * 0.12, y - s * 0.35],
                    [x - s * 0.12, y - s * 0.42, x + s * 0.12, y - s * 0.42, x + s * 0.12, y - s * 0.35],
                    [x + s * 0.12, y - s * 0.1]
                ], '#d8c8b8', 2);
            }
        }

        function drawPond(x, y, pw, ph) {
            drawCurve([
                [x - pw, y],
                [x - pw * 1.1, y - ph * 0.6, x - pw * 0.5, y - ph, x, y - ph * 0.9],
                [x + pw * 0.5, y - ph, x + pw * 1.1, y - ph * 0.6, x + pw, y],
                [x + pw * 1.1, y + ph * 0.6, x + pw * 0.5, y + ph, x, y + ph * 0.9],
                [x - pw * 0.5, y + ph, x - pw * 1.1, y + ph * 0.6, x - pw, y]
            ], C.water1, 2);
            ctx.fillStyle = C.water3;
            ctx.beginPath();
            ctx.moveTo(x - pw * 0.6, y - ph * 0.3);
            ctx.quadraticCurveTo(x - pw * 0.3, y - ph * 0.6, x + pw * 0.1, y - ph * 0.4);
            ctx.quadraticCurveTo(x - pw * 0.2, y - ph * 0.2, x - pw * 0.5, y - ph * 0.1);
            ctx.closePath();
            ctx.fill();
        }

        function drawKoi(x, y, size, color1, color2) {
            const s = size;
            drawCurve([
                [x + s * 0.5, y],
                [x + s * 0.4, y - s * 0.2, x, y - s * 0.25, x - s * 0.3, y],
                [x, y + s * 0.25, x + s * 0.4, y + s * 0.2, x + s * 0.5, y]
            ], color1, 1.5);
            ctx.fillStyle = color2;
            ctx.beginPath();
            ctx.moveTo(x + s * 0.2, y - s * 0.1);
            ctx.quadraticCurveTo(x, y - s * 0.15, x - s * 0.15, y);
            ctx.quadraticCurveTo(x, y + s * 0.1, x + s * 0.15, y + s * 0.05);
            ctx.closePath();
            ctx.fill();
            drawCurve([
                [x - s * 0.3, y],
                [x - s * 0.5, y - s * 0.2, x - s * 0.6, y - s * 0.25, x - s * 0.55, y],
                [x - s * 0.6, y + s * 0.25, x - s * 0.5, y + s * 0.2, x - s * 0.3, y]
            ], color1, 1);
            ctx.fillStyle = C.outline;
            ctx.beginPath();
            ctx.arc(x + s * 0.35, y - s * 0.05, s * 0.04, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawLilyPad(x, y, size) {
            const s = size;
            ctx.fillStyle = C.leaf3;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x + s * 0.3, y - s * 0.1, x + s * 0.5, y - s * 0.4, x + s * 0.3, y - s * 0.6);
            ctx.bezierCurveTo(x + s * 0.1, y - s * 0.8, x - s * 0.3, y - s * 0.7, x - s * 0.5, y - s * 0.5);
            ctx.bezierCurveTo(x - s * 0.6, y - s * 0.3, x - s * 0.4, y, x, y);
            ctx.fill();
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function drawGardener(x, y, size, pose) {
            const s = size;

            if (pose === 'large') {
                drawCurve([
                    [x - s * 0.25, y],
                    [x - s * 0.3, y - s * 0.15, x - s * 0.28, y - s * 0.35, x - s * 0.2, y - s * 0.5],
                    [x - s * 0.1, y - s * 0.55, x + s * 0.1, y - s * 0.55, x + s * 0.2, y - s * 0.5],
                    [x + s * 0.28, y - s * 0.35, x + s * 0.3, y - s * 0.15, x + s * 0.25, y]
                ], C.cloth1, 2.5);
                drawCurve([
                    [x - s * 0.15, y - s * 0.55],
                    [x - s * 0.18, y - s * 0.65, x - s * 0.15, y - s * 0.78, x, y - s * 0.82],
                    [x + s * 0.15, y - s * 0.78, x + s * 0.18, y - s * 0.65, x + s * 0.15, y - s * 0.55]
                ], C.skin2, 2);
                drawCurve([
                    [x - s * 0.28, y - s * 0.72],
                    [x - s * 0.3, y - s * 0.78, x - s * 0.2, y - s * 0.82, x, y - s * 0.84],
                    [x + s * 0.2, y - s * 0.82, x + s * 0.3, y - s * 0.78, x + s * 0.28, y - s * 0.72]
                ], C.hat2, 2);
                drawCurve([
                    [x - s * 0.15, y - s * 0.78],
                    [x - s * 0.15, y - s * 0.92, x + s * 0.15, y - s * 0.92, x + s * 0.15, y - s * 0.78]
                ], C.hat1, 2);
            } else if (pose === 'medium') {
                drawCurve([
                    [x - s * 0.18, y],
                    [x - s * 0.2, y - s * 0.2, x - s * 0.18, y - s * 0.4, x, y - s * 0.5],
                    [x + s * 0.18, y - s * 0.4, x + s * 0.2, y - s * 0.2, x + s * 0.18, y]
                ], C.cloth1, 2);
                drawCurve([
                    [x - s * 0.1, y - s * 0.5],
                    [x - s * 0.12, y - s * 0.6, x + s * 0.12, y - s * 0.6, x + s * 0.1, y - s * 0.5]
                ], C.skin2, 2);
                drawCurve([
                    [x - s * 0.18, y - s * 0.58],
                    [x - s * 0.15, y - s * 0.68, x + s * 0.15, y - s * 0.68, x + s * 0.18, y - s * 0.58]
                ], C.hat2, 1.5);
                ctx.strokeStyle = C.cloth1;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(x - s * 0.08, y);
                ctx.lineTo(x - s * 0.1, y + s * 0.2);
                ctx.moveTo(x + s * 0.08, y);
                ctx.lineTo(x + s * 0.1, y + s * 0.2);
                ctx.stroke();
                ctx.strokeStyle = C.outline;
                ctx.lineWidth = 2;
                ctx.stroke();
            } else {
                drawCurve([
                    [x - s * 0.12, y],
                    [x - s * 0.15, y - s * 0.25, x + s * 0.15, y - s * 0.25, x + s * 0.12, y]
                ], C.cloth1, 1.5);
                ctx.fillStyle = C.skin2;
                ctx.beginPath();
                ctx.arc(x, y - s * 0.35, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = C.outline;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                drawCurve([
                    [x - s * 0.12, y - s * 0.4],
                    [x - s * 0.1, y - s * 0.5, x + s * 0.1, y - s * 0.5, x + s * 0.12, y - s * 0.4]
                ], C.hat2, 1);
            }
        }

        // ===== STAGE RENDERERS =====
        function renderStage1() {
            // Warm cream wall
            const wallGrad = ctx.createLinearGradient(0, 0, w, h);
            wallGrad.addColorStop(0, '#f8f0e8');
            wallGrad.addColorStop(1, '#f0e8d8');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, w, h);

            // Window frame
            const winPad = w * 0.08;
            const winTop = h * 0.08;
            const winBot = h * 0.52;

            drawCurve([
                [winPad, winBot],
                [winPad, winTop],
                [w - winPad, winTop],
                [w - winPad, winBot]
            ], C.wood2, 4);

            // Sky through window
            const skyGrad = ctx.createLinearGradient(0, winTop, 0, winBot);
            skyGrad.addColorStop(0, '#c8dce8');
            skyGrad.addColorStop(0.7, '#e0ecf4');
            skyGrad.addColorStop(1, '#f0f4f8');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(winPad + 12, winTop + 12, w - winPad * 2 - 24, winBot - winTop - 24);
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 2;
            ctx.strokeRect(winPad + 12, winTop + 12, w - winPad * 2 - 24, winBot - winTop - 24);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(w * 0.35, h * 0.18, w * 0.06, 0, Math.PI * 2);
            ctx.arc(w * 0.48, h * 0.15, w * 0.08, 0, Math.PI * 2);
            ctx.arc(w * 0.62, h * 0.19, w * 0.055, 0, Math.PI * 2);
            ctx.fill();

            // Window divider
            drawCurve([
                [w/2 - 5, winTop + 12],
                [w/2 - 5, winBot - 12],
                [w/2 + 5, winBot - 12],
                [w/2 + 5, winTop + 12]
            ], C.wood2, 2);

            // Warm light
            ctx.fillStyle = 'rgba(255, 245, 220, 0.15)';
            ctx.beginPath();
            ctx.moveTo(w * 0.3, winTop + 12);
            ctx.lineTo(w * 0.15, winBot);
            ctx.lineTo(w * 0.45, winBot);
            ctx.lineTo(w * 0.55, winTop + 12);
            ctx.closePath();
            ctx.fill();

            // Windowsill
            const sillY = h * 0.52;
            drawCurve([
                [w * 0.04, sillY],
                [w * 0.06, sillY - h * 0.02, w * 0.94, sillY - h * 0.02, w * 0.96, sillY],
                [w * 0.96, sillY + h * 0.035],
                [w * 0.04, sillY + h * 0.035]
            ], C.wood3, 3);

            // Large pot
            const potW = w * 0.42;
            const potH = h * 0.18;
            const potY = h * 0.75;
            drawPot(w * 0.5, potY, potW, potH);

            // Seedling
            drawSeedling(w * 0.5, h * 0.57, w * 0.006);

            // Hands
            const handScale = w * 0.003;
            drawHand(w * 0.08, h * 0.68, handScale, false);
            drawHand(w * 0.92, h * 0.68, handScale, true);
        }

        function renderStage2() {
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.4);
            skyGrad.addColorStop(0, C.sky1);
            skyGrad.addColorStop(0.6, C.sky2);
            skyGrad.addColorStop(1, C.sky3);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h * 0.4);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(w * 0.2, h * 0.1, w * 0.07, 0, Math.PI * 2);
            ctx.arc(w * 0.32, h * 0.08, w * 0.085, 0, Math.PI * 2);
            ctx.arc(w * 0.75, h * 0.12, w * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Ground layers
            ctx.fillStyle = C.grass2;
            ctx.fillRect(0, h * 0.4, w, h * 0.6);

            ctx.fillStyle = C.grass3;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.7);
            ctx.quadraticCurveTo(w * 0.3, h * 0.68, w * 0.5, h * 0.72);
            ctx.quadraticCurveTo(w * 0.7, h * 0.76, w, h * 0.7);
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();

            // Horizon
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.4);
            ctx.lineTo(w, h * 0.4);
            ctx.stroke();

            // Side walls
            drawCurve([
                [0, h * 0.38], [0, h * 0.6],
                [w * 0.08, h * 0.58], [w * 0.08, h * 0.38]
            ], '#989080', 2);
            drawCurve([
                [w, h * 0.38], [w, h * 0.6],
                [w * 0.92, h * 0.58], [w * 0.92, h * 0.38]
            ], '#989080', 2);

            // Glass cloche
            drawGreenhouse(w * 0.5, h * 0.52, w * 0.28, 1);

            // Small pond
            drawPond(w * 0.18, h * 0.68, w * 0.1, h * 0.05);

            // Flowers
            drawFlower(w * 0.08, h * 0.52, w * 0.055, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.9, h * 0.55, w * 0.05, [C.orange1, C.orange2, C.orange3]);

            // Small plant
            ctx.strokeStyle = C.leaf2;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(w * 0.28, h * 0.62);
            ctx.quadraticCurveTo(w * 0.27, h * 0.58, w * 0.29, h * 0.54);
            ctx.stroke();
            drawCurve([
                [w * 0.29, h * 0.54],
                [w * 0.24, h * 0.52, w * 0.22, h * 0.54, w * 0.25, h * 0.56]
            ], C.leaf3, 1.5);
            drawCurve([
                [w * 0.29, h * 0.55],
                [w * 0.34, h * 0.53, w * 0.36, h * 0.55, w * 0.33, h * 0.57]
            ], C.leaf4, 1.5);

            // Large gardener
            drawGardener(w * 0.5, h * 0.92, w * 0.25, 'large');
        }

        function renderStage3() {
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.42);
            skyGrad.addColorStop(0, C.sky1);
            skyGrad.addColorStop(0.5, C.sky2);
            skyGrad.addColorStop(1, '#e8f0f4');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h * 0.42);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(w * 0.15, h * 0.1, w * 0.055, 0, Math.PI * 2);
            ctx.arc(w * 0.25, h * 0.08, w * 0.07, 0, Math.PI * 2);
            ctx.arc(w * 0.8, h * 0.12, w * 0.06, 0, Math.PI * 2);
            ctx.fill();

            // Ground layers
            ctx.fillStyle = C.grass1;
            ctx.fillRect(0, h * 0.42, w, h * 0.2);
            ctx.fillStyle = C.grass2;
            ctx.fillRect(0, h * 0.58, w, h * 0.2);
            ctx.fillStyle = C.grass3;
            ctx.fillRect(0, h * 0.76, w, h * 0.24);

            // Horizon
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.42);
            ctx.lineTo(w, h * 0.42);
            ctx.stroke();

            // Path
            drawCurve([
                [w * 0.35, h],
                [w * 0.38, h * 0.85, w * 0.42, h * 0.7, w * 0.48, h * 0.58],
                [w * 0.52, h * 0.58],
                [w * 0.58, h * 0.7, w * 0.62, h * 0.85, w * 0.65, h]
            ], C.earth2, 2);

            // Greenhouse
            drawGreenhouse(w * 0.5, h * 0.52, w * 0.32, 3);

            // Tree
            drawTree(w * 0.88, h * 0.54, w * 0.23);

            // Pond with life
            drawPond(w * 0.18, h * 0.72, w * 0.12, h * 0.06);
            drawKoi(w * 0.2, h * 0.73, w * 0.04, '#e87050', C.white);
            drawLilyPad(w * 0.12, h * 0.7, w * 0.04);

            // Flowers
            drawFlower(w * 0.06, h * 0.55, w * 0.04, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.14, h * 0.52, w * 0.035, [C.orange1, C.orange2, C.orange3]);
            drawFlower(w * 0.22, h * 0.56, w * 0.038, [C.purple1, C.purple2, C.purple3]);
            drawFlower(w * 0.1, h * 0.62, w * 0.032, [C.yellow1, C.yellow2, C.yellow3]);
            drawFlower(w * 0.78, h * 0.54, w * 0.035, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.85, h * 0.58, w * 0.032, [C.purple1, C.purple2, C.purple3]);

            // Medium gardener
            drawGardener(w * 0.5, h * 0.82, w * 0.18, 'medium');
        }

        function renderStage4() {
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.4);
            skyGrad.addColorStop(0, '#b0c8e0');
            skyGrad.addColorStop(0.6, C.sky2);
            skyGrad.addColorStop(1, '#e0ecf0');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h * 0.4);

            // Mountains
            drawCurve([
                [0, h * 0.4],
                [w * 0.1, h * 0.32, w * 0.2, h * 0.28, w * 0.3, h * 0.32],
                [w * 0.4, h * 0.26, w * 0.5, h * 0.22, w * 0.6, h * 0.28],
                [w * 0.7, h * 0.24, w * 0.85, h * 0.2, w, h * 0.3],
                [w, h * 0.4]
            ], '#9aaab8', 2);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(w * 0.12, h * 0.08, w * 0.05, 0, Math.PI * 2);
            ctx.arc(w * 0.22, h * 0.06, w * 0.06, 0, Math.PI * 2);
            ctx.arc(w * 0.7, h * 0.1, w * 0.055, 0, Math.PI * 2);
            ctx.arc(w * 0.82, h * 0.08, w * 0.065, 0, Math.PI * 2);
            ctx.fill();

            // Ground layers
            ctx.fillStyle = '#6a9050';
            ctx.fillRect(0, h * 0.4, w, h * 0.15);
            ctx.fillStyle = C.grass2;
            ctx.fillRect(0, h * 0.52, w, h * 0.15);
            ctx.fillStyle = C.grass3;
            ctx.fillRect(0, h * 0.65, w, h * 0.15);
            ctx.fillStyle = C.grass4;
            ctx.fillRect(0, h * 0.78, w, h * 0.22);

            // Horizon
            ctx.strokeStyle = C.outline;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.4);
            ctx.lineTo(w, h * 0.4);
            ctx.stroke();

            // Winding path
            drawCurve([
                [w * 0.32, h],
                [w * 0.34, h * 0.88, w * 0.38, h * 0.75, w * 0.44, h * 0.62],
                [w * 0.48, h * 0.55, w * 0.52, h * 0.55, w * 0.56, h * 0.62],
                [w * 0.62, h * 0.75, w * 0.66, h * 0.88, w * 0.68, h]
            ], C.earth2, 2);

            // Grand conservatory
            drawGreenhouse(w * 0.5, h * 0.52, w * 0.3, 4);

            // Trees
            drawTree(w * 0.08, h * 0.54, w * 0.18);
            drawTree(w * 0.92, h * 0.5, w * 0.22);

            // Large pond
            drawPond(w * 0.22, h * 0.7, w * 0.11, h * 0.055);
            drawKoi(w * 0.2, h * 0.69, w * 0.032, '#e87050', C.white);
            drawKoi(w * 0.26, h * 0.72, w * 0.026, C.white, '#e87050');
            drawLilyPad(w * 0.15, h * 0.68, w * 0.032);
            drawLilyPad(w * 0.28, h * 0.71, w * 0.026);

            // Many flowers
            drawFlower(w * 0.04, h * 0.52, w * 0.028, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.1, h * 0.5, w * 0.025, [C.orange1, C.orange2, C.orange3]);
            drawFlower(w * 0.16, h * 0.53, w * 0.022, [C.purple1, C.purple2, C.purple3]);
            drawFlower(w * 0.05, h * 0.72, w * 0.038, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.12, h * 0.7, w * 0.035, [C.yellow1, C.yellow2, C.yellow3]);
            drawFlower(w * 0.08, h * 0.78, w * 0.032, [C.purple1, C.purple2, C.purple3]);
            drawFlower(w * 0.82, h * 0.52, w * 0.025, [C.orange1, C.orange2, C.orange3]);
            drawFlower(w * 0.88, h * 0.55, w * 0.022, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.82, h * 0.72, w * 0.035, [C.purple1, C.purple2, C.purple3]);
            drawFlower(w * 0.9, h * 0.7, w * 0.038, [C.rose1, C.rose2, C.rose3]);
            drawFlower(w * 0.86, h * 0.78, w * 0.032, [C.orange1, C.orange2, C.orange3]);
            drawFlower(w * 0.94, h * 0.75, w * 0.028, [C.yellow1, C.yellow2, C.yellow3]);

            // Small distant gardener
            drawGardener(w * 0.5, h * 0.64, w * 0.13, 'small');
        }

        // ===== MAIN RENDER =====
        function render() {
            ctx.clearRect(0, 0, w, h);

            switch (gardenState.stage) {
                case 1: renderStage1(); break;
                case 2: renderStage2(); break;
                case 3: renderStage3(); break;
                case 4: renderStage4(); break;
                default: renderStage1();
            }
        }

        // Initialize
        resizeCanvas();

        // Send data back to Telegram when closing
        if (tg) {
            tg.onEvent('backButtonClicked', () => {
                tg.close();
            });
        }
    </script>
</body>
</html>
