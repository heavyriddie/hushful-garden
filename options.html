<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden Composition Options</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: #1a1a2e;
            color: #e0e0e0;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #f0e8d8;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #a0a0a0;
            font-style: italic;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }
        .option {
            background: #252540;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .option h2 {
            padding: 15px;
            background: #303050;
            font-size: 18px;
            color: #f0e0c0;
        }
        .option-desc {
            padding: 15px;
            font-size: 13px;
            line-height: 1.6;
            color: #b0b0c0;
            border-bottom: 1px solid #404060;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 aspect ratio */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .controls {
            padding: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            background: #202038;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .controls button.growth {
            background: #406040;
            color: #e0f0e0;
        }
        .controls button.growth:hover {
            background: #508050;
        }
        .controls button.growth.active {
            background: #60a060;
            box-shadow: 0 0 10px rgba(96, 160, 96, 0.5);
        }
    </style>
</head>
<body>
    <h1>Garden Composition Options</h1>
    <p class="subtitle">Kawase Hasui-inspired layouts with growth progression</p>

    <div class="options-grid">
        <!-- Option 1 -->
        <div class="option">
            <h2>Option 1: The Winding Path</h2>
            <div class="option-desc">
                <strong>Composition:</strong> S-curve path from bottom center winding to a distant gate/arch.
                Strong foreground-midground-background layering. Gardener large in foreground on the path.
                <br><br>
                <strong>Growth:</strong> Path edges go from bare soil → seedlings → full borders.
                Gate/destination becomes clearer as health improves.
            </div>
            <div class="canvas-container">
                <canvas id="canvas1"></canvas>
            </div>
            <div class="controls">
                <button class="growth active" onclick="setGrowth(1, 0.1)">Seedling</button>
                <button class="growth" onclick="setGrowth(1, 0.4)">Growing</button>
                <button class="growth" onclick="setGrowth(1, 0.7)">Blooming</button>
                <button class="growth" onclick="setGrowth(1, 1.0)">Flourishing</button>
            </div>
        </div>

        <!-- Option 2 -->
        <div class="option">
            <h2>Option 2: The Garden Gate</h2>
            <div class="option-desc">
                <strong>Composition:</strong> Looking INTO garden through an arched gate frame.
                Gate posts and arch create strong framing. Gardener inside, medium-large.
                Path leads eye to a central feature (tree/fountain).
                <br><br>
                <strong>Growth:</strong> Gate vines grow and bloom. Garden inside fills in.
                Central tree grows from sapling to full canopy.
            </div>
            <div class="canvas-container">
                <canvas id="canvas2"></canvas>
            </div>
            <div class="controls">
                <button class="growth active" onclick="setGrowth(2, 0.1)">Seedling</button>
                <button class="growth" onclick="setGrowth(2, 0.4)">Growing</button>
                <button class="growth" onclick="setGrowth(2, 0.7)">Blooming</button>
                <button class="growth" onclick="setGrowth(2, 1.0)">Flourishing</button>
            </div>
        </div>

        <!-- Option 3 -->
        <div class="option">
            <h2>Option 3: The Terraced Garden</h2>
            <div class="option-desc">
                <strong>Composition:</strong> Three horizontal terraces/levels stepping up.
                Strong Hasui-style horizontal bands. Gardener on middle terrace, prominent.
                Steps connect levels. Trees frame sides.
                <br><br>
                <strong>Growth:</strong> Each terrace fills in progressively.
                Lower = established, upper = newer growth. Creates sense of climbing/progress.
            </div>
            <div class="canvas-container">
                <canvas id="canvas3"></canvas>
            </div>
            <div class="controls">
                <button class="growth active" onclick="setGrowth(3, 0.1)">Seedling</button>
                <button class="growth" onclick="setGrowth(3, 0.4)">Growing</button>
                <button class="growth" onclick="setGrowth(3, 0.7)">Blooming</button>
                <button class="growth" onclick="setGrowth(3, 1.0)">Flourishing</button>
            </div>
        </div>

        <!-- Option 4 -->
        <div class="option">
            <h2>Option 4: The Courtyard</h2>
            <div class="option-desc">
                <strong>Composition:</strong> Enclosed courtyard view from above-corner angle.
                Walls on two sides create L-shape frame. Central circular bed with path around.
                Gardener large, tending the central feature.
                <br><br>
                <strong>Growth:</strong> Central bed grows from empty → planted → blooming.
                Wall planters fill in. Climbing plants grow up walls.
            </div>
            <div class="canvas-container">
                <canvas id="canvas4"></canvas>
            </div>
            <div class="controls">
                <button class="growth active" onclick="setGrowth(4, 0.1)">Seedling</button>
                <button class="growth" onclick="setGrowth(4, 0.4)">Growing</button>
                <button class="growth" onclick="setGrowth(4, 0.7)">Blooming</button>
                <button class="growth" onclick="setGrowth(4, 1.0)">Flourishing</button>
            </div>
        </div>

        <!-- Option 5 -->
        <div class="option">
            <h2>Option 5: The Forest Clearing</h2>
            <div class="option-desc">
                <strong>Composition:</strong> Circular clearing in woods. Dark trees frame all sides.
                Sunlight streams into center. Gardener large in the light.
                Winding path exits through gap in trees.
                <br><br>
                <strong>Growth:</strong> Clearing expands as health improves.
                Flowers spread from center outward. Light gets brighter and warmer.
            </div>
            <div class="canvas-container">
                <canvas id="canvas5"></canvas>
            </div>
            <div class="controls">
                <button class="growth active" onclick="setGrowth(5, 0.1)">Seedling</button>
                <button class="growth" onclick="setGrowth(5, 0.4)">Growing</button>
                <button class="growth" onclick="setGrowth(5, 0.7)">Blooming</button>
                <button class="growth" onclick="setGrowth(5, 1.0)">Flourishing</button>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // SHARED UTILITIES
        // ═══════════════════════════════════════════════════════════════════

        const growthStates = { 1: 0.1, 2: 0.1, 3: 0.1, 4: 0.1, 5: 0.1 };
        const canvases = {};
        const contexts = {};

        function initCanvas(id) {
            const canvas = document.getElementById(`canvas${id}`);
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            canvases[id] = canvas;
            contexts[id] = ctx;

            return { canvas, ctx, w: rect.width, h: rect.height };
        }

        function setGrowth(option, value) {
            growthStates[option] = value;

            // Update button states
            const container = document.querySelectorAll('.option')[option - 1];
            container.querySelectorAll('.growth').forEach((btn, i) => {
                const btnValue = [0.1, 0.4, 0.7, 1.0][i];
                btn.classList.toggle('active', Math.abs(btnValue - value) < 0.05);
            });

            renderOption(option);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        // Kawase-style palette
        const palette = {
            skyTop: '#4080a0',
            skyBottom: '#90c8d8',
            ground: '#4a7848',
            groundDark: '#2a5028',
            groundLight: '#6a9858',
            path: '#c8b090',
            pathDark: '#a89070',
            wall: '#b8a888',
            wallDark: '#8a7868',
            wallLight: '#d8c8a8',
            tree: '#1a3020',
            treeMid: '#2a4830',
            treeLight: '#3a6040',
            flowerPink: '#ff6088',
            flowerMagenta: '#e050a0',
            flowerYellow: '#ffc848',
            flowerBlue: '#6090d0',
            flowerWhite: '#f8f0e8',
            flowerPurple: '#9060c0',
            water: '#4080a0'
        };

        // ═══════════════════════════════════════════════════════════════════
        // GARDENER - Larger, more prominent
        // ═══════════════════════════════════════════════════════════════════

        function drawGardener(ctx, x, y, scale, facing = 1) {
            const h = 80 * scale;

            ctx.save();
            ctx.translate(x, y);
            ctx.scale(facing, 1);

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(0, 0, 20 * scale, 8 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#3a4858';
            ctx.fillRect(-8 * scale, -h * 0.38, 7 * scale, h * 0.38);
            ctx.fillRect(1 * scale, -h * 0.38, 7 * scale, h * 0.38);

            // Body - green tunic
            ctx.fillStyle = '#5a7850';
            ctx.beginPath();
            ctx.moveTo(-14 * scale, -h * 0.38);
            ctx.lineTo(-16 * scale, -h * 0.72);
            ctx.lineTo(16 * scale, -h * 0.72);
            ctx.lineTo(14 * scale, -h * 0.38);
            ctx.closePath();
            ctx.fill();

            // Arms
            ctx.fillStyle = '#d8b898';
            ctx.fillRect(-20 * scale, -h * 0.68, 6 * scale, 22 * scale);
            ctx.fillRect(14 * scale, -h * 0.68, 6 * scale, 22 * scale);

            // Head
            ctx.fillStyle = '#e8c0a0';
            ctx.beginPath();
            ctx.arc(0, -h * 0.82, 12 * scale, 0, Math.PI * 2);
            ctx.fill();

            // Hair
            ctx.fillStyle = '#4a3020';
            ctx.beginPath();
            ctx.arc(0, -h * 0.85, 13 * scale, Math.PI * 1.1, Math.PI * 1.9);
            ctx.fill();

            // Straw hat - larger, more prominent
            ctx.fillStyle = '#e8d8a8';
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.92, 22 * scale, 7 * scale, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#d8c898';
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.98, 14 * scale, 10 * scale, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Hat band
            ctx.fillStyle = '#8060a0';
            ctx.fillRect(-14 * scale, -h * 0.94, 28 * scale, 3 * scale);

            // Tool - watering can or hoe
            ctx.fillStyle = '#607080';
            ctx.fillRect(18 * scale, -h * 0.5, 12 * scale, 18 * scale);
            ctx.fillRect(26 * scale, -h * 0.6, 8 * scale, 6 * scale);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // FLOWERS with growth stages
        // ═══════════════════════════════════════════════════════════════════

        function drawFlower(ctx, x, y, color, growth, scale, seed) {
            if (growth < 0.1) return; // Not visible yet

            const stemH = (15 + growth * 25) * scale;

            // Stem
            ctx.strokeStyle = '#3a6030';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + (seededRandom(seed) - 0.5) * 5, y - stemH);
            ctx.stroke();

            if (growth < 0.3) {
                // Just a bud
                ctx.fillStyle = lerpColor('#3a6030', color, 0.3);
                ctx.beginPath();
                ctx.ellipse(x, y - stemH, 3 * scale, 5 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Flower blooming
                const bloomSize = (3 + growth * 6) * scale;
                const petals = 5 + Math.floor(seededRandom(seed + 1) * 3);

                ctx.fillStyle = color;
                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2;
                    const openAmount = Math.min(1, (growth - 0.3) / 0.5);
                    const px = x + Math.cos(angle) * bloomSize * openAmount;
                    const py = y - stemH + Math.sin(angle) * bloomSize * openAmount * 0.7;

                    ctx.beginPath();
                    ctx.ellipse(px, py, bloomSize * 0.6, bloomSize * 0.4, angle, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#ffd848';
                ctx.beginPath();
                ctx.arc(x, y - stemH, bloomSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawFlowerCluster(ctx, x, y, colors, growth, scale, seed) {
            const count = 3 + Math.floor(growth * 5);
            for (let i = 0; i < count; i++) {
                const fx = x + (seededRandom(seed + i * 7) - 0.5) * 30 * scale;
                const fy = y + (seededRandom(seed + i * 11) - 0.5) * 15 * scale;
                const fgrowth = Math.max(0, growth - seededRandom(seed + i * 13) * 0.3);
                const color = colors[i % colors.length];
                drawFlower(ctx, fx, fy, color, fgrowth, scale, seed + i * 100);
            }
        }

        function drawBush(ctx, x, y, growth, scale, seed) {
            if (growth < 0.05) return;

            const size = (10 + growth * 30) * scale;
            const layers = Math.floor(1 + growth * 3);

            for (let i = 0; i < layers; i++) {
                const shade = lerpColor(palette.groundDark, palette.treeLight, i / layers);
                ctx.fillStyle = shade;

                const ox = (seededRandom(seed + i * 7) - 0.5) * size * 0.5;
                const oy = -size * 0.3 * i;
                const r = size * (0.6 + seededRandom(seed + i * 11) * 0.4);

                ctx.beginPath();
                ctx.ellipse(x + ox, y + oy, r, r * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTree(ctx, x, y, growth, scale) {
            if (growth < 0.1) return;

            const h = (30 + growth * 80) * scale;
            const canopySize = (20 + growth * 50) * scale;

            // Trunk
            ctx.fillStyle = palette.tree;
            const trunkW = (4 + growth * 8) * scale;
            ctx.fillRect(x - trunkW/2, y - h * 0.5, trunkW, h * 0.5);

            // Canopy layers
            if (growth > 0.2) {
                const layers = [
                    { y: -h * 0.5, r: canopySize * 0.8 },
                    { y: -h * 0.65, r: canopySize * 0.9 },
                    { y: -h * 0.8, r: canopySize * 0.7 },
                    { y: -h * 0.92, r: canopySize * 0.5 },
                ];

                layers.forEach((layer, i) => {
                    if (growth > 0.2 + i * 0.15) {
                        ctx.fillStyle = i % 2 === 0 ? palette.treeMid : palette.treeLight;
                        ctx.beginPath();
                        ctx.ellipse(x, y + layer.y, layer.r, layer.r * 0.6, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // OPTION 1: The Winding Path
        // ═══════════════════════════════════════════════════════════════════

        function renderOption1() {
            const { ctx, w, h } = initCanvas(1);
            const growth = growthStates[1];

            // Sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, palette.skyTop);
            skyGrad.addColorStop(1, palette.skyBottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Distant hills
            ctx.fillStyle = lerpColor(palette.skyBottom, palette.treeMid, 0.5);
            ctx.beginPath();
            ctx.moveTo(0, h * 0.35);
            for (let x = 0; x <= w; x += 10) {
                ctx.lineTo(x, h * 0.35 + Math.sin(x * 0.02) * 15 + Math.sin(x * 0.007) * 25);
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.fill();

            // Main ground
            ctx.fillStyle = palette.ground;
            ctx.fillRect(0, h * 0.4, w, h * 0.6);

            // Winding S-curve path
            ctx.fillStyle = palette.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.35, h);
            ctx.bezierCurveTo(w * 0.3, h * 0.85, w * 0.6, h * 0.75, w * 0.55, h * 0.6);
            ctx.bezierCurveTo(w * 0.5, h * 0.5, w * 0.3, h * 0.48, w * 0.45, h * 0.38);
            ctx.lineTo(w * 0.52, h * 0.38);
            ctx.bezierCurveTo(w * 0.37, h * 0.48, w * 0.57, h * 0.5, w * 0.62, h * 0.6);
            ctx.bezierCurveTo(w * 0.67, h * 0.75, w * 0.37, h * 0.85, w * 0.45, h);
            ctx.fill();

            // Path edges darker
            ctx.strokeStyle = palette.pathDark;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w * 0.35, h);
            ctx.bezierCurveTo(w * 0.3, h * 0.85, w * 0.6, h * 0.75, w * 0.55, h * 0.6);
            ctx.bezierCurveTo(w * 0.5, h * 0.5, w * 0.3, h * 0.48, w * 0.45, h * 0.38);
            ctx.stroke();

            // Distant gate/arch (more visible with growth)
            if (growth > 0.3) {
                const gateAlpha = (growth - 0.3) / 0.7;
                ctx.fillStyle = `rgba(180, 160, 130, ${gateAlpha})`;
                ctx.fillRect(w * 0.43, h * 0.32, 4, h * 0.08);
                ctx.fillRect(w * 0.53, h * 0.32, 4, h * 0.08);
                ctx.beginPath();
                ctx.arc(w * 0.485, h * 0.32, w * 0.055, Math.PI, 0);
                ctx.fill();
            }

            // Trees framing sides
            drawTree(ctx, w * 0.08, h * 0.55, growth, 0.9);
            drawTree(ctx, w * 0.92, h * 0.52, growth * 0.9, 0.85);

            // Flower borders along path - grow with health
            const flowerColors = [palette.flowerPink, palette.flowerYellow, palette.flowerBlue];

            // Left side of path
            drawFlowerCluster(ctx, w * 0.22, h * 0.75, flowerColors, growth, 1.0, 100);
            drawFlowerCluster(ctx, w * 0.18, h * 0.6, flowerColors, growth * 0.8, 0.9, 200);
            drawBush(ctx, w * 0.15, h * 0.68, growth, 1.0, 300);

            // Right side of path
            drawFlowerCluster(ctx, w * 0.75, h * 0.72, flowerColors, growth, 1.0, 400);
            drawFlowerCluster(ctx, w * 0.8, h * 0.58, flowerColors, growth * 0.8, 0.9, 500);
            drawBush(ctx, w * 0.82, h * 0.65, growth, 1.0, 600);

            // Foreground bushes
            drawBush(ctx, w * 0.1, h * 0.95, growth, 1.3, 700);
            drawBush(ctx, w * 0.88, h * 0.92, growth, 1.2, 800);

            // Gardener - large, on the path
            drawGardener(ctx, w * 0.42, h * 0.78, 1.1, 1);

            // Foreground flowers
            drawFlowerCluster(ctx, w * 0.08, h * 0.98, [palette.flowerMagenta, palette.flowerWhite], growth, 1.2, 900);
            drawFlowerCluster(ctx, w * 0.9, h * 0.96, [palette.flowerPurple, palette.flowerPink], growth, 1.2, 1000);
        }

        // ═══════════════════════════════════════════════════════════════════
        // OPTION 2: The Garden Gate
        // ═══════════════════════════════════════════════════════════════════

        function renderOption2() {
            const { ctx, w, h } = initCanvas(2);
            const growth = growthStates[2];

            // Sky through gate
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.6);
            skyGrad.addColorStop(0, palette.skyTop);
            skyGrad.addColorStop(1, palette.skyBottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Dark frame areas (outside gate)
            ctx.fillStyle = '#1a2818';
            ctx.fillRect(0, 0, w * 0.18, h);
            ctx.fillRect(w * 0.82, 0, w * 0.18, h);
            ctx.fillRect(0, 0, w, h * 0.08);

            // Gate arch frame
            ctx.fillStyle = palette.wall;
            // Left post
            ctx.fillRect(w * 0.12, h * 0.05, w * 0.1, h * 0.95);
            // Right post
            ctx.fillRect(w * 0.78, h * 0.05, w * 0.1, h * 0.95);
            // Arch
            ctx.beginPath();
            ctx.moveTo(w * 0.12, h * 0.35);
            ctx.quadraticCurveTo(w * 0.12, h * 0.05, w * 0.5, h * 0.05);
            ctx.quadraticCurveTo(w * 0.88, h * 0.05, w * 0.88, h * 0.35);
            ctx.lineTo(w * 0.78, h * 0.35);
            ctx.quadraticCurveTo(w * 0.78, h * 0.12, w * 0.5, h * 0.12);
            ctx.quadraticCurveTo(w * 0.22, h * 0.12, w * 0.22, h * 0.35);
            ctx.fill();

            // Garden inside - ground
            ctx.fillStyle = palette.ground;
            ctx.beginPath();
            ctx.moveTo(w * 0.22, h * 0.45);
            ctx.lineTo(w * 0.78, h * 0.45);
            ctx.lineTo(w * 0.88, h);
            ctx.lineTo(w * 0.12, h);
            ctx.fill();

            // Path inside
            ctx.fillStyle = palette.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.4, h);
            ctx.lineTo(w * 0.46, h * 0.5);
            ctx.lineTo(w * 0.54, h * 0.5);
            ctx.lineTo(w * 0.6, h);
            ctx.fill();

            // Central tree - grows from sapling
            drawTree(ctx, w * 0.5, h * 0.55, growth, 1.2);

            // Garden beds on sides
            const flowerColors = [palette.flowerPink, palette.flowerYellow, palette.flowerMagenta];
            drawFlowerCluster(ctx, w * 0.3, h * 0.65, flowerColors, growth, 0.9, 100);
            drawFlowerCluster(ctx, w * 0.7, h * 0.63, flowerColors, growth, 0.9, 200);
            drawBush(ctx, w * 0.25, h * 0.72, growth, 0.8, 300);
            drawBush(ctx, w * 0.75, h * 0.70, growth, 0.8, 400);

            // Vines on gate posts - grow with health
            if (growth > 0.2) {
                const vineGrowth = (growth - 0.2) / 0.8;
                // Left vine
                for (let i = 0; i < 8 * vineGrowth; i++) {
                    const vy = h * 0.9 - i * h * 0.08;
                    ctx.fillStyle = i % 2 ? palette.treeLight : palette.treeMid;
                    ctx.beginPath();
                    ctx.ellipse(w * 0.17, vy, 8, 12, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    if (growth > 0.5 && i < 5) {
                        drawFlower(ctx, w * 0.17, vy, palette.flowerPink, growth - 0.3, 0.7, i * 50);
                    }
                }
                // Right vine
                for (let i = 0; i < 7 * vineGrowth; i++) {
                    const vy = h * 0.88 - i * h * 0.08;
                    ctx.fillStyle = i % 2 ? palette.treeMid : palette.treeLight;
                    ctx.beginPath();
                    ctx.ellipse(w * 0.83, vy, 8, 12, -0.3, 0, Math.PI * 2);
                    ctx.fill();

                    if (growth > 0.5 && i < 4) {
                        drawFlower(ctx, w * 0.83, vy, palette.flowerPurple, growth - 0.3, 0.7, i * 50 + 500);
                    }
                }
            }

            // Gardener inside garden
            drawGardener(ctx, w * 0.38, h * 0.82, 1.0, 1);

            // Foreground flowers
            drawFlowerCluster(ctx, w * 0.2, h * 0.95, [palette.flowerWhite, palette.flowerYellow], growth, 1.1, 600);
            drawFlowerCluster(ctx, w * 0.8, h * 0.93, [palette.flowerBlue, palette.flowerWhite], growth, 1.1, 700);
        }

        // ═══════════════════════════════════════════════════════════════════
        // OPTION 3: The Terraced Garden
        // ═══════════════════════════════════════════════════════════════════

        function renderOption3() {
            const { ctx, w, h } = initCanvas(3);
            const growth = growthStates[3];

            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.4);
            skyGrad.addColorStop(0, palette.skyTop);
            skyGrad.addColorStop(1, palette.skyBottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Three terraces - horizontal bands (Hasui style)
            const terraces = [
                { y: 0.35, h: 0.2, growth: growth * 0.7 },  // Top/furthest
                { y: 0.52, h: 0.22, growth: growth * 0.9 }, // Middle
                { y: 0.72, h: 0.28, growth: growth },        // Bottom/nearest
            ];

            // Terrace walls (retaining walls)
            terraces.forEach((t, i) => {
                // Wall face
                ctx.fillStyle = i === 2 ? palette.wallDark : palette.wall;
                ctx.fillRect(0, h * t.y, w, h * 0.04);

                // Ground
                const groundShade = lerpColor(palette.groundDark, palette.ground, i / 2);
                ctx.fillStyle = groundShade;
                ctx.fillRect(0, h * (t.y + 0.04), w, h * (t.h - 0.04));
            });

            // Stone steps on left
            ctx.fillStyle = palette.path;
            for (let i = 0; i < 3; i++) {
                const sy = h * (0.39 + i * 0.18);
                ctx.fillRect(w * 0.08, sy, w * 0.12, h * 0.05);
                ctx.fillStyle = palette.pathDark;
                ctx.fillRect(w * 0.08, sy + h * 0.04, w * 0.12, h * 0.01);
                ctx.fillStyle = palette.path;
            }

            // Trees framing
            drawTree(ctx, w * 0.05, h * 0.5, growth, 1.1);
            drawTree(ctx, w * 0.95, h * 0.48, growth * 0.9, 1.0);

            // Plants on each terrace
            const flowerColors = [palette.flowerPink, palette.flowerYellow, palette.flowerBlue, palette.flowerMagenta];

            // Top terrace - sparse
            drawFlowerCluster(ctx, w * 0.4, h * 0.52, flowerColors, terraces[0].growth, 0.7, 100);
            drawBush(ctx, w * 0.7, h * 0.5, terraces[0].growth, 0.6, 150);

            // Middle terrace - medium
            drawFlowerCluster(ctx, w * 0.3, h * 0.7, flowerColors, terraces[1].growth, 0.85, 200);
            drawFlowerCluster(ctx, w * 0.6, h * 0.68, flowerColors, terraces[1].growth, 0.85, 250);
            drawBush(ctx, w * 0.8, h * 0.69, terraces[1].growth, 0.8, 300);

            // Gardener on middle terrace - prominent
            drawGardener(ctx, w * 0.45, h * 0.71, 1.15, 1);

            // Bottom terrace - lush
            drawFlowerCluster(ctx, w * 0.25, h * 0.9, flowerColors, terraces[2].growth, 1.0, 400);
            drawFlowerCluster(ctx, w * 0.5, h * 0.88, flowerColors, terraces[2].growth, 1.0, 450);
            drawFlowerCluster(ctx, w * 0.75, h * 0.92, flowerColors, terraces[2].growth, 1.0, 500);
            drawBush(ctx, w * 0.15, h * 0.95, terraces[2].growth, 1.1, 550);
            drawBush(ctx, w * 0.85, h * 0.93, terraces[2].growth, 1.0, 600);

            // Foreground detail
            drawFlowerCluster(ctx, w * 0.1, h * 0.98, [palette.flowerWhite, palette.flowerPink], growth, 1.2, 700);
        }

        // ═══════════════════════════════════════════════════════════════════
        // OPTION 4: The Courtyard
        // ═══════════════════════════════════════════════════════════════════

        function renderOption4() {
            const { ctx, w, h } = initCanvas(4);
            const growth = growthStates[4];

            // Sky in corner
            ctx.fillStyle = palette.skyTop;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h * 0.3);
            ctx.lineTo(0, h * 0.45);
            ctx.fill();

            // Back wall (horizontal)
            ctx.fillStyle = palette.wall;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.45);
            ctx.lineTo(w, h * 0.3);
            ctx.lineTo(w, h * 0.5);
            ctx.lineTo(0, h * 0.65);
            ctx.fill();

            // Wall texture
            ctx.fillStyle = palette.wallDark;
            for (let i = 0; i < 12; i++) {
                const wx = w * (i / 12);
                const wy1 = h * (0.45 - i * 0.012);
                ctx.fillRect(wx, wy1, 2, h * 0.18);
            }

            // Side wall (left, vertical)
            ctx.fillStyle = palette.wallLight;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.45);
            ctx.lineTo(0, h);
            ctx.lineTo(w * 0.25, h);
            ctx.lineTo(w * 0.25, h * 0.55);
            ctx.fill();

            // Ground
            ctx.fillStyle = palette.ground;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.65);
            ctx.lineTo(w, h * 0.5);
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.fill();

            // Circular center bed
            const bedX = w * 0.55;
            const bedY = h * 0.72;

            // Bed border (stone)
            ctx.fillStyle = palette.pathDark;
            ctx.beginPath();
            ctx.ellipse(bedX, bedY, w * 0.22, h * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Soil/planted area
            ctx.fillStyle = palette.groundDark;
            ctx.beginPath();
            ctx.ellipse(bedX, bedY, w * 0.19, h * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Path around bed
            ctx.fillStyle = palette.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.25, h);
            ctx.lineTo(w * 0.25, h * 0.65);
            ctx.lineTo(w * 0.35, h * 0.62);
            ctx.lineTo(w * 0.35, h);
            ctx.fill();

            // Plants in center bed - grow from nothing to full
            const flowerColors = [palette.flowerPink, palette.flowerMagenta, palette.flowerYellow, palette.flowerPurple];

            if (growth > 0.1) {
                // Central feature plant
                drawBush(ctx, bedX, bedY - h * 0.05, growth, 1.2, 100);

                // Ring of flowers
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const fx = bedX + Math.cos(angle) * w * 0.14;
                    const fy = bedY + Math.sin(angle) * h * 0.07;
                    drawFlower(ctx, fx, fy, flowerColors[i % 4], growth, 0.9, i * 100);
                }
            }

            // Wall planters
            if (growth > 0.3) {
                const planterGrowth = (growth - 0.3) / 0.7;
                // Back wall planters
                drawFlowerCluster(ctx, w * 0.3, h * 0.58, flowerColors, planterGrowth, 0.7, 300);
                drawFlowerCluster(ctx, w * 0.7, h * 0.48, flowerColors, planterGrowth, 0.7, 400);

                // Side wall climbing plants
                for (let i = 0; i < 4 * planterGrowth; i++) {
                    ctx.fillStyle = palette.treeMid;
                    ctx.beginPath();
                    ctx.ellipse(w * 0.12, h * (0.9 - i * 0.1), 10, 15, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Potted plants
            // Pot
            ctx.fillStyle = '#a06040';
            ctx.beginPath();
            ctx.moveTo(w * 0.8, h * 0.85);
            ctx.lineTo(w * 0.77, h * 0.75);
            ctx.lineTo(w * 0.87, h * 0.75);
            ctx.lineTo(w * 0.84, h * 0.85);
            ctx.fill();
            drawFlowerCluster(ctx, w * 0.82, h * 0.73, [palette.flowerBlue, palette.flowerWhite], growth, 0.8, 500);

            // Gardener tending center bed - large
            drawGardener(ctx, w * 0.42, h * 0.88, 1.2, 1);

            // Corner detail
            drawBush(ctx, w * 0.92, h * 0.95, growth, 1.0, 600);
        }

        // ═══════════════════════════════════════════════════════════════════
        // OPTION 5: The Forest Clearing
        // ═══════════════════════════════════════════════════════════════════

        function renderOption5() {
            const { ctx, w, h } = initCanvas(5);
            const growth = growthStates[5];

            // Background - dark forest
            ctx.fillStyle = '#0a1810';
            ctx.fillRect(0, 0, w, h);

            // Light in clearing - gets brighter with growth
            const lightIntensity = 0.3 + growth * 0.5;
            const clearingGrad = ctx.createRadialGradient(
                w * 0.5, h * 0.4, 0,
                w * 0.5, h * 0.5, w * (0.3 + growth * 0.2)
            );
            clearingGrad.addColorStop(0, lerpColor('#90c8a0', '#f0e8d0', growth));
            clearingGrad.addColorStop(0.6, lerpColor('#406040', '#80a870', growth));
            clearingGrad.addColorStop(1, '#1a2818');
            ctx.fillStyle = clearingGrad;
            ctx.fillRect(0, 0, w, h);

            // Sky peek through trees - more visible with growth
            if (growth > 0.3) {
                ctx.fillStyle = lerpColor(palette.skyTop, palette.skyBottom, 0.5);
                ctx.globalAlpha = (growth - 0.3) * 0.8;
                ctx.beginPath();
                ctx.ellipse(w * 0.5, h * 0.15, w * 0.15 * growth, h * 0.1 * growth, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // Dark trees framing - all around edges
            const treePositions = [
                { x: 0.02, y: 0.4 }, { x: 0.08, y: 0.5 },
                { x: 0.95, y: 0.42 }, { x: 0.88, y: 0.52 },
                { x: 0.15, y: 0.35 }, { x: 0.85, y: 0.38 },
                { x: 0, y: 0.55 }, { x: 1, y: 0.5 },
            ];

            treePositions.forEach((pos, i) => {
                // Dark tree silhouettes
                ctx.fillStyle = '#0a1510';
                const tx = w * pos.x;
                const ty = h * pos.y;

                // Trunk
                ctx.fillRect(tx - 8, ty, 16, h - ty);

                // Canopy
                ctx.beginPath();
                ctx.ellipse(tx, ty - 20, 50 + i * 5, 80, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tx, ty - 60, 40 + i * 3, 60, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Ground in clearing
            const groundY = h * 0.55;
            ctx.fillStyle = palette.ground;
            ctx.beginPath();
            ctx.ellipse(w * 0.5, groundY + h * 0.2, w * (0.35 + growth * 0.1), h * 0.25, 0, 0, Math.PI * 2);
            ctx.fill();

            // Winding path exiting through trees
            ctx.fillStyle = palette.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.42, h);
            ctx.bezierCurveTo(w * 0.45, h * 0.85, w * 0.4, h * 0.7, w * 0.48, h * 0.55);
            ctx.bezierCurveTo(w * 0.55, h * 0.45, w * 0.52, h * 0.35, w * 0.5, h * 0.25);
            ctx.lineTo(w * 0.53, h * 0.25);
            ctx.bezierCurveTo(w * 0.55, h * 0.35, w * 0.58, h * 0.45, w * 0.52, h * 0.55);
            ctx.bezierCurveTo(w * 0.44, h * 0.7, w * 0.49, h * 0.85, w * 0.48, h);
            ctx.fill();

            // Flowers spreading from center - more with growth
            const flowerColors = [palette.flowerPink, palette.flowerYellow, palette.flowerWhite, palette.flowerBlue];
            const flowerCount = Math.floor(growth * 15);

            for (let i = 0; i < flowerCount; i++) {
                const angle = seededRandom(i * 17) * Math.PI * 2;
                const dist = seededRandom(i * 23) * w * 0.25 * growth;
                const fx = w * 0.5 + Math.cos(angle) * dist;
                const fy = h * 0.65 + Math.sin(angle) * dist * 0.4;

                if (fx > w * 0.2 && fx < w * 0.8) {
                    drawFlower(ctx, fx, fy, flowerColors[i % 4], growth, 0.8, i * 100);
                }
            }

            // Bushes at clearing edge
            drawBush(ctx, w * 0.25, h * 0.7, growth * 0.8, 0.9, 200);
            drawBush(ctx, w * 0.75, h * 0.68, growth * 0.8, 0.85, 300);

            // Gardener in the light - large, central
            drawGardener(ctx, w * 0.5, h * 0.78, 1.25, 1);

            // Sunbeams (if growth is high)
            if (growth > 0.6) {
                ctx.strokeStyle = `rgba(255, 248, 220, ${(growth - 0.6) * 0.3})`;
                ctx.lineWidth = 3;
                for (let i = 0; i < 5; i++) {
                    const bx = w * (0.35 + i * 0.08);
                    ctx.beginPath();
                    ctx.moveTo(bx, h * 0.1);
                    ctx.lineTo(bx + (i - 2) * 20, h * 0.5);
                    ctx.stroke();
                }
            }

            // Foreground dark foliage
            ctx.fillStyle = '#0a1510';
            ctx.beginPath();
            ctx.ellipse(w * 0.05, h * 1.05, 60, 100, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(w * 0.95, h * 1.02, 50, 90, 0.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ═══════════════════════════════════════════════════════════════════
        // RENDER ALL
        // ═══════════════════════════════════════════════════════════════════

        function renderOption(n) {
            switch(n) {
                case 1: renderOption1(); break;
                case 2: renderOption2(); break;
                case 3: renderOption3(); break;
                case 4: renderOption4(); break;
                case 5: renderOption5(); break;
            }
        }

        function renderAll() {
            for (let i = 1; i <= 5; i++) {
                renderOption(i);
            }
        }

        // Initial render
        window.addEventListener('load', renderAll);
        window.addEventListener('resize', renderAll);
    </script>
</body>
</html>
