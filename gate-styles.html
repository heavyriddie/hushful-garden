<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden Gate - Style Variations</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Georgia', serif;
            background: #12121a;
            color: #e0e0e0;
            padding: 20px;
        }
        h1 {
            text-align: center;
            margin-bottom: 8px;
            color: #f0e8d8;
        }
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #a0a0a0;
            font-style: italic;
        }
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 25px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .option {
            background: #1a1a28;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        .option h2 {
            padding: 12px 15px;
            background: #252538;
            font-size: 16px;
            color: #f0e0c0;
        }
        .option-desc {
            padding: 12px 15px;
            font-size: 12px;
            line-height: 1.5;
            color: #a0a0b0;
            border-bottom: 1px solid #303045;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 133%; /* Taller aspect for phone */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .controls {
            padding: 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            background: #18182a;
        }
        .controls button {
            padding: 6px 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            background: #354035;
            color: #d0e0d0;
            transition: all 0.2s;
        }
        .controls button:hover { background: #456045; }
        .controls button.active {
            background: #5a8a5a;
            box-shadow: 0 0 8px rgba(90, 138, 90, 0.4);
        }
    </style>
</head>
<body>
    <h1>The Garden Gate - Style Variations</h1>
    <p class="subtitle">5 distinct artistic approaches to the same composition</p>

    <div class="options-grid">
        <!-- Style A: Kawase Hasui -->
        <div class="option">
            <h2>A: Kawase Hasui Woodblock</h2>
            <div class="option-desc">
                Bold flat color blocks, strong silhouettes, atmospheric gradients.
                Limited palette with high saturation. Distinct layers with no blending.
                Evening/twilight mood with warm sky against cool shadows.
            </div>
            <div class="canvas-container">
                <canvas id="canvasA"></canvas>
            </div>
            <div class="controls">
                <button class="active" onclick="setGrowth('A', 0.15)">Sparse</button>
                <button onclick="setGrowth('A', 0.45)">Growing</button>
                <button onclick="setGrowth('A', 0.75)">Blooming</button>
                <button onclick="setGrowth('A', 1.0)">Lush</button>
            </div>
        </div>

        <!-- Style B: Storybook Illustration -->
        <div class="option">
            <h2>B: Storybook Illustration</h2>
            <div class="option-desc">
                Soft, painterly edges. Warm golden light. Rich textures suggesting
                hand-painted quality. Cozy, inviting atmosphere like a children's book.
                Gentle color transitions, rounded forms, nostalgic warmth.
            </div>
            <div class="canvas-container">
                <canvas id="canvasB"></canvas>
            </div>
            <div class="controls">
                <button class="active" onclick="setGrowth('B', 0.15)">Sparse</button>
                <button onclick="setGrowth('B', 0.45)">Growing</button>
                <button onclick="setGrowth('B', 0.75)">Blooming</button>
                <button onclick="setGrowth('B', 1.0)">Lush</button>
            </div>
        </div>

        <!-- Style C: Ghibli Pastoral -->
        <div class="option">
            <h2>C: Ghibli Pastoral</h2>
            <div class="option-desc">
                Dreamy, luminous quality. Soft greens and sky blues. Gentle movement
                in foliage. Dappled light through leaves. Peaceful, meditative mood.
                Emphasis on natural beauty and quiet moments.
            </div>
            <div class="canvas-container">
                <canvas id="canvasC"></canvas>
            </div>
            <div class="controls">
                <button class="active" onclick="setGrowth('C', 0.15)">Sparse</button>
                <button onclick="setGrowth('C', 0.45)">Growing</button>
                <button onclick="setGrowth('C', 0.75)">Blooming</button>
                <button onclick="setGrowth('C', 1.0)">Lush</button>
            </div>
        </div>

        <!-- Style D: Paper Cut / Layered -->
        <div class="option">
            <h2>D: Paper Cut Layers</h2>
            <div class="option-desc">
                Distinct depth layers like cut paper. Strong parallax feeling.
                Crisp edges, flat colors within each layer. Graphic, modern aesthetic.
                Each depth plane has its own color temperature.
            </div>
            <div class="canvas-container">
                <canvas id="canvasD"></canvas>
            </div>
            <div class="controls">
                <button class="active" onclick="setGrowth('D', 0.15)">Sparse</button>
                <button onclick="setGrowth('D', 0.45)">Growing</button>
                <button onclick="setGrowth('D', 0.75)">Blooming</button>
                <button onclick="setGrowth('D', 1.0)">Lush</button>
            </div>
        </div>

        <!-- Style E: Moody Romantic -->
        <div class="option">
            <h2>E: Moody Romantic</h2>
            <div class="option-desc">
                Rich, deep colors. Dramatic light and shadow. Jewel tones against
                dark backgrounds. Mysterious, enchanted garden feeling.
                Inspired by Victorian botanical art and secret garden aesthetics.
            </div>
            <div class="canvas-container">
                <canvas id="canvasE"></canvas>
            </div>
            <div class="controls">
                <button class="active" onclick="setGrowth('E', 0.15)">Sparse</button>
                <button onclick="setGrowth('E', 0.45)">Growing</button>
                <button onclick="setGrowth('E', 0.75)">Blooming</button>
                <button onclick="setGrowth('E', 1.0)">Lush</button>
            </div>
        </div>
    </div>

    <script>
        const growthStates = { A: 0.15, B: 0.15, C: 0.15, D: 0.15, E: 0.15 };
        const canvases = {};
        const contexts = {};

        function initCanvas(id) {
            const canvas = document.getElementById(`canvas${id}`);
            const ctx = canvas.getContext('2d');
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = Math.min(window.devicePixelRatio || 1, 2);

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            canvases[id] = canvas;
            contexts[id] = ctx;

            return { canvas, ctx, w: rect.width, h: rect.height };
        }

        function setGrowth(style, value) {
            growthStates[style] = value;
            const options = document.querySelectorAll('.option');
            const idx = ['A','B','C','D','E'].indexOf(style);
            options[idx].querySelectorAll('.controls button').forEach((btn, i) => {
                const vals = [0.15, 0.45, 0.75, 1.0];
                btn.classList.toggle('active', Math.abs(vals[i] - value) < 0.05);
            });
            renderStyle(style);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        // ═══════════════════════════════════════════════════════════════════
        // STYLE A: KAWASE HASUI WOODBLOCK
        // ═══════════════════════════════════════════════════════════════════

        function renderStyleA() {
            const { ctx, w, h } = initCanvas('A');
            const growth = growthStates.A;

            // Palette - bold, limited, high contrast
            const p = {
                skyTop: '#2a3860',
                skyMid: '#6050a0',
                skyLow: '#d07090',
                skyHorizon: '#f8a080',
                stone: '#8a7868',
                stoneDark: '#5a4838',
                stoneLight: '#b8a888',
                gardenGround: '#2a5838',
                gardenLight: '#3a7848',
                path: '#c8a878',
                pathDark: '#a08058',
                treeDark: '#1a2820',
                treeMid: '#2a4830',
                flowerPink: '#ff5080',
                flowerMagenta: '#e040a0',
                flowerYellow: '#ffc830',
                flowerWhite: '#f8f0e8'
            };

            // SKY - Bold gradient bands
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.45);
            skyGrad.addColorStop(0, p.skyTop);
            skyGrad.addColorStop(0.4, p.skyMid);
            skyGrad.addColorStop(0.75, p.skyLow);
            skyGrad.addColorStop(1, p.skyHorizon);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // GATE FRAME - Dark silhouette
            ctx.fillStyle = p.stoneDark;
            // Left pillar
            ctx.fillRect(0, 0, w * 0.2, h);
            // Right pillar
            ctx.fillRect(w * 0.8, 0, w * 0.2, h);
            // Arch top
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h * 0.25);
            ctx.quadraticCurveTo(w * 0.5, h * 0.08, 0, h * 0.25);
            ctx.fill();

            // Inner arch edge - stone color
            ctx.fillStyle = p.stone;
            ctx.beginPath();
            ctx.moveTo(w * 0.2, h * 0.2);
            ctx.quadraticCurveTo(w * 0.5, h * 0.12, w * 0.8, h * 0.2);
            ctx.lineTo(w * 0.8, h * 0.25);
            ctx.quadraticCurveTo(w * 0.5, h * 0.16, w * 0.2, h * 0.25);
            ctx.fill();
            // Pillar inner edges
            ctx.fillRect(w * 0.17, h * 0.2, w * 0.05, h * 0.8);
            ctx.fillRect(w * 0.78, h * 0.2, w * 0.05, h * 0.8);

            // GARDEN GROUND - Flat color
            ctx.fillStyle = p.gardenGround;
            ctx.beginPath();
            ctx.moveTo(w * 0.2, h * 0.4);
            ctx.lineTo(w * 0.8, h * 0.4);
            ctx.lineTo(w * 0.83, h);
            ctx.lineTo(w * 0.17, h);
            ctx.fill();

            // PATH - Bold stripe
            ctx.fillStyle = p.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.38, h);
            ctx.lineTo(w * 0.44, h * 0.42);
            ctx.lineTo(w * 0.56, h * 0.42);
            ctx.lineTo(w * 0.62, h);
            ctx.fill();

            // Path edge
            ctx.strokeStyle = p.pathDark;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(w * 0.38, h);
            ctx.lineTo(w * 0.44, h * 0.42);
            ctx.moveTo(w * 0.62, h);
            ctx.lineTo(w * 0.56, h * 0.42);
            ctx.stroke();

            // CENTRAL TREE - Bold silhouette style
            const treeH = (0.15 + growth * 0.35) * h;
            const treeW = (0.08 + growth * 0.2) * w;

            // Trunk
            ctx.fillStyle = p.treeDark;
            ctx.fillRect(w * 0.48, h * 0.5 - treeH * 0.3, w * 0.04, treeH * 0.4);

            // Canopy - layered flat shapes
            if (growth > 0.2) {
                ctx.fillStyle = p.treeDark;
                ctx.beginPath();
                ctx.ellipse(w * 0.5, h * 0.5 - treeH * 0.5, treeW * 0.9, treeH * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.treeMid;
                ctx.beginPath();
                ctx.ellipse(w * 0.5, h * 0.5 - treeH * 0.6, treeW * 0.7, treeH * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // FLOWERS - Bold simple shapes
            const flowerColors = [p.flowerPink, p.flowerMagenta, p.flowerYellow, p.flowerWhite];

            function drawHasuiFlower(x, y, color, size) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                // Simple highlight
                ctx.fillStyle = lerpColor(color, '#ffffff', 0.4);
                ctx.beginPath();
                ctx.arc(x - size * 0.2, y - size * 0.2, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Garden beds
            const flowerCount = Math.floor(8 + growth * 20);
            for (let i = 0; i < flowerCount; i++) {
                const side = i % 2;
                const baseX = side === 0 ? w * 0.28 : w * 0.72;
                const fx = baseX + (seededRandom(i * 7) - 0.5) * w * 0.12;
                const fy = h * (0.5 + seededRandom(i * 11) * 0.4);
                const fgrowth = Math.max(0, growth - seededRandom(i * 13) * 0.3);

                if (fgrowth > 0.1) {
                    const size = (3 + fgrowth * 8) * (0.7 + seededRandom(i * 17) * 0.5);
                    drawHasuiFlower(fx, fy, flowerColors[i % 4], size);
                }
            }

            // VINES on gate - bold shapes
            if (growth > 0.3) {
                const vineGrowth = (growth - 0.3) / 0.7;
                ctx.fillStyle = p.treeMid;

                // Left vine
                for (let i = 0; i < Math.floor(6 * vineGrowth); i++) {
                    const vy = h * (0.85 - i * 0.1);
                    ctx.beginPath();
                    ctx.ellipse(w * 0.18, vy, 12, 18, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    if (growth > 0.6) {
                        drawHasuiFlower(w * 0.18, vy - 10, p.flowerPink, 5);
                    }
                }

                // Right vine
                for (let i = 0; i < Math.floor(5 * vineGrowth); i++) {
                    const vy = h * (0.8 - i * 0.1);
                    ctx.beginPath();
                    ctx.ellipse(w * 0.82, vy, 12, 18, -0.3, 0, Math.PI * 2);
                    ctx.fill();

                    if (growth > 0.6) {
                        drawHasuiFlower(w * 0.82, vy - 10, p.flowerMagenta, 5);
                    }
                }
            }

            // GARDENER - Bold, simple shapes
            drawGardenerHasui(ctx, w * 0.5, h * 0.82, w, h, 1);

            // Foreground flowers
            for (let i = 0; i < 6; i++) {
                const fx = w * (0.22 + seededRandom(i * 31) * 0.1);
                const fy = h * (0.92 + seededRandom(i * 37) * 0.06);
                drawHasuiFlower(fx, fy, flowerColors[i % 4], 6 + growth * 6);
            }
            for (let i = 0; i < 6; i++) {
                const fx = w * (0.72 + seededRandom(i * 41) * 0.1);
                const fy = h * (0.9 + seededRandom(i * 43) * 0.08);
                drawHasuiFlower(fx, fy, flowerColors[(i + 2) % 4], 6 + growth * 6);
            }
        }

        function drawGardenerHasui(ctx, x, y, w, h, facing) {
            const scale = 0.14;
            const gh = h * scale;

            ctx.save();
            ctx.translate(x, y);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(0, 0, gh * 0.35, gh * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body - simple trapezoid
            ctx.fillStyle = '#4a6848';
            ctx.beginPath();
            ctx.moveTo(-gh * 0.2, 0);
            ctx.lineTo(-gh * 0.25, -gh * 0.45);
            ctx.lineTo(gh * 0.25, -gh * 0.45);
            ctx.lineTo(gh * 0.2, 0);
            ctx.fill();

            // Head
            ctx.fillStyle = '#e8c8a8';
            ctx.beginPath();
            ctx.arc(0, -gh * 0.58, gh * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Hat - bold shape
            ctx.fillStyle = '#d8c888';
            ctx.beginPath();
            ctx.ellipse(0, -gh * 0.68, gh * 0.32, gh * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(0, -gh * 0.75, gh * 0.18, gh * 0.12, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Hat band
            ctx.fillStyle = '#8060a0';
            ctx.fillRect(-gh * 0.18, -gh * 0.7, gh * 0.36, gh * 0.04);

            // Watering can
            ctx.fillStyle = '#506070';
            ctx.fillRect(gh * 0.2, -gh * 0.35, gh * 0.18, gh * 0.22);
            ctx.fillRect(gh * 0.32, -gh * 0.42, gh * 0.1, gh * 0.08);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // STYLE B: STORYBOOK ILLUSTRATION
        // ═══════════════════════════════════════════════════════════════════

        function renderStyleB() {
            const { ctx, w, h } = initCanvas('B');
            const growth = growthStates.B;

            // Warm, golden palette
            const p = {
                skyTop: '#6890b8',
                skyBottom: '#f8e0b0',
                stoneWarm: '#c8a878',
                stoneShadow: '#8a7058',
                stoneHighlight: '#e8d8b8',
                groundGreen: '#5a8848',
                groundWarm: '#7aa858',
                pathGold: '#e8c888',
                pathShadow: '#c8a060',
                foliageDark: '#3a5830',
                foliageMid: '#5a8848',
                foliageLight: '#8ab868',
                flowerRose: '#e87088',
                flowerPeach: '#f8a878',
                flowerCream: '#f8f0d8',
                flowerLavender: '#a888c8'
            };

            // Warm sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, p.skyTop);
            skyGrad.addColorStop(1, p.skyBottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Soft clouds
            ctx.fillStyle = 'rgba(255, 250, 240, 0.6)';
            for (let i = 0; i < 4; i++) {
                const cx = w * (0.2 + seededRandom(i * 7) * 0.6);
                const cy = h * (0.1 + seededRandom(i * 11) * 0.15);
                for (let j = 0; j < 3; j++) {
                    ctx.beginPath();
                    ctx.arc(cx + j * 15 - 15, cy, 18 + seededRandom(i * j) * 12, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Gate frame with soft edges
            // Outer shadow
            ctx.fillStyle = p.stoneShadow;
            roundedGateFrame(ctx, w, h, 0.18, 0.82, 0.06);

            // Main stone
            ctx.fillStyle = p.stoneWarm;
            roundedGateFrame(ctx, w, h, 0.19, 0.81, 0.07);

            // Highlight edge
            ctx.fillStyle = p.stoneHighlight;
            ctx.fillRect(w * 0.19, h * 0.25, w * 0.02, h * 0.7);
            ctx.fillRect(w * 0.79, h * 0.25, w * 0.02, h * 0.7);

            // Stone texture
            ctx.fillStyle = p.stoneShadow;
            for (let i = 0; i < 20; i++) {
                const sx = seededRandom(i * 7) < 0.5 ?
                    w * (0.02 + seededRandom(i * 11) * 0.14) :
                    w * (0.84 + seededRandom(i * 13) * 0.14);
                const sy = h * (0.2 + seededRandom(i * 17) * 0.75);
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(sx, sy, 3 + seededRandom(i * 19) * 5, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Garden ground - soft gradient
            const groundGrad = ctx.createLinearGradient(0, h * 0.35, 0, h);
            groundGrad.addColorStop(0, p.groundGreen);
            groundGrad.addColorStop(1, p.groundWarm);
            ctx.fillStyle = groundGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.19, h * 0.38);
            ctx.quadraticCurveTo(w * 0.5, h * 0.35, w * 0.81, h * 0.38);
            ctx.lineTo(w * 0.85, h);
            ctx.lineTo(w * 0.15, h);
            ctx.fill();

            // Soft path
            ctx.fillStyle = p.pathGold;
            ctx.beginPath();
            ctx.moveTo(w * 0.36, h);
            ctx.quadraticCurveTo(w * 0.42, h * 0.7, w * 0.46, h * 0.4);
            ctx.lineTo(w * 0.54, h * 0.4);
            ctx.quadraticCurveTo(w * 0.58, h * 0.7, w * 0.64, h);
            ctx.fill();

            // Path shadow/edge
            ctx.strokeStyle = p.pathShadow;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(w * 0.36, h);
            ctx.quadraticCurveTo(w * 0.42, h * 0.7, w * 0.46, h * 0.4);
            ctx.stroke();

            // Central tree - soft, rounded
            drawStorybookTree(ctx, w * 0.5, h * 0.48, growth, p);

            // Soft bushes and flowers
            drawStorybookGarden(ctx, w, h, growth, p);

            // Climbing roses on gate
            if (growth > 0.25) {
                drawClimbingRoses(ctx, w * 0.17, h * 0.3, h * 0.6, growth, p, 'left');
                drawClimbingRoses(ctx, w * 0.83, h * 0.35, h * 0.55, growth, p, 'right');
            }

            // Gardener
            drawStorybookGardener(ctx, w * 0.5, h * 0.82, w, h);

            // Foreground flowers - soft, painterly
            drawStorybookFlowers(ctx, w * 0.22, h * 0.94, growth * 8, p);
            drawStorybookFlowers(ctx, w * 0.78, h * 0.92, growth * 7, p);
        }

        function roundedGateFrame(ctx, w, h, left, right, archStart) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(w * right, h);
            ctx.lineTo(w * right, h * 0.22);
            ctx.quadraticCurveTo(w * 0.5, h * archStart, w * left, h * 0.22);
            ctx.lineTo(w * left, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();
        }

        function drawStorybookTree(ctx, x, y, growth, p) {
            if (growth < 0.1) return;

            const h = 80 + growth * 120;
            const canopyW = 40 + growth * 80;

            // Trunk with texture
            const trunkGrad = ctx.createLinearGradient(x - 8, y, x + 8, y);
            trunkGrad.addColorStop(0, '#5a4030');
            trunkGrad.addColorStop(0.5, '#7a5840');
            trunkGrad.addColorStop(1, '#5a4030');
            ctx.fillStyle = trunkGrad;

            ctx.beginPath();
            ctx.moveTo(x - 6 - growth * 4, y);
            ctx.quadraticCurveTo(x - 8 - growth * 5, y - h * 0.4, x - 3, y - h * 0.5);
            ctx.lineTo(x + 3, y - h * 0.5);
            ctx.quadraticCurveTo(x + 8 + growth * 5, y - h * 0.4, x + 6 + growth * 4, y);
            ctx.fill();

            // Canopy - soft layered circles
            if (growth > 0.2) {
                const layers = [
                    { y: -h * 0.5, r: canopyW * 0.7, color: p.foliageDark },
                    { y: -h * 0.6, r: canopyW * 0.8, color: p.foliageMid },
                    { y: -h * 0.55, r: canopyW * 0.6, color: p.foliageMid },
                    { y: -h * 0.7, r: canopyW * 0.65, color: p.foliageLight },
                    { y: -h * 0.65, r: canopyW * 0.5, color: p.foliageLight },
                ];

                layers.forEach((layer, i) => {
                    if (growth > 0.2 + i * 0.12) {
                        ctx.fillStyle = layer.color;
                        ctx.beginPath();
                        ctx.arc(x + (i % 2 - 0.5) * 10, y + layer.y, layer.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Dappled highlights
                if (growth > 0.6) {
                    ctx.fillStyle = 'rgba(200, 230, 180, 0.4)';
                    for (let i = 0; i < 8; i++) {
                        const hx = x + (seededRandom(i * 7) - 0.5) * canopyW;
                        const hy = y - h * (0.5 + seededRandom(i * 11) * 0.25);
                        ctx.beginPath();
                        ctx.arc(hx, hy, 5 + seededRandom(i * 13) * 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawStorybookGarden(ctx, w, h, growth, p) {
            // Soft bushes
            const bushPositions = [
                { x: 0.28, y: 0.6 }, { x: 0.72, y: 0.58 },
                { x: 0.25, y: 0.75 }, { x: 0.75, y: 0.73 },
            ];

            bushPositions.forEach((pos, i) => {
                if (growth > 0.1 + i * 0.1) {
                    const size = 20 + growth * 35;
                    const colors = [p.foliageDark, p.foliageMid, p.foliageLight];

                    colors.forEach((color, j) => {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(
                            w * pos.x + (j - 1) * size * 0.3,
                            h * pos.y - j * size * 0.2,
                            size * (0.8 - j * 0.15),
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    });
                }
            });

            // Flowers
            const flowerColors = [p.flowerRose, p.flowerPeach, p.flowerCream, p.flowerLavender];
            const flowerCount = Math.floor(growth * 25);

            for (let i = 0; i < flowerCount; i++) {
                const side = i % 2;
                const fx = w * (side === 0 ? 0.22 + seededRandom(i * 7) * 0.15 : 0.65 + seededRandom(i * 11) * 0.15);
                const fy = h * (0.5 + seededRandom(i * 13) * 0.38);

                drawSoftFlower(ctx, fx, fy, flowerColors[i % 4], 4 + growth * 5);
            }
        }

        function drawSoftFlower(ctx, x, y, color, size) {
            // Stem
            ctx.strokeStyle = '#5a8040';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x, y + size);
            ctx.quadraticCurveTo(x + 2, y + size * 0.5, x, y);
            ctx.stroke();

            // Soft petals
            ctx.fillStyle = color;
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
                const px = x + Math.cos(angle) * size * 0.5;
                const py = y + Math.sin(angle) * size * 0.5;
                ctx.beginPath();
                ctx.arc(px, py, size * 0.45, 0, Math.PI * 2);
                ctx.fill();
            }

            // Highlight
            ctx.fillStyle = lerpColor(color, '#ffffff', 0.5);
            ctx.beginPath();
            ctx.arc(x - size * 0.15, y - size * 0.15, size * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // Center
            ctx.fillStyle = '#f8d858';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawClimbingRoses(ctx, x, y, maxH, growth, p, side) {
            const vineGrowth = (growth - 0.25) / 0.75;
            const segments = Math.floor(vineGrowth * 6);

            for (let i = 0; i < segments; i++) {
                const vy = y + maxH * (1 - i / 6);
                const vx = x + (side === 'left' ? 1 : -1) * Math.sin(i * 0.8) * 8;

                // Leaf
                ctx.fillStyle = p.foliageMid;
                ctx.beginPath();
                ctx.ellipse(vx, vy, 10, 14, (side === 'left' ? 0.3 : -0.3), 0, Math.PI * 2);
                ctx.fill();

                // Rose
                if (growth > 0.5 && i < segments - 1) {
                    drawSoftFlower(ctx, vx, vy - 8, i % 2 ? p.flowerRose : p.flowerPeach, 6 + growth * 3);
                }
            }
        }

        function drawStorybookFlowers(ctx, x, y, count, p) {
            const colors = [p.flowerRose, p.flowerPeach, p.flowerCream, p.flowerLavender];
            for (let i = 0; i < count; i++) {
                const fx = x + (seededRandom(i * 7) - 0.5) * 50;
                const fy = y + (seededRandom(i * 11) - 0.5) * 25;
                drawSoftFlower(ctx, fx, fy, colors[i % 4], 5 + seededRandom(i * 13) * 5);
            }
        }

        function drawStorybookGardener(ctx, x, y, w, h) {
            const scale = h * 0.13;

            ctx.save();
            ctx.translate(x, y);

            // Shadow
            ctx.fillStyle = 'rgba(60, 80, 40, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 0, scale * 0.4, scale * 0.12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Dress/apron - soft blue
            ctx.fillStyle = '#7090a8';
            ctx.beginPath();
            ctx.moveTo(-scale * 0.25, 0);
            ctx.quadraticCurveTo(-scale * 0.3, -scale * 0.3, -scale * 0.2, -scale * 0.5);
            ctx.lineTo(scale * 0.2, -scale * 0.5);
            ctx.quadraticCurveTo(scale * 0.3, -scale * 0.3, scale * 0.25, 0);
            ctx.fill();

            // Apron
            ctx.fillStyle = '#f8f0e0';
            ctx.beginPath();
            ctx.moveTo(-scale * 0.15, -scale * 0.1);
            ctx.lineTo(-scale * 0.12, -scale * 0.45);
            ctx.lineTo(scale * 0.12, -scale * 0.45);
            ctx.lineTo(scale * 0.15, -scale * 0.1);
            ctx.fill();

            // Arms
            ctx.fillStyle = '#e8c8a8';
            ctx.beginPath();
            ctx.ellipse(-scale * 0.28, -scale * 0.4, scale * 0.08, scale * 0.15, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(scale * 0.28, -scale * 0.4, scale * 0.08, scale * 0.15, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#f0d0b0';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.62, scale * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // Hair
            ctx.fillStyle = '#8a6040';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.68, scale * 0.14, Math.PI * 1.1, Math.PI * 1.9);
            ctx.fill();
            // Bun
            ctx.beginPath();
            ctx.arc(0, -scale * 0.78, scale * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Sun hat - straw with ribbon
            ctx.fillStyle = '#f0e0c0';
            ctx.beginPath();
            ctx.ellipse(0, -scale * 0.72, scale * 0.35, scale * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(0, -scale * 0.78, scale * 0.2, scale * 0.12, 0, Math.PI, Math.PI * 2);
            ctx.fill();

            // Hat ribbon
            ctx.fillStyle = '#e08088';
            ctx.fillRect(-scale * 0.2, -scale * 0.74, scale * 0.4, scale * 0.04);

            // Watering can - copper
            ctx.fillStyle = '#c08860';
            ctx.beginPath();
            ctx.ellipse(scale * 0.35, -scale * 0.25, scale * 0.12, scale * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(scale * 0.4, -scale * 0.35, scale * 0.08, scale * 0.06);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // STYLE C: GHIBLI PASTORAL
        // ═══════════════════════════════════════════════════════════════════

        function renderStyleC() {
            const { ctx, w, h } = initCanvas('C');
            const growth = growthStates.C;

            // Soft, dreamy palette
            const p = {
                skyTop: '#88b8d8',
                skyBottom: '#d8f0f8',
                cloudWhite: '#ffffff',
                stoneGrey: '#a8a898',
                stoneMoss: '#889878',
                groundSoft: '#78a868',
                groundLight: '#a8d098',
                pathDust: '#d8c8a8',
                foliageSoft: '#5a9858',
                foliageLight: '#88c078',
                foliageGlow: '#b8e0a8',
                flowerSoft: '#f8a8b8',
                flowerWhite: '#fff8f8',
                flowerYellow: '#f8e888',
                flowerBlue: '#a8c8e8'
            };

            // Dreamy sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, p.skyTop);
            skyGrad.addColorStop(1, p.skyBottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Soft puffy clouds
            ctx.fillStyle = p.cloudWhite;
            ctx.globalAlpha = 0.8;
            drawGhibliCloud(ctx, w * 0.3, h * 0.12, 50);
            drawGhibliCloud(ctx, w * 0.65, h * 0.08, 40);
            drawGhibliCloud(ctx, w * 0.5, h * 0.18, 35);
            ctx.globalAlpha = 1;

            // Gate - mossy stone, organic
            ctx.fillStyle = p.stoneGrey;
            // Organic arch shape
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(w * 0.78, h);
            ctx.lineTo(w * 0.78, h * 0.25);
            ctx.bezierCurveTo(w * 0.75, h * 0.1, w * 0.25, h * 0.1, w * 0.22, h * 0.25);
            ctx.lineTo(w * 0.22, h);
            ctx.lineTo(0, h);
            ctx.fill();

            // Moss on stone
            ctx.fillStyle = p.stoneMoss;
            for (let i = 0; i < 30; i++) {
                const mx = seededRandom(i * 7) < 0.5 ?
                    w * (0.02 + seededRandom(i * 11) * 0.18) :
                    w * (0.8 + seededRandom(i * 13) * 0.18);
                const my = h * (0.15 + seededRandom(i * 17) * 0.8);
                ctx.beginPath();
                ctx.arc(mx, my, 4 + seededRandom(i * 19) * 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Garden - soft, luminous
            const groundGrad = ctx.createLinearGradient(0, h * 0.35, 0, h);
            groundGrad.addColorStop(0, p.groundSoft);
            groundGrad.addColorStop(0.5, p.groundLight);
            groundGrad.addColorStop(1, p.groundSoft);
            ctx.fillStyle = groundGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.22, h * 0.35);
            ctx.bezierCurveTo(w * 0.35, h * 0.32, w * 0.65, h * 0.32, w * 0.78, h * 0.35);
            ctx.lineTo(w * 0.82, h);
            ctx.lineTo(w * 0.18, h);
            ctx.fill();

            // Dappled light on ground
            ctx.fillStyle = p.groundLight;
            ctx.globalAlpha = 0.5;
            for (let i = 0; i < 15; i++) {
                const lx = w * (0.25 + seededRandom(i * 7) * 0.5);
                const ly = h * (0.4 + seededRandom(i * 11) * 0.5);
                ctx.beginPath();
                ctx.ellipse(lx, ly, 15 + seededRandom(i * 13) * 25, 8 + seededRandom(i * 17) * 12, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Dusty path
            ctx.fillStyle = p.pathDust;
            ctx.beginPath();
            ctx.moveTo(w * 0.38, h);
            ctx.bezierCurveTo(w * 0.4, h * 0.8, w * 0.48, h * 0.5, w * 0.47, h * 0.38);
            ctx.lineTo(w * 0.53, h * 0.38);
            ctx.bezierCurveTo(w * 0.52, h * 0.5, w * 0.6, h * 0.8, w * 0.62, h);
            ctx.fill();

            // Central tree - Ghibli style, organic
            drawGhibliTree(ctx, w * 0.5, h * 0.45, growth, p);

            // Soft grass tufts and flowers
            drawGhibliVegetation(ctx, w, h, growth, p);

            // Gardener
            drawGhibliGardener(ctx, w * 0.52, h * 0.8, w, h);

            // Foreground grass
            ctx.fillStyle = p.foliageSoft;
            for (let i = 0; i < 20; i++) {
                const gx = w * (0.18 + seededRandom(i * 7) * 0.08);
                const gy = h * (0.88 + seededRandom(i * 11) * 0.1);
                drawGrassTuft(ctx, gx, gy, 15 + growth * 15);
            }
            for (let i = 0; i < 20; i++) {
                const gx = w * (0.75 + seededRandom(i * 7 + 100) * 0.08);
                const gy = h * (0.86 + seededRandom(i * 11 + 100) * 0.12);
                drawGrassTuft(ctx, gx, gy, 15 + growth * 15);
            }
        }

        function drawGhibliCloud(ctx, x, y, size) {
            const blobs = [
                { ox: 0, oy: 0, r: size },
                { ox: -size * 0.6, oy: size * 0.1, r: size * 0.7 },
                { ox: size * 0.5, oy: size * 0.15, r: size * 0.6 },
                { ox: -size * 0.3, oy: -size * 0.2, r: size * 0.5 },
                { ox: size * 0.2, oy: -size * 0.15, r: size * 0.55 },
            ];
            blobs.forEach(b => {
                ctx.beginPath();
                ctx.arc(x + b.ox, y + b.oy, b.r, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGhibliTree(ctx, x, y, growth, p) {
            if (growth < 0.1) return;

            const h = 60 + growth * 140;
            const canopyR = 30 + growth * 70;

            // Organic trunk
            ctx.fillStyle = '#6a5040';
            ctx.beginPath();
            ctx.moveTo(x - 5 - growth * 6, y);
            ctx.bezierCurveTo(x - 8, y - h * 0.3, x - 4, y - h * 0.5, x, y - h * 0.45);
            ctx.bezierCurveTo(x + 4, y - h * 0.5, x + 8, y - h * 0.3, x + 5 + growth * 6, y);
            ctx.fill();

            // Branches
            if (growth > 0.3) {
                ctx.strokeStyle = '#5a4030';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, y - h * 0.4);
                ctx.quadraticCurveTo(x - 20, y - h * 0.5, x - 30 * growth, y - h * 0.45);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y - h * 0.42);
                ctx.quadraticCurveTo(x + 18, y - h * 0.52, x + 28 * growth, y - h * 0.48);
                ctx.stroke();
            }

            // Luminous canopy - multiple soft layers
            if (growth > 0.2) {
                // Back glow
                ctx.fillStyle = p.foliageGlow;
                ctx.globalAlpha = 0.4;
                ctx.beginPath();
                ctx.arc(x, y - h * 0.6, canopyR * 1.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Main canopy blobs
                const canopyBlobs = [
                    { ox: -canopyR * 0.4, oy: -h * 0.55, r: canopyR * 0.7, c: p.foliageSoft },
                    { ox: canopyR * 0.3, oy: -h * 0.52, r: canopyR * 0.65, c: p.foliageSoft },
                    { ox: 0, oy: -h * 0.65, r: canopyR * 0.8, c: p.foliageLight },
                    { ox: -canopyR * 0.2, oy: -h * 0.7, r: canopyR * 0.5, c: p.foliageLight },
                    { ox: canopyR * 0.15, oy: -h * 0.72, r: canopyR * 0.45, c: p.foliageGlow },
                ];

                canopyBlobs.forEach((blob, i) => {
                    if (growth > 0.2 + i * 0.1) {
                        ctx.fillStyle = blob.c;
                        ctx.beginPath();
                        ctx.arc(x + blob.ox, y + blob.oy, blob.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        }

        function drawGhibliVegetation(ctx, w, h, growth, p) {
            // Grass tufts
            ctx.fillStyle = p.foliageSoft;
            for (let i = 0; i < 40; i++) {
                const gx = w * (0.22 + seededRandom(i * 7) * 0.56);
                const gy = h * (0.4 + seededRandom(i * 11) * 0.5);
                if (Math.abs(gx - w * 0.5) > w * 0.1 || gy > h * 0.55) {
                    drawGrassTuft(ctx, gx, gy, 8 + growth * 12);
                }
            }

            // Soft flowers
            const flowerColors = [p.flowerSoft, p.flowerWhite, p.flowerYellow, p.flowerBlue];
            const flowerCount = Math.floor(growth * 30);

            for (let i = 0; i < flowerCount; i++) {
                const fx = w * (0.22 + seededRandom(i * 7 + 50) * 0.56);
                const fy = h * (0.45 + seededRandom(i * 11 + 50) * 0.45);

                if (Math.abs(fx - w * 0.5) > w * 0.08) {
                    drawGhibliFlower(ctx, fx, fy, flowerColors[i % 4], 3 + growth * 4);
                }
            }
        }

        function drawGrassTuft(ctx, x, y, h) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x - 3, y - h * 0.6, x - 5, y - h);
            ctx.quadraticCurveTo(x, y - h * 0.7, x, y);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.quadraticCurveTo(x + 2, y - h * 0.7, x + 4, y - h * 0.9);
            ctx.quadraticCurveTo(x, y - h * 0.6, x, y);
            ctx.fill();
        }

        function drawGhibliFlower(ctx, x, y, color, size) {
            // Simple, soft flower
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.9;
            ctx.beginPath();
            ctx.arc(x, y - size, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // White center
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(x, y - size, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function drawGhibliGardener(ctx, x, y, w, h) {
            const scale = h * 0.12;

            ctx.save();
            ctx.translate(x, y);

            // Shadow - soft
            ctx.fillStyle = 'rgba(80, 120, 80, 0.25)';
            ctx.beginPath();
            ctx.ellipse(0, 0, scale * 0.35, scale * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Simple dress - soft green
            ctx.fillStyle = '#88a878';
            ctx.beginPath();
            ctx.moveTo(-scale * 0.22, 0);
            ctx.quadraticCurveTo(-scale * 0.25, -scale * 0.35, -scale * 0.15, -scale * 0.5);
            ctx.lineTo(scale * 0.15, -scale * 0.5);
            ctx.quadraticCurveTo(scale * 0.25, -scale * 0.35, scale * 0.22, 0);
            ctx.fill();

            // Arms
            ctx.fillStyle = '#f0d8c0';
            ctx.beginPath();
            ctx.ellipse(-scale * 0.22, -scale * 0.4, scale * 0.06, scale * 0.12, 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(scale * 0.22, -scale * 0.4, scale * 0.06, scale * 0.12, -0.4, 0, Math.PI * 2);
            ctx.fill();

            // Head
            ctx.fillStyle = '#f8e0c8';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.6, scale * 0.14, 0, Math.PI * 2);
            ctx.fill();

            // Hair - soft brown
            ctx.fillStyle = '#8a6848';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.65, scale * 0.13, Math.PI * 1.15, Math.PI * 1.85);
            ctx.fill();

            // Simple hat
            ctx.fillStyle = '#f8f0e0';
            ctx.beginPath();
            ctx.ellipse(0, -scale * 0.7, scale * 0.28, scale * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tool
            ctx.fillStyle = '#888888';
            ctx.fillRect(scale * 0.25, -scale * 0.55, scale * 0.04, scale * 0.4);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // STYLE D: PAPER CUT LAYERS
        // ═══════════════════════════════════════════════════════════════════

        function renderStyleD() {
            const { ctx, w, h } = initCanvas('D');
            const growth = growthStates.D;

            // Bold, flat colors for each layer
            const layers = {
                sky: '#e8a870',
                skyAccent: '#f8c888',
                layer1: '#2a3040', // Darkest - gate frame
                layer2: '#3a5848', // Dark green - back plants
                layer3: '#4a7858', // Mid green - mid plants
                layer4: '#5a9868', // Bright green - garden floor
                layer5: '#78b878', // Lightest - foreground
                path: '#d8c090',
                flowerA: '#f05080',
                flowerB: '#f8d848',
                flowerC: '#f8f8f0',
                flowerD: '#8080d0'
            };

            // LAYER 0: Sky - warm gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, layers.sky);
            skyGrad.addColorStop(1, layers.skyAccent);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Sun/moon
            ctx.fillStyle = '#fff8e0';
            ctx.beginPath();
            ctx.arc(w * 0.65, h * 0.15, 25, 0, Math.PI * 2);
            ctx.fill();

            // LAYER 1: Gate frame (darkest)
            ctx.fillStyle = layers.layer1;
            // Crisp gate shape
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(w * 0.8, h);
            ctx.lineTo(w * 0.8, h * 0.2);
            ctx.lineTo(w * 0.7, h * 0.1);
            ctx.lineTo(w * 0.3, h * 0.1);
            ctx.lineTo(w * 0.2, h * 0.2);
            ctx.lineTo(w * 0.2, h);
            ctx.lineTo(0, h);
            ctx.fill();

            // LAYER 2: Back plants
            ctx.fillStyle = layers.layer2;
            ctx.beginPath();
            ctx.moveTo(w * 0.2, h * 0.35);
            ctx.lineTo(w * 0.8, h * 0.35);
            ctx.lineTo(w * 0.8, h * 0.5);
            // Wavy plant tops
            for (let x = w * 0.8; x >= w * 0.2; x -= 15) {
                const py = h * 0.45 + Math.sin(x * 0.05) * 10 + (growth > 0.3 ? 15 : 5);
                ctx.lineTo(x, py);
            }
            ctx.lineTo(w * 0.2, h * 0.5);
            ctx.fill();

            // Add tree silhouette if growth
            if (growth > 0.2) {
                ctx.beginPath();
                ctx.arc(w * 0.5, h * 0.35 - growth * 40, 20 + growth * 40, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(w * 0.48, h * 0.35 - growth * 20, w * 0.04, growth * 30);
            }

            // LAYER 3: Mid plants
            ctx.fillStyle = layers.layer3;
            ctx.beginPath();
            ctx.moveTo(w * 0.2, h * 0.5);
            for (let x = w * 0.2; x <= w * 0.8; x += 12) {
                const py = h * 0.55 + Math.sin(x * 0.08 + 1) * 12 - growth * 15;
                ctx.lineTo(x, py);
            }
            ctx.lineTo(w * 0.8, h * 0.65);
            ctx.lineTo(w * 0.2, h * 0.65);
            ctx.fill();

            // LAYER 4: Garden floor + path
            ctx.fillStyle = layers.layer4;
            ctx.fillRect(w * 0.2, h * 0.6, w * 0.6, h * 0.4);

            // Crisp path
            ctx.fillStyle = layers.path;
            ctx.beginPath();
            ctx.moveTo(w * 0.4, h);
            ctx.lineTo(w * 0.45, h * 0.6);
            ctx.lineTo(w * 0.55, h * 0.6);
            ctx.lineTo(w * 0.6, h);
            ctx.fill();

            // LAYER 5: Foreground plants
            ctx.fillStyle = layers.layer5;
            // Left foreground
            ctx.beginPath();
            ctx.moveTo(w * 0.2, h * 0.85);
            for (let i = 0; i < 8; i++) {
                const px = w * (0.2 + i * 0.02);
                const py = h * (0.75 - growth * 0.1) + Math.sin(i * 1.5) * 15;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(w * 0.35, h);
            ctx.lineTo(w * 0.2, h);
            ctx.fill();

            // Right foreground
            ctx.beginPath();
            ctx.moveTo(w * 0.8, h * 0.82);
            for (let i = 0; i < 8; i++) {
                const px = w * (0.8 - i * 0.02);
                const py = h * (0.73 - growth * 0.1) + Math.sin(i * 1.3 + 2) * 15;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(w * 0.65, h);
            ctx.lineTo(w * 0.8, h);
            ctx.fill();

            // FLOWERS - Crisp circles on each layer
            const flowerColors = [layers.flowerA, layers.flowerB, layers.flowerC, layers.flowerD];

            // Back layer flowers
            if (growth > 0.3) {
                for (let i = 0; i < growth * 8; i++) {
                    const fx = w * (0.25 + seededRandom(i * 7) * 0.5);
                    const fy = h * (0.38 + seededRandom(i * 11) * 0.1);
                    ctx.fillStyle = flowerColors[i % 4];
                    ctx.beginPath();
                    ctx.arc(fx, fy, 4 + growth * 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Mid layer flowers
            if (growth > 0.2) {
                for (let i = 0; i < growth * 12; i++) {
                    const fx = w * (0.22 + seededRandom(i * 7 + 50) * 0.56);
                    const fy = h * (0.5 + seededRandom(i * 11 + 50) * 0.08);
                    ctx.fillStyle = flowerColors[(i + 1) % 4];
                    ctx.beginPath();
                    ctx.arc(fx, fy, 5 + growth * 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Foreground flowers - larger
            for (let i = 0; i < growth * 10; i++) {
                const side = i % 2;
                const fx = side === 0 ?
                    w * (0.22 + seededRandom(i * 7 + 100) * 0.12) :
                    w * (0.68 + seededRandom(i * 7 + 100) * 0.1);
                const fy = h * (0.78 + seededRandom(i * 11 + 100) * 0.15);
                ctx.fillStyle = flowerColors[(i + 2) % 4];
                ctx.beginPath();
                ctx.arc(fx, fy, 6 + growth * 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // GARDENER - Flat, graphic style
            drawPaperCutGardener(ctx, w * 0.5, h * 0.85, w, h);
        }

        function drawPaperCutGardener(ctx, x, y, w, h) {
            const scale = h * 0.15;

            ctx.save();
            ctx.translate(x, y);

            // Body - simple trapezoid
            ctx.fillStyle = '#3a5848';
            ctx.beginPath();
            ctx.moveTo(-scale * 0.22, 0);
            ctx.lineTo(-scale * 0.18, -scale * 0.55);
            ctx.lineTo(scale * 0.18, -scale * 0.55);
            ctx.lineTo(scale * 0.22, 0);
            ctx.fill();

            // Head
            ctx.fillStyle = '#f0d0b0';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.65, scale * 0.14, 0, Math.PI * 2);
            ctx.fill();

            // Hat - flat circle
            ctx.fillStyle = '#e8d8a8';
            ctx.beginPath();
            ctx.ellipse(0, -scale * 0.72, scale * 0.28, scale * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, -scale * 0.76, scale * 0.14, Math.PI, Math.PI * 2);
            ctx.fill();

            // Tool
            ctx.fillStyle = '#607080';
            ctx.fillRect(scale * 0.2, -scale * 0.5, scale * 0.15, scale * 0.25);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // STYLE E: MOODY ROMANTIC
        // ═══════════════════════════════════════════════════════════════════

        function renderStyleE() {
            const { ctx, w, h } = initCanvas('E');
            const growth = growthStates.E;

            // Rich, dark palette with jewel tones
            const p = {
                skyDeep: '#1a1828',
                skyGlow: '#2a3858',
                stoneOld: '#4a4038',
                stoneDark: '#2a2820',
                stoneLight: '#6a5848',
                groundDark: '#1a2818',
                groundMid: '#2a3828',
                pathMoon: '#5a5048',
                foliageDark: '#1a2818',
                foliageDeep: '#283828',
                flowerRuby: '#c03050',
                flowerRose: '#d86088',
                flowerGold: '#d8a840',
                flowerIvory: '#e8e0d0',
                flowerViolet: '#7848a0'
            };

            // Dark moody sky
            const skyGrad = ctx.createRadialGradient(w * 0.5, h * 0.2, 0, w * 0.5, h * 0.3, h * 0.5);
            skyGrad.addColorStop(0, p.skyGlow);
            skyGrad.addColorStop(1, p.skyDeep);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h);

            // Stars
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 30; i++) {
                const sx = w * seededRandom(i * 7);
                const sy = h * seededRandom(i * 11) * 0.4;
                ctx.globalAlpha = 0.3 + seededRandom(i * 13) * 0.5;
                ctx.beginPath();
                ctx.arc(sx, sy, 0.5 + seededRandom(i * 17), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Moon glow
            ctx.fillStyle = '#d8d0c0';
            ctx.globalAlpha = 0.15;
            ctx.beginPath();
            ctx.arc(w * 0.7, h * 0.12, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#e8e0d8';
            ctx.beginPath();
            ctx.arc(w * 0.7, h * 0.12, 20, 0, Math.PI * 2);
            ctx.fill();

            // Ancient gate - weathered stone
            ctx.fillStyle = p.stoneDark;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(w, 0);
            ctx.lineTo(w, h);
            ctx.lineTo(w * 0.78, h);
            ctx.lineTo(w * 0.78, h * 0.22);
            ctx.bezierCurveTo(w * 0.7, h * 0.08, w * 0.3, h * 0.08, w * 0.22, h * 0.22);
            ctx.lineTo(w * 0.22, h);
            ctx.lineTo(0, h);
            ctx.fill();

            // Stone texture/age
            ctx.fillStyle = p.stoneLight;
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 40; i++) {
                const tx = seededRandom(i * 7) < 0.5 ?
                    w * seededRandom(i * 11) * 0.2 :
                    w * (0.8 + seededRandom(i * 13) * 0.2);
                const ty = h * seededRandom(i * 17);
                ctx.beginPath();
                ctx.arc(tx, ty, 2 + seededRandom(i * 19) * 6, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Inner arch highlight
            ctx.strokeStyle = p.stoneLight;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(w * 0.22, h * 0.35);
            ctx.bezierCurveTo(w * 0.3, h * 0.12, w * 0.7, h * 0.12, w * 0.78, h * 0.35);
            ctx.stroke();

            // Dark garden interior
            ctx.fillStyle = p.groundDark;
            ctx.fillRect(w * 0.22, h * 0.35, w * 0.56, h * 0.65);

            // Moonlit path
            const pathGrad = ctx.createLinearGradient(w * 0.5, h * 0.35, w * 0.5, h);
            pathGrad.addColorStop(0, '#4a4840');
            pathGrad.addColorStop(1, p.pathMoon);
            ctx.fillStyle = pathGrad;
            ctx.beginPath();
            ctx.moveTo(w * 0.4, h);
            ctx.bezierCurveTo(w * 0.42, h * 0.7, w * 0.48, h * 0.5, w * 0.47, h * 0.38);
            ctx.lineTo(w * 0.53, h * 0.38);
            ctx.bezierCurveTo(w * 0.52, h * 0.5, w * 0.58, h * 0.7, w * 0.6, h);
            ctx.fill();

            // Mysterious tree
            drawMoodyTree(ctx, w * 0.5, h * 0.45, growth, p);

            // Dark foliage masses
            drawMoodyFoliage(ctx, w, h, growth, p);

            // Jewel-toned flowers - glowing against dark
            drawMoodyFlowers(ctx, w, h, growth, p);

            // Climbing roses on gate
            if (growth > 0.2) {
                drawMoodyVines(ctx, w * 0.2, h * 0.3, h * 0.65, growth, p);
                drawMoodyVines(ctx, w * 0.8, h * 0.35, h * 0.6, growth, p);
            }

            // Gardener - silhouette style
            drawMoodyGardener(ctx, w * 0.48, h * 0.82, w, h);

            // Foreground dark leaves
            ctx.fillStyle = p.foliageDark;
            ctx.beginPath();
            ctx.ellipse(w * 0.1, h * 1.05, 80, 120, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(w * 0.9, h * 1.02, 70, 110, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Foreground flowers - brightest
            const fgFlowers = [p.flowerRose, p.flowerGold, p.flowerIvory];
            for (let i = 0; i < growth * 8; i++) {
                const fx = w * (0.15 + seededRandom(i * 7 + 200) * 0.12);
                const fy = h * (0.88 + seededRandom(i * 11 + 200) * 0.1);
                drawGlowingFlower(ctx, fx, fy, fgFlowers[i % 3], 6 + growth * 4);
            }
            for (let i = 0; i < growth * 7; i++) {
                const fx = w * (0.75 + seededRandom(i * 7 + 300) * 0.1);
                const fy = h * (0.86 + seededRandom(i * 11 + 300) * 0.12);
                drawGlowingFlower(ctx, fx, fy, fgFlowers[(i + 1) % 3], 6 + growth * 4);
            }
        }

        function drawMoodyTree(ctx, x, y, growth, p) {
            if (growth < 0.15) return;

            const h = 50 + growth * 120;
            const canopyR = 25 + growth * 55;

            // Gnarled trunk
            ctx.fillStyle = '#2a2018';
            ctx.beginPath();
            ctx.moveTo(x - 6 - growth * 5, y);
            ctx.bezierCurveTo(x - 10, y - h * 0.3, x - 5, y - h * 0.5, x - 2, y - h * 0.4);
            ctx.bezierCurveTo(x + 5, y - h * 0.5, x + 10, y - h * 0.3, x + 6 + growth * 5, y);
            ctx.fill();

            // Dark canopy
            if (growth > 0.25) {
                ctx.fillStyle = p.foliageDark;
                ctx.beginPath();
                ctx.arc(x, y - h * 0.55, canopyR, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.foliageDeep;
                ctx.beginPath();
                ctx.arc(x - canopyR * 0.3, y - h * 0.6, canopyR * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + canopyR * 0.25, y - h * 0.65, canopyR * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Moonlight edge
                ctx.strokeStyle = '#4a5848';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y - h * 0.55, canopyR * 0.95, Math.PI * 1.2, Math.PI * 1.8);
                ctx.stroke();
            }
        }

        function drawMoodyFoliage(ctx, w, h, growth, p) {
            // Dark bush masses
            const bushes = [
                { x: 0.28, y: 0.6 }, { x: 0.72, y: 0.58 },
                { x: 0.25, y: 0.75 }, { x: 0.75, y: 0.72 },
            ];

            bushes.forEach((pos, i) => {
                const size = 25 + growth * 30;
                ctx.fillStyle = i < 2 ? p.foliageDark : p.foliageDeep;
                ctx.beginPath();
                ctx.arc(w * pos.x, h * pos.y, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawMoodyFlowers(ctx, w, h, growth, p) {
            const flowerColors = [p.flowerRuby, p.flowerRose, p.flowerGold, p.flowerIvory, p.flowerViolet];
            const count = Math.floor(growth * 25);

            for (let i = 0; i < count; i++) {
                const fx = w * (0.25 + seededRandom(i * 7) * 0.5);
                const fy = h * (0.45 + seededRandom(i * 11) * 0.4);

                if (Math.abs(fx - w * 0.5) > w * 0.1) {
                    drawGlowingFlower(ctx, fx, fy, flowerColors[i % 5], 3 + growth * 4);
                }
            }
        }

        function drawGlowingFlower(ctx, x, y, color, size) {
            // Glow
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(x, y, size * 1.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Flower
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            // Highlight
            ctx.fillStyle = lerpColor(color, '#ffffff', 0.5);
            ctx.beginPath();
            ctx.arc(x - size * 0.2, y - size * 0.2, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMoodyVines(ctx, x, startY, length, growth, p) {
            const vineGrowth = (growth - 0.2) / 0.8;
            const segments = Math.floor(vineGrowth * 7);

            for (let i = 0; i < segments; i++) {
                const vy = startY + length * (1 - i / 7);

                // Dark leaf
                ctx.fillStyle = p.foliageDeep;
                ctx.beginPath();
                ctx.ellipse(x, vy, 12, 16, x < 200 ? 0.4 : -0.4, 0, Math.PI * 2);
                ctx.fill();

                // Glowing rose
                if (growth > 0.5 && i < segments - 2) {
                    drawGlowingFlower(ctx, x, vy - 8, i % 2 ? p.flowerRuby : p.flowerRose, 5 + growth * 2);
                }
            }
        }

        function drawMoodyGardener(ctx, x, y, w, h) {
            const scale = h * 0.14;

            ctx.save();
            ctx.translate(x, y);

            // Silhouette style - dark with rim light

            // Cloak/dress
            ctx.fillStyle = '#1a2020';
            ctx.beginPath();
            ctx.moveTo(-scale * 0.25, 0);
            ctx.quadraticCurveTo(-scale * 0.28, -scale * 0.35, -scale * 0.18, -scale * 0.55);
            ctx.lineTo(scale * 0.18, -scale * 0.55);
            ctx.quadraticCurveTo(scale * 0.28, -scale * 0.35, scale * 0.25, 0);
            ctx.fill();

            // Rim light on dress
            ctx.strokeStyle = '#3a4838';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(scale * 0.25, 0);
            ctx.quadraticCurveTo(scale * 0.28, -scale * 0.35, scale * 0.18, -scale * 0.55);
            ctx.stroke();

            // Head
            ctx.fillStyle = '#e0c8a8';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.65, scale * 0.13, 0, Math.PI * 2);
            ctx.fill();

            // Hair - dark
            ctx.fillStyle = '#1a1818';
            ctx.beginPath();
            ctx.arc(0, -scale * 0.7, scale * 0.12, Math.PI * 1.1, Math.PI * 1.9);
            ctx.fill();

            // Lantern - warm glow
            ctx.fillStyle = '#f8d868';
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(scale * 0.35, -scale * 0.35, scale * 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.fillStyle = '#d8a840';
            ctx.fillRect(scale * 0.28, -scale * 0.42, scale * 0.12, scale * 0.15);
            ctx.fillStyle = '#f8e880';
            ctx.fillRect(scale * 0.3, -scale * 0.4, scale * 0.08, scale * 0.1);

            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // RENDER ALL
        // ═══════════════════════════════════════════════════════════════════

        function renderStyle(id) {
            switch(id) {
                case 'A': renderStyleA(); break;
                case 'B': renderStyleB(); break;
                case 'C': renderStyleC(); break;
                case 'D': renderStyleD(); break;
                case 'E': renderStyleE(); break;
            }
        }

        function renderAll() {
            ['A', 'B', 'C', 'D', 'E'].forEach(renderStyle);
        }

        window.addEventListener('load', renderAll);
        window.addEventListener('resize', renderAll);
    </script>
</body>
</html>
