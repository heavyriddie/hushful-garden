<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #1a2030;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Woodblock print texture - slight grain */
        #print-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.06;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 60;
            mix-blend-mode: multiply;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(250, 245, 235, 0.92);
            padding: 14px 28px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(20, 30, 40, 0.3);
            text-align: center;
            z-index: 100;
            border: 2px solid rgba(60, 50, 40, 0.15);
        }

        #garden-name {
            font-size: 17px;
            font-weight: 600;
            color: #2a3040;
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }

        #garden-status {
            font-size: 11px;
            color: #5a6070;
            font-style: italic;
        }

        #plant-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(250, 245, 235, 0.95);
            padding: 22px 28px;
            border-radius: 16px;
            box-shadow: 0 8px 40px rgba(20, 30, 40, 0.35);
            text-align: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.4, 0.64, 1);
            max-width: 260px;
            border: 2px solid rgba(60, 50, 40, 0.2);
        }

        #plant-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        #tooltip-icon { font-size: 32px; margin-bottom: 8px; }
        #tooltip-title { font-size: 16px; font-weight: 600; color: #2a3040; margin-bottom: 6px; }
        #tooltip-message { font-size: 13px; color: #4a5060; line-height: 1.5; font-style: italic; }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="print-texture"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <div id="plant-tooltip">
        <div id="tooltip-icon"></div>
        <div id="tooltip-title"></div>
        <div id="tooltip-message"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUSHFUL SECRET GARDEN - Enclosed Walled Garden
        // Intimate, cozy space with walls, arch gate, and focused composition
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Initialize Telegram WebApp
        let tg = null;
        try {
            tg = window.Telegram?.WebApp;
            if (tg) {
                tg.ready();
                tg.expand();
                document.body.style.background = tg.backgroundColor || '#1a2030';
            }
        } catch (e) {
            console.log('Telegram WebApp init error:', e);
        }

        let canvas, ctx, width, height, dpr;

        function initCanvas() {
            canvas = document.getElementById('garden-canvas');
            if (!canvas) return false;
            ctx = canvas.getContext('2d');
            if (!ctx) return false;
            return true;
        }

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLOR PALETTES - Kawase-inspired with warm garden tones
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const palettes = {
            dawn: {
                skyTop: '#4a5580',
                skyMid: '#8060a0',
                skyLow: '#e080a0',
                skyHorizon: '#f8a088',
                clouds: '#ff90b0',
                cloudShadow: '#c060a0',
                sun: '#ffcc88',
                sunGlow: '#ff9060',
                // Wall colors - warm stone
                wallMain: '#a08870',
                wallShadow: '#786858',
                wallHighlight: '#c0a890',
                wallMoss: '#607850',
                // Gate/arch
                gateWood: '#5a4838',
                gateIron: '#3a3030',
                // Ground inside garden
                groundFar: '#507848',
                groundMid: '#406838',
                groundNear: '#306028',
                pathStone: '#b8a080',
                pathShadow: '#988868',
                // Plants
                flower1: '#ff7090',
                flower2: '#ffaa60',
                flower3: '#90d0ff',
                tree: '#1a3828',
                treeFoliage: '#2a5838',
                vine: '#3a6840'
            },
            day: {
                skyTop: '#3080a0',
                skyMid: '#50a8c0',
                skyLow: '#80c8d8',
                skyHorizon: '#c0e0e8',
                clouds: '#f0f8ff',
                cloudShadow: '#a0c8d8',
                sun: '#fff8e0',
                sunGlow: '#ffe8b0',
                wallMain: '#c8b098',
                wallShadow: '#a08870',
                wallHighlight: '#e0d0b8',
                wallMoss: '#708858',
                gateWood: '#6a5848',
                gateIron: '#484040',
                groundFar: '#608858',
                groundMid: '#507848',
                groundNear: '#406838',
                pathStone: '#d0c0a0',
                pathShadow: '#b0a080',
                flower1: '#ff6080',
                flower2: '#ffa050',
                flower3: '#80c0ff',
                tree: '#1a3020',
                treeFoliage: '#285028',
                vine: '#4a7850'
            },
            golden: {
                skyTop: '#5070a0',
                skyMid: '#a08850',
                skyLow: '#e0a050',
                skyHorizon: '#f8c060',
                clouds: '#ffd080',
                cloudShadow: '#c89040',
                sun: '#fff0a0',
                sunGlow: '#ffc040',
                wallMain: '#d0a878',
                wallShadow: '#a88058',
                wallHighlight: '#e8c8a0',
                wallMoss: '#687048',
                gateWood: '#584030',
                gateIron: '#403028',
                groundFar: '#687040',
                groundMid: '#586030',
                groundNear: '#485020',
                pathStone: '#e0c090',
                pathShadow: '#c0a070',
                flower1: '#ff8060',
                flower2: '#ffc040',
                flower3: '#a0d080',
                tree: '#283018',
                treeFoliage: '#384820',
                vine: '#587040'
            },
            dusk: {
                skyTop: '#3048a0',
                skyMid: '#6050a0',
                skyLow: '#c060a0',
                skyHorizon: '#e080a0',
                clouds: '#e888c0',
                cloudShadow: '#9050a0',
                sun: '#ffa080',
                sunGlow: '#ff7060',
                wallMain: '#8a7878',
                wallShadow: '#6a5858',
                wallHighlight: '#a89898',
                wallMoss: '#506858',
                gateWood: '#4a3838',
                gateIron: '#302828',
                groundFar: '#505868',
                groundMid: '#404858',
                groundNear: '#303848',
                pathStone: '#9080a0',
                pathShadow: '#706080',
                flower1: '#ff70c0',
                flower2: '#ffa080',
                flower3: '#80a0ff',
                tree: '#181830',
                treeFoliage: '#282848',
                vine: '#405060'
            },
            night: {
                skyTop: '#101830',
                skyMid: '#182040',
                skyLow: '#203050',
                skyHorizon: '#304060',
                clouds: '#384868',
                cloudShadow: '#202840',
                moon: '#e0e8ff',
                moonGlow: '#8090c0',
                wallMain: '#384048',
                wallShadow: '#282830',
                wallHighlight: '#4a5058',
                wallMoss: '#304038',
                gateWood: '#282020',
                gateIron: '#181818',
                groundFar: '#203028',
                groundMid: '#182820',
                groundNear: '#102018',
                pathStone: '#404858',
                pathShadow: '#303040',
                flower1: '#6080a0',
                flower2: '#7090a0',
                flower3: '#5070a0',
                tree: '#0a1018',
                treeFoliage: '#101820',
                vine: '#283830'
            }
        };

        function getTimeOfDay() {
            const hour = new Date().getHours();
            const minute = new Date().getMinutes();
            return (hour + minute / 60) / 24;
        }

        function getPalette(t) {
            if (t < 0.22) return lerpPalette(palettes.night, palettes.dawn, t / 0.22);
            if (t < 0.35) return lerpPalette(palettes.dawn, palettes.day, (t - 0.22) / 0.13);
            if (t < 0.6) return palettes.day;
            if (t < 0.72) return lerpPalette(palettes.day, palettes.golden, (t - 0.6) / 0.12);
            if (t < 0.82) return lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.1);
            if (t < 0.92) return lerpPalette(palettes.dusk, palettes.night, (t - 0.82) / 0.1);
            return palettes.night;
        }

        function lerpPalette(p1, p2, t) {
            const result = {};
            for (const key in p1) {
                if (typeof p1[key] === 'string' && p1[key].startsWith('#')) {
                    result[key] = lerpColor(p1[key], p2[key], t);
                } else {
                    result[key] = p1[key];
                }
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAWING - SECRET GARDEN COMPOSITION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawSky(ctx, p) {
            // Sky visible above the walls - just a strip at top
            const gradient = ctx.createLinearGradient(0, 0, 0, height * 0.4);
            gradient.addColorStop(0, p.skyTop);
            gradient.addColorStop(0.5, p.skyMid);
            gradient.addColorStop(1, p.skyLow);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height * 0.45);
        }

        function drawSun(ctx, p, timeOfDay) {
            const isNight = timeOfDay < 0.22 || timeOfDay > 0.85;

            if (isNight) {
                // Moon peeking over the wall
                ctx.fillStyle = p.moonGlow || '#8090c0';
                ctx.beginPath();
                ctx.arc(width * 0.7, height * 0.12, 28, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.moon || '#e0e8ff';
                ctx.beginPath();
                ctx.arc(width * 0.7, height * 0.12, 18, 0, Math.PI * 2);
                ctx.fill();

                // Stars
                for (let i = 0; i < 25; i++) {
                    const sx = seededRandom(i * 7) * width;
                    const sy = seededRandom(i * 11) * height * 0.35;
                    const size = 1 + seededRandom(i * 3) * 1.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + seededRandom(i * 5) * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Sun position - arcs above wall
                const dayProgress = (timeOfDay - 0.22) / 0.63;
                const sunX = width * (0.3 + dayProgress * 0.4);
                const sunY = height * (0.2 - Math.sin(dayProgress * Math.PI) * 0.12);

                ctx.fillStyle = p.sunGlow;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 35, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.sun;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 22, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawClouds(ctx, p, time) {
            if (!p.clouds || p.clouds === p.cloudShadow) return;

            // Small clouds above the walls
            const cloudData = [
                { x: 0.2, y: 0.08, scale: 0.7 },
                { x: 0.6, y: 0.05, scale: 0.9 },
                { x: 0.85, y: 0.1, scale: 0.6 },
            ];

            cloudData.forEach((cloud, i) => {
                const cx = (cloud.x + time * 0.008 * (0.5 + i * 0.2)) % 1.2 - 0.1;
                const cy = cloud.y;
                const scale = cloud.scale * 40;

                ctx.save();
                ctx.translate(cx * width, cy * height);

                ctx.fillStyle = p.cloudShadow;
                ctx.beginPath();
                ctx.ellipse(2, 3, scale * 1.1, scale * 0.45, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.clouds;
                ctx.beginPath();
                ctx.ellipse(0, 0, scale * 1.1, scale * 0.45, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDEN WALLS - The enclosure
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawWalls(ctx, p) {
            const wallTop = height * 0.35;
            const wallHeight = height * 0.3;

            // Back wall (behind arch)
            ctx.fillStyle = p.wallShadow;
            ctx.fillRect(0, wallTop, width, wallHeight);

            // Wall texture - stone blocks
            drawWallTexture(ctx, p, 0, wallTop, width, wallHeight);

            // Wall cap/coping
            ctx.fillStyle = p.wallHighlight;
            ctx.fillRect(0, wallTop - 8, width, 12);

            // Moss on wall top
            for (let x = 0; x < width; x += 15 + seededRandom(x) * 10) {
                if (seededRandom(x * 3) > 0.4) {
                    ctx.fillStyle = p.wallMoss;
                    const mossWidth = 8 + seededRandom(x * 7) * 15;
                    const mossHeight = 5 + seededRandom(x * 11) * 8;
                    ctx.beginPath();
                    ctx.ellipse(x, wallTop - 2, mossWidth, mossHeight, 0, Math.PI, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawWallTexture(ctx, p, x, y, w, h) {
            // Stone block pattern
            const blockH = 25;
            const blockW = 45;

            for (let row = 0; row < h / blockH; row++) {
                const offset = (row % 2) * blockW * 0.5;
                for (let col = -1; col < w / blockW + 1; col++) {
                    const bx = x + col * blockW + offset;
                    const by = y + row * blockH;

                    // Slight color variation
                    const shade = 0.9 + seededRandom(bx * by) * 0.2;
                    ctx.fillStyle = lerpColor(p.wallShadow, p.wallMain, shade);
                    ctx.fillRect(bx + 1, by + 1, blockW - 2, blockH - 2);

                    // Mortar lines (just leave gaps)
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ARCHED GATE - The entrance
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawArchGate(ctx, p) {
            const gateX = width * 0.5;
            const gateW = width * 0.28;
            const gateTop = height * 0.22;
            const gateBottom = height * 0.65;
            const archHeight = height * 0.18;

            // Dark interior (through the gate)
            ctx.fillStyle = '#1a2820';
            ctx.beginPath();
            ctx.moveTo(gateX - gateW/2, gateBottom);
            ctx.lineTo(gateX - gateW/2, gateTop + archHeight);
            ctx.quadraticCurveTo(gateX - gateW/2, gateTop, gateX, gateTop);
            ctx.quadraticCurveTo(gateX + gateW/2, gateTop, gateX + gateW/2, gateTop + archHeight);
            ctx.lineTo(gateX + gateW/2, gateBottom);
            ctx.closePath();
            ctx.fill();

            // Hint of path beyond
            ctx.fillStyle = '#283830';
            ctx.beginPath();
            ctx.moveTo(gateX - 20, gateBottom);
            ctx.lineTo(gateX - 15, gateTop + archHeight + 20);
            ctx.lineTo(gateX + 15, gateTop + archHeight + 20);
            ctx.lineTo(gateX + 20, gateBottom);
            ctx.closePath();
            ctx.fill();

            // Stone arch frame - thick border
            const archThickness = 18;

            // Left pillar
            ctx.fillStyle = p.wallMain;
            ctx.fillRect(gateX - gateW/2 - archThickness, gateTop, archThickness, gateBottom - gateTop);

            // Right pillar
            ctx.fillRect(gateX + gateW/2, gateTop, archThickness, gateBottom - gateTop);

            // Arch top
            ctx.beginPath();
            ctx.moveTo(gateX - gateW/2 - archThickness, gateTop + archHeight);
            ctx.lineTo(gateX - gateW/2 - archThickness, gateTop);
            ctx.quadraticCurveTo(gateX - gateW/2 - archThickness, gateTop - archThickness, gateX, gateTop - archThickness);
            ctx.quadraticCurveTo(gateX + gateW/2 + archThickness, gateTop - archThickness, gateX + gateW/2 + archThickness, gateTop);
            ctx.lineTo(gateX + gateW/2 + archThickness, gateTop + archHeight);
            ctx.lineTo(gateX + gateW/2, gateTop + archHeight);
            ctx.quadraticCurveTo(gateX + gateW/2, gateTop, gateX, gateTop);
            ctx.quadraticCurveTo(gateX - gateW/2, gateTop, gateX - gateW/2, gateTop + archHeight);
            ctx.closePath();
            ctx.fill();

            // Keystone
            ctx.fillStyle = p.wallHighlight;
            ctx.beginPath();
            ctx.moveTo(gateX - 12, gateTop - archThickness);
            ctx.lineTo(gateX - 15, gateTop + 5);
            ctx.lineTo(gateX + 15, gateTop + 5);
            ctx.lineTo(gateX + 12, gateTop - archThickness);
            ctx.closePath();
            ctx.fill();

            // Iron gate (slightly open)
            ctx.strokeStyle = p.gateIron;
            ctx.lineWidth = 3;

            // Left gate door (closed)
            for (let i = 0; i < 4; i++) {
                const barX = gateX - gateW/2 + 8 + i * 12;
                ctx.beginPath();
                ctx.moveTo(barX, gateTop + 15);
                ctx.lineTo(barX, gateBottom);
                ctx.stroke();
            }

            // Right gate door (slightly open/angled)
            ctx.save();
            ctx.translate(gateX + gateW/2 - 5, gateTop + 15);
            ctx.rotate(-0.15);
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-8 - i * 12, 0);
                ctx.lineTo(-8 - i * 12, gateBottom - gateTop - 15);
                ctx.stroke();
            }
            ctx.restore();

            // Decorative horizontal bars
            ctx.beginPath();
            ctx.moveTo(gateX - gateW/2 + 5, gateTop + 40);
            ctx.lineTo(gateX - 5, gateTop + 40);
            ctx.stroke();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SIDE WALLS - Creating the enclosed feeling
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawSideWalls(ctx, p) {
            // Left wall receding into perspective
            ctx.fillStyle = p.wallShadow;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.35);
            ctx.lineTo(width * 0.15, height * 0.45);
            ctx.lineTo(width * 0.15, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Wall texture on left
            ctx.fillStyle = p.wallMain;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.35);
            ctx.lineTo(width * 0.12, height * 0.44);
            ctx.lineTo(width * 0.12, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Right wall
            ctx.fillStyle = p.wallShadow;
            ctx.beginPath();
            ctx.moveTo(width, height * 0.35);
            ctx.lineTo(width * 0.85, height * 0.45);
            ctx.lineTo(width * 0.85, height);
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = p.wallMain;
            ctx.beginPath();
            ctx.moveTo(width, height * 0.35);
            ctx.lineTo(width * 0.88, height * 0.44);
            ctx.lineTo(width * 0.88, height);
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDEN GROUND - The enclosed space
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawGardenGround(ctx, p) {
            // Main garden floor
            const gradient = ctx.createLinearGradient(0, height * 0.65, 0, height);
            gradient.addColorStop(0, p.groundFar);
            gradient.addColorStop(0.4, p.groundMid);
            gradient.addColorStop(1, p.groundNear);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(width * 0.12, height * 0.65);
            ctx.lineTo(width * 0.88, height * 0.65);
            ctx.lineTo(width * 0.85, height);
            ctx.lineTo(width * 0.15, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawGardenPath(ctx, p) {
            // Stone path from gate into garden
            const pathPoints = [
                { x: 0.5, y: 0.65 },
                { x: 0.48, y: 0.72 },
                { x: 0.5, y: 0.80 },
                { x: 0.47, y: 0.88 },
                { x: 0.5, y: 0.95 },
            ];

            // Path stones
            ctx.fillStyle = p.pathStone;

            pathPoints.forEach((pt, i) => {
                const cx = pt.x * width;
                const cy = pt.y * height;
                const stoneW = 35 + i * 8;
                const stoneH = 18 + i * 3;

                // Main stone
                ctx.fillStyle = p.pathStone;
                ctx.beginPath();
                ctx.ellipse(cx, cy, stoneW, stoneH, 0, 0, Math.PI * 2);
                ctx.fill();

                // Side stones
                if (i > 0) {
                    ctx.fillStyle = p.pathShadow;
                    ctx.beginPath();
                    ctx.ellipse(cx - stoneW * 0.8, cy + 5, stoneW * 0.5, stoneH * 0.6, 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(cx + stoneW * 0.7, cy - 3, stoneW * 0.4, stoneH * 0.5, -0.1, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VINES ON WALLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawVines(ctx, p, time) {
            // Vines climbing left wall
            drawVineCluster(ctx, p, width * 0.08, height * 0.5, 8, time, 1);
            drawVineCluster(ctx, p, width * 0.05, height * 0.65, 5, time, 2);

            // Vines on right wall
            drawVineCluster(ctx, p, width * 0.92, height * 0.48, 7, time, 3);
            drawVineCluster(ctx, p, width * 0.9, height * 0.62, 6, time, 4);

            // Vines around arch
            drawVineCluster(ctx, p, width * 0.35, height * 0.28, 6, time, 5);
            drawVineCluster(ctx, p, width * 0.65, height * 0.30, 5, time, 6);
        }

        function drawVineCluster(ctx, p, x, y, count, time, seed) {
            for (let i = 0; i < count; i++) {
                const vx = x + (seededRandom(seed + i) - 0.5) * 30;
                const vy = y + (seededRandom(seed + i + 50) - 0.5) * 40;
                const len = 30 + seededRandom(seed + i + 100) * 50;
                const sway = Math.sin(time * 0.5 + seed + i) * 3;

                // Vine stem
                ctx.strokeStyle = p.vine;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(vx, vy);
                ctx.quadraticCurveTo(vx + sway, vy + len * 0.5, vx + sway * 0.5, vy + len);
                ctx.stroke();

                // Leaves
                for (let j = 0; j < 4; j++) {
                    const ly = vy + len * (j + 1) / 5;
                    const lx = vx + sway * (j / 4);
                    const side = (j % 2 === 0) ? 1 : -1;

                    ctx.fillStyle = p.vine;
                    ctx.beginPath();
                    ctx.ellipse(lx + side * 6, ly, 8, 5, side * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDENER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Gardener {
            constructor() {
                this.x = width * 0.55;
                this.y = height * 0.82;
                this.facing = -1;
                this.bobOffset = 0;
            }

            update(time) {
                this.bobOffset = Math.sin(time * 2) * 1.5;
            }

            draw(ctx, p) {
                const scale = 0.65;
                const h = 45 * scale;
                const x = this.x;
                const y = this.y + this.bobOffset * 0.3;

                ctx.save();
                ctx.translate(x, y);
                ctx.scale(this.facing, 1);

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(0, 2, 12 * scale, 4 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = '#3a4858';
                ctx.fillRect(-5 * scale, -h * 0.35, 4 * scale, h * 0.35);
                ctx.fillRect(1 * scale, -h * 0.35, 4 * scale, h * 0.35);

                // Body - earthy green tunic
                ctx.fillStyle = '#6a8860';
                ctx.beginPath();
                ctx.moveTo(-8 * scale, -h * 0.35);
                ctx.lineTo(-10 * scale, -h * 0.75);
                ctx.lineTo(10 * scale, -h * 0.75);
                ctx.lineTo(8 * scale, -h * 0.35);
                ctx.closePath();
                ctx.fill();

                // Arms
                ctx.fillStyle = '#d0a888';
                ctx.fillRect(-12 * scale, -h * 0.7, 4 * scale, 14 * scale);
                ctx.fillRect(8 * scale, -h * 0.7, 4 * scale, 14 * scale);

                // Head
                ctx.fillStyle = '#e0b898';
                ctx.beginPath();
                ctx.arc(0, -h * 0.85, 8 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#4a3828';
                ctx.beginPath();
                ctx.arc(0, -h * 0.88, 9 * scale, Math.PI, Math.PI * 2);
                ctx.fill();

                // Straw hat
                ctx.fillStyle = '#d8c090';
                ctx.beginPath();
                ctx.ellipse(0, -h * 0.95, 14 * scale, 4 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#c8b080';
                ctx.beginPath();
                ctx.ellipse(0, -h, 8 * scale, 6 * scale, 0, Math.PI, Math.PI * 2);
                ctx.fill();

                // Watering can
                ctx.fillStyle = '#708898';
                ctx.fillRect(10 * scale, -h * 0.5, 8 * scale, 12 * scale);
                ctx.fillRect(15 * scale, -h * 0.6, 6 * scale, 4 * scale);

                ctx.restore();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLANTS INSIDE THE GARDEN
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawPottedPlant(ctx, x, y, scale, p, seed) {
            ctx.save();
            ctx.translate(x, y);

            // Terracotta pot
            ctx.fillStyle = '#b07050';
            ctx.beginPath();
            ctx.moveTo(-15 * scale, 0);
            ctx.lineTo(-12 * scale, -25 * scale);
            ctx.lineTo(12 * scale, -25 * scale);
            ctx.lineTo(15 * scale, 0);
            ctx.closePath();
            ctx.fill();

            // Pot rim
            ctx.fillStyle = '#c08060';
            ctx.fillRect(-14 * scale, -28 * scale, 28 * scale, 6 * scale);

            // Plant in pot
            const colors = [p.flower1, p.flower2, p.flower3];
            for (let i = 0; i < 5; i++) {
                const stemX = (seededRandom(seed + i) - 0.5) * 15 * scale;
                const stemH = (25 + seededRandom(seed + i + 10) * 20) * scale;

                // Stem
                ctx.strokeStyle = p.vine || '#4a7850';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(stemX, -28 * scale);
                ctx.lineTo(stemX + (seededRandom(seed + i + 20) - 0.5) * 10, -28 * scale - stemH);
                ctx.stroke();

                // Flower
                ctx.fillStyle = colors[i % 3];
                ctx.beginPath();
                ctx.arc(stemX, -28 * scale - stemH, 6 * scale, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawFlowerBed(ctx, x, y, w, p, seed) {
            const colors = [p.flower1, p.flower2, p.flower3];

            for (let i = 0; i < 8; i++) {
                const fx = x + (seededRandom(seed + i) - 0.5) * w;
                const fy = y + (seededRandom(seed + i + 50) - 0.5) * 20;
                const h = 20 + seededRandom(seed + i + 100) * 25;

                // Stem
                ctx.strokeStyle = p.vine || '#4a7850';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + (seededRandom(seed + i + 150) - 0.5) * 8, fy - h);
                ctx.stroke();

                // Flower head
                ctx.fillStyle = colors[Math.floor(seededRandom(seed + i + 200) * 3)];
                const petals = 5 + Math.floor(seededRandom(seed + i + 250) * 3);
                const petalSize = 4 + seededRandom(seed + i + 300) * 4;

                for (let j = 0; j < petals; j++) {
                    const angle = (j / petals) * Math.PI * 2;
                    const px = fx + Math.cos(angle) * petalSize;
                    const py = fy - h + Math.sin(angle) * petalSize;
                    ctx.beginPath();
                    ctx.arc(px, py, petalSize * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#ffd040';
                ctx.beginPath();
                ctx.arc(fx, fy - h, petalSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBush(ctx, x, y, scale, p, seed) {
            ctx.save();
            ctx.translate(x, y);

            const blobs = [
                { ox: -12, oy: -8, r: 18 },
                { ox: 8, oy: -12, r: 20 },
                { ox: -3, oy: -20, r: 16 },
                { ox: 12, oy: -6, r: 14 },
            ];

            blobs.forEach((blob, i) => {
                ctx.fillStyle = lerpColor(p.groundNear, p.groundMid, 0.3 + i * 0.15);
                ctx.beginPath();
                ctx.arc(blob.ox * scale, blob.oy * scale, blob.r * scale, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        function drawSmallTree(ctx, x, y, scale, p) {
            ctx.save();
            ctx.translate(x, y);

            // Trunk
            ctx.fillStyle = p.tree || '#2a3828';
            ctx.fillRect(-5 * scale, -30 * scale, 10 * scale, 30 * scale);

            // Foliage layers
            ctx.fillStyle = p.treeFoliage || '#3a5838';
            ctx.beginPath();
            ctx.arc(0, -45 * scale, 25 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = p.tree || '#2a3828';
            ctx.beginPath();
            ctx.arc(0, -55 * scale, 18 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDEN STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const API_BASE = 'https://hushful-telegram-bot.onrender.com';

        let gardenState = {
            name: 'Your Garden',
            health: 0.5,
            status: null,
            plants: [
                { x: 0.25, type: 'bush', growth: 0.7, layer: 1 },
                { x: 0.75, type: 'bush', growth: 0.6, layer: 1 },
                { x: 0.3, type: 'flowers', growth: 0.8, layer: 2 },
                { x: 0.6, type: 'flowers', growth: 0.7, layer: 2 },
                { x: 0.2, type: 'pot', growth: 0.8, layer: 2 },
                { x: 0.8, type: 'pot', growth: 0.6, layer: 2 },
            ]
        };

        async function fetchGardenState() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) return;

            try {
                const response = await fetch(`${API_BASE}/api/garden/${userId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error && data.plants) {
                        gardenState = data;
                        document.getElementById('garden-name').textContent = gardenState.name;
                        updateStatus();
                    }
                }
            } catch (error) {
                console.log('Using default garden');
            }
        }

        let gardener;
        let plantObjects = [];

        function initGarden() {
            gardener = new Gardener();
            gardener.x = width * 0.55;
            gardener.y = height * 0.82;

            plantObjects = gardenState.plants.map((p, i) => ({
                ...p,
                seed: i * 137 + p.x * 1000
            }));

            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            if (gardenState.status) {
                document.getElementById('garden-status').textContent = gardenState.status;
                return;
            }
            const hour = new Date().getHours();
            const messages = {
                5: 'Dawn light through the arch...',
                9: 'A peaceful secret morning...',
                12: 'Sunlight warms the stones...',
                17: 'Golden light on ancient walls...',
                20: 'Evening settles in the garden...',
                23: 'Moonlight through the gate...'
            };
            let msg = messages[23];
            for (const [h, m] of Object.entries(messages)) {
                if (hour >= parseInt(h)) msg = m;
            }
            document.getElementById('garden-status').textContent = msg;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INTERACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const plantStories = {
            bush: {
                icon: 'ğŸŒ¿',
                title: 'Garden Shrub',
                messages: [
                    'Thriving in this sheltered space.',
                    'Your care helps me flourish.',
                    'Growing strong within these walls.'
                ]
            },
            flowers: {
                icon: 'ğŸŒ¸',
                title: 'Wildflowers',
                messages: [
                    'Blooming in your secret garden!',
                    'Each petal reflects your care.',
                    'Color from your healthy choices.'
                ]
            },
            pot: {
                icon: 'ğŸª´',
                title: 'Potted Plant',
                messages: [
                    'Carefully tended and loved.',
                    'A little treasure in your garden.',
                    'Growing happily in its home.'
                ]
            },
            tree: {
                icon: 'ğŸŒ³',
                title: 'Garden Tree',
                messages: [
                    'Reaching toward the sky.',
                    'Deep roots from your consistency.',
                    'Steady growth through steady care.'
                ]
            }
        };

        const tooltip = document.getElementById('plant-tooltip');

        function showPlantTooltip(plant) {
            const story = plantStories[plant.type] || plantStories.flowers;
            document.getElementById('tooltip-icon').textContent = story.icon;
            document.getElementById('tooltip-title').textContent = story.title;
            const msg = story.messages[Math.floor(Math.random() * story.messages.length)];
            document.getElementById('tooltip-message').textContent = msg;
            tooltip.classList.add('visible');
        }

        function findPlantAt(clickX, clickY) {
            // Map plant positions in the enclosed garden space
            for (const plant of plantObjects) {
                // Plants are positioned within the garden bounds
                const px = width * 0.15 + plant.x * width * 0.7;
                const py = height * (0.70 + plant.layer * 0.08);
                const hitRadius = 45;

                const dx = clickX - px;
                const dy = clickY - py;
                if (Math.sqrt(dx * dx + dy * dy) < hitRadius) {
                    return plant;
                }
            }

            // Check gardener
            const gx = gardener.x;
            const gy = gardener.y - 20;
            if (Math.sqrt((clickX - gx) ** 2 + (clickY - gy) ** 2) < 40) {
                return { type: 'gardener' };
            }

            return null;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const p = getPalette(timeOfDay);

            ctx.clearRect(0, 0, width, height);

            // Sky (visible above walls)
            drawSky(ctx, p);
            drawSun(ctx, p, timeOfDay);
            drawClouds(ctx, p, time);

            // Back wall with arch
            drawWalls(ctx, p);
            drawArchGate(ctx, p);

            // Side walls
            drawSideWalls(ctx, p);

            // Garden floor
            drawGardenGround(ctx, p);
            drawGardenPath(ctx, p);

            // Vines on walls
            drawVines(ctx, p, time);

            // Plants - bushes along walls
            plantObjects.filter(pl => pl.type === 'bush').forEach(pl => {
                const px = width * 0.15 + pl.x * width * 0.7;
                drawBush(ctx, px, height * 0.72, pl.growth * 0.7, p, pl.seed);
            });

            // Small tree if health is good
            if (gardenState.health > 0.6) {
                drawSmallTree(ctx, width * 0.22, height * 0.68, 0.6, p);
            }

            // Potted plants
            plantObjects.filter(pl => pl.type === 'pot').forEach(pl => {
                const px = width * 0.15 + pl.x * width * 0.7;
                drawPottedPlant(ctx, px, height * 0.88, pl.growth * 0.8, p, pl.seed);
            });

            // Gardener
            gardener.update(time);
            gardener.draw(ctx, p);

            // Flower beds
            plantObjects.filter(pl => pl.type === 'flowers').forEach(pl => {
                const px = width * 0.15 + pl.x * width * 0.7;
                drawFlowerBed(ctx, px, height * 0.85, 60 * pl.growth, p, pl.seed);
            });

            requestAnimationFrame(render);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STARTUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function startApp() {
            try {
                if (!initCanvas()) {
                    console.error('Failed to initialize canvas');
                    return;
                }

                window.addEventListener('resize', () => { resizeCanvas(); initGarden(); });

                canvas.addEventListener('click', e => {
                    const rect = canvas.getBoundingClientRect();
                    const plant = findPlantAt(e.clientX - rect.left, e.clientY - rect.top);
                    if (plant) {
                        if (plant.type === 'gardener') {
                            document.getElementById('tooltip-icon').textContent = 'ğŸ‘¨â€ğŸŒ¾';
                            document.getElementById('tooltip-title').textContent = 'Your Gardener';
                            document.getElementById('tooltip-message').textContent = 'Tending your secret garden with care. This peaceful space grows with every healthy choice.';
                            tooltip.classList.add('visible');
                        } else {
                            showPlantTooltip(plant);
                        }
                    } else {
                        tooltip.classList.remove('visible');
                    }
                });

                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const plant = findPlantAt(touch.clientX - rect.left, touch.clientY - rect.top);
                    if (plant) {
                        if (plant.type === 'gardener') {
                            document.getElementById('tooltip-icon').textContent = 'ğŸ‘¨â€ğŸŒ¾';
                            document.getElementById('tooltip-title').textContent = 'Your Gardener';
                            document.getElementById('tooltip-message').textContent = 'Tending your secret garden with care. This peaceful space grows with every healthy choice.';
                            tooltip.classList.add('visible');
                        } else {
                            showPlantTooltip(plant);
                        }
                    }
                }, { passive: false });

                tooltip.addEventListener('click', () => tooltip.classList.remove('visible'));

                resizeCanvas();
                initGarden();
                requestAnimationFrame(render);

                fetchGardenState();
                setInterval(fetchGardenState, 5 * 60 * 1000);

                console.log('Secret garden initialized');
            } catch (error) {
                console.error('Error starting garden app:', error);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
    </script>
</body>
</html>
