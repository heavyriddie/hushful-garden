<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
            z-index: 100;
        }

        #garden-name {
            font-size: 18px;
            font-weight: 600;
            color: #2d5a27;
            margin-bottom: 4px;
        }

        #garden-status {
            font-size: 13px;
            color: #666;
        }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <script>
        // Initialize Telegram Web App
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
        }

        // Canvas setup
        const canvas = document.getElementById('garden-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth * window.devicePixelRatio;
            canvas.height = window.innerHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Time of day (0-1, where 0.5 is noon)
        function getTimeOfDay() {
            const now = new Date();
            const hours = now.getHours() + now.getMinutes() / 60;
            return hours / 24;
        }

        // Sky colors based on time
        function getSkyColors(timeOfDay) {
            const colors = {
                night: { top: '#0a1628', bottom: '#1a2744' },
                dawn: { top: '#4a6fa5', bottom: '#f4a460' },
                day: { top: '#87ceeb', bottom: '#e0f4ff' },
                dusk: { top: '#4a3f6b', bottom: '#ff7e67' }
            };

            if (timeOfDay < 0.2 || timeOfDay > 0.85) return colors.night;
            if (timeOfDay < 0.3) return colors.dawn;
            if (timeOfDay < 0.7) return colors.day;
            if (timeOfDay < 0.85) return colors.dusk;
            return colors.night;
        }

        // Plant class
        class Plant {
            constructor(x, groundY, type, growthStage) {
                this.x = x;
                this.groundY = groundY;
                this.type = type;
                this.growthStage = growthStage; // 0-1
                this.swayOffset = Math.random() * Math.PI * 2;
                this.swaySpeed = 0.5 + Math.random() * 0.3;
                this.swayAmount = 0.02 + Math.random() * 0.02;
            }

            draw(ctx, time) {
                const sway = Math.sin(time * this.swaySpeed + this.swayOffset) * this.swayAmount;
                const height = this.getHeight();

                ctx.save();
                ctx.translate(this.x, this.groundY);

                if (this.type === 'flower') {
                    this.drawFlower(ctx, height, sway, time);
                } else if (this.type === 'grass') {
                    this.drawGrass(ctx, height, sway);
                } else if (this.type === 'bush') {
                    this.drawBush(ctx, height, sway);
                } else if (this.type === 'tree') {
                    this.drawTree(ctx, height, sway);
                }

                ctx.restore();
            }

            getHeight() {
                const baseHeights = {
                    flower: 60,
                    grass: 30,
                    bush: 80,
                    tree: 150
                };
                return (baseHeights[this.type] || 50) * this.growthStage;
            }

            drawFlower(ctx, height, sway, time) {
                // Stem
                ctx.strokeStyle = '#3d7a3d';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * height * 30, -height * 0.5, sway * height * 20, -height);
                ctx.stroke();

                // Flower head
                const flowerX = sway * height * 20;
                const flowerY = -height;
                const petalSize = 8 + this.growthStage * 8;

                // Petals
                const colors = ['#ff9ecd', '#ffb7d5', '#ffd4e5', '#ff85c0', '#ffaacc'];
                const petalCount = 5;
                for (let i = 0; i < petalCount; i++) {
                    const angle = (i / petalCount) * Math.PI * 2 + time * 0.1;
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.beginPath();
                    ctx.ellipse(
                        flowerX + Math.cos(angle) * petalSize * 0.5,
                        flowerY + Math.sin(angle) * petalSize * 0.5,
                        petalSize, petalSize * 0.6,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#ffeb3b';
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, petalSize * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }

            drawGrass(ctx, height, sway) {
                const bladeCount = 5;
                for (let i = 0; i < bladeCount; i++) {
                    const offsetX = (i - bladeCount / 2) * 4;
                    const bladeSway = sway * (1 + i * 0.1);

                    ctx.strokeStyle = `hsl(${100 + i * 5}, 60%, ${35 + i * 3}%)`;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.quadraticCurveTo(
                        offsetX + bladeSway * height * 40,
                        -height * 0.6,
                        offsetX + bladeSway * height * 30,
                        -height * (0.8 + i * 0.05)
                    );
                    ctx.stroke();
                }
            }

            drawBush(ctx, height, sway) {
                const bushWidth = height * 1.2;

                // Multiple layered circles for bush effect
                const layers = [
                    { y: -height * 0.3, size: bushWidth * 0.5, color: '#2d5a27' },
                    { y: -height * 0.5, size: bushWidth * 0.6, color: '#3d7a3d' },
                    { y: -height * 0.7, size: bushWidth * 0.4, color: '#4a9a4a' },
                ];

                layers.forEach((layer, i) => {
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    ctx.ellipse(
                        sway * height * 10 * (i + 1),
                        layer.y,
                        layer.size,
                        layer.size * 0.7,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
            }

            drawTree(ctx, height, sway) {
                // Trunk
                ctx.fillStyle = '#5d4037';
                ctx.beginPath();
                ctx.moveTo(-8, 0);
                ctx.lineTo(-6, -height * 0.4);
                ctx.lineTo(6, -height * 0.4);
                ctx.lineTo(8, 0);
                ctx.closePath();
                ctx.fill();

                // Foliage layers
                const foliageY = -height * 0.4;
                const foliageSize = height * 0.5;

                const foliageLayers = [
                    { y: foliageY, size: foliageSize, color: '#2d5a27' },
                    { y: foliageY - foliageSize * 0.3, size: foliageSize * 0.8, color: '#3d7a3d' },
                    { y: foliageY - foliageSize * 0.5, size: foliageSize * 0.5, color: '#4a9a4a' },
                ];

                foliageLayers.forEach((layer, i) => {
                    ctx.fillStyle = layer.color;
                    ctx.beginPath();
                    ctx.ellipse(
                        sway * height * 5 * (i + 1),
                        layer.y,
                        layer.size,
                        layer.size * 0.8,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
            }
        }

        // Butterfly class
        class Butterfly {
            constructor(canvasWidth, canvasHeight) {
                this.x = Math.random() * canvasWidth;
                this.y = canvasHeight * 0.3 + Math.random() * canvasHeight * 0.4;
                this.targetX = this.x;
                this.targetY = this.y;
                this.wingAngle = 0;
                this.color = `hsl(${Math.random() * 60 + 280}, 70%, 60%)`;
                this.size = 8 + Math.random() * 6;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            update(time) {
                // Flap wings
                this.wingAngle = Math.sin(time * 8) * 0.5;

                // Occasionally pick new target
                if (Math.random() < 0.01) {
                    this.targetX = Math.random() * this.canvasWidth;
                    this.targetY = this.canvasHeight * 0.2 + Math.random() * this.canvasHeight * 0.5;
                }

                // Move toward target with gentle floating
                this.x += (this.targetX - this.x) * 0.01 + Math.sin(time * 2) * 0.5;
                this.y += (this.targetY - this.y) * 0.01 + Math.cos(time * 1.5) * 0.3;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Body
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.ellipse(0, 0, 2, this.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                ctx.fillStyle = this.color;

                // Left wings
                ctx.save();
                ctx.rotate(-this.wingAngle);
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.5, -this.size * 0.2, this.size * 0.6, this.size * 0.4, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.4, this.size * 0.2, this.size * 0.4, this.size * 0.3, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Right wings
                ctx.save();
                ctx.rotate(this.wingAngle);
                ctx.beginPath();
                ctx.ellipse(this.size * 0.5, -this.size * 0.2, this.size * 0.6, this.size * 0.4, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(this.size * 0.4, this.size * 0.2, this.size * 0.4, this.size * 0.3, 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }
        }

        // Particle class (for sparkles/fireflies at night)
        class Particle {
            constructor(canvasWidth, canvasHeight, isNight) {
                this.x = Math.random() * canvasWidth;
                this.y = Math.random() * canvasHeight * 0.8;
                this.size = 1 + Math.random() * 2;
                this.speed = 0.2 + Math.random() * 0.3;
                this.opacity = Math.random();
                this.isNight = isNight;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            update(time) {
                this.y -= this.speed;
                this.x += Math.sin(time + this.y * 0.01) * 0.3;
                this.opacity = 0.3 + Math.sin(time * 2 + this.y * 0.1) * 0.3;

                if (this.y < 0) {
                    this.y = this.canvasHeight;
                    this.x = Math.random() * this.canvasWidth;
                }
            }

            draw(ctx) {
                if (this.isNight) {
                    // Firefly glow
                    ctx.fillStyle = `rgba(255, 255, 150, ${this.opacity})`;
                    ctx.shadowColor = 'rgba(255, 255, 100, 0.8)';
                    ctx.shadowBlur = 10;
                } else {
                    // Daytime sparkle
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity * 0.5})`;
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Garden state (this would come from your backend)
        const gardenState = {
            name: tg?.initDataUnsafe?.user?.first_name
                ? `${tg.initDataUnsafe.user.first_name}'s Garden`
                : 'Your Garden',
            plants: [
                { x: 0.15, type: 'tree', growth: 0.9 },
                { x: 0.25, type: 'bush', growth: 0.8 },
                { x: 0.35, type: 'flower', growth: 1 },
                { x: 0.42, type: 'grass', growth: 1 },
                { x: 0.5, type: 'flower', growth: 0.7 },
                { x: 0.58, type: 'grass', growth: 0.9 },
                { x: 0.65, type: 'flower', growth: 0.85 },
                { x: 0.75, type: 'bush', growth: 0.6 },
                { x: 0.85, type: 'tree', growth: 0.7 },
            ]
        };

        // Initialize garden elements
        let plants = [];
        let butterflies = [];
        let particles = [];

        function initGarden() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const groundY = height * 0.85;

            // Create plants from state
            plants = gardenState.plants.map(p =>
                new Plant(p.x * width, groundY, p.type, p.growth)
            );

            // Add some random grass
            for (let i = 0; i < 15; i++) {
                plants.push(new Plant(
                    Math.random() * width,
                    groundY,
                    'grass',
                    0.5 + Math.random() * 0.5
                ));
            }

            // Sort by y position (back to front)
            plants.sort((a, b) => a.groundY - b.groundY);

            // Create butterflies
            butterflies = [];
            for (let i = 0; i < 3; i++) {
                butterflies.push(new Butterfly(width, height));
            }

            // Create particles
            const isNight = getTimeOfDay() < 0.25 || getTimeOfDay() > 0.8;
            particles = [];
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(width, height, isNight));
            }

            // Update info panel
            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            const hour = new Date().getHours();
            let status = '';

            if (hour >= 5 && hour < 9) {
                status = 'Waking up with the sunrise...';
            } else if (hour >= 9 && hour < 12) {
                status = 'Soaking in the morning light...';
            } else if (hour >= 12 && hour < 14) {
                status = 'Enjoying the midday sun...';
            } else if (hour >= 14 && hour < 17) {
                status = 'Growing peacefully...';
            } else if (hour >= 17 && hour < 20) {
                status = 'Settling into evening...';
            } else if (hour >= 20 && hour < 23) {
                status = 'Resting under the stars...';
            } else {
                status = 'Dreaming in the moonlight...';
            }

            document.getElementById('garden-status').textContent = status;
        }

        // Draw sky gradient
        function drawSky(ctx, width, height) {
            const timeOfDay = getTimeOfDay();
            const colors = getSkyColors(timeOfDay);

            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, colors.top);
            gradient.addColorStop(1, colors.bottom);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            // Stars at night
            if (timeOfDay < 0.25 || timeOfDay > 0.8) {
                for (let i = 0; i < 50; i++) {
                    const x = (Math.sin(i * 123.456) * 0.5 + 0.5) * width;
                    const y = (Math.cos(i * 789.012) * 0.5 + 0.5) * height * 0.6;
                    const twinkle = Math.sin(Date.now() * 0.002 + i) * 0.3 + 0.7;

                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + Math.random(), 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Sun or moon
            const celestialY = height * 0.15;
            const celestialX = width * 0.8;

            if (timeOfDay > 0.25 && timeOfDay < 0.75) {
                // Sun
                ctx.fillStyle = '#fff5c0';
                ctx.shadowColor = '#ffeb3b';
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Moon
                ctx.fillStyle = '#f5f5f5';
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 25, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Draw ground
        function drawGround(ctx, width, height) {
            const groundY = height * 0.85;

            // Grass gradient
            const gradient = ctx.createLinearGradient(0, groundY, 0, height);
            gradient.addColorStop(0, '#4a9a4a');
            gradient.addColorStop(0.3, '#3d7a3d');
            gradient.addColorStop(1, '#2d5a27');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, groundY);

            // Gentle hills
            for (let x = 0; x <= width; x += 50) {
                const hillHeight = Math.sin(x * 0.01) * 10 + Math.sin(x * 0.02) * 5;
                ctx.lineTo(x, groundY + hillHeight);
            }

            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }

        // Main render loop
        let lastTime = 0;
        function render(currentTime) {
            const time = currentTime * 0.001;
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Draw scene
            drawSky(ctx, width, height);
            drawGround(ctx, width, height);

            // Update and draw particles
            particles.forEach(p => {
                p.update(time);
                p.draw(ctx);
            });

            // Draw plants (sorted back to front)
            plants.forEach(plant => plant.draw(ctx, time));

            // Update and draw butterflies (only during day)
            const timeOfDay = getTimeOfDay();
            if (timeOfDay > 0.25 && timeOfDay < 0.8) {
                butterflies.forEach(b => {
                    b.update(time);
                    b.draw(ctx);
                });
            }

            // Update status every minute
            if (currentTime - lastTime > 60000) {
                updateStatus();
                lastTime = currentTime;
            }

            requestAnimationFrame(render);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            initGarden();
        });

        // Initialize and start
        initGarden();
        requestAnimationFrame(render);

        // Update night particles periodically
        setInterval(() => {
            const isNight = getTimeOfDay() < 0.25 || getTimeOfDay() > 0.8;
            particles.forEach(p => p.isNight = isNight);
        }, 60000);
    </script>
</body>
</html>
