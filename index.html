<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #1a3020;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Subtle texture overlay */
        #print-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 60;
            mix-blend-mode: multiply;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(250, 245, 235, 0.92);
            padding: 14px 28px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(20, 30, 40, 0.3);
            text-align: center;
            z-index: 100;
            border: 2px solid rgba(60, 50, 40, 0.15);
        }

        #garden-name {
            font-size: 17px;
            font-weight: 600;
            color: #2a3040;
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }

        #garden-status {
            font-size: 11px;
            color: #5a6070;
            font-style: italic;
        }

        #plant-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(250, 245, 235, 0.95);
            padding: 22px 28px;
            border-radius: 16px;
            box-shadow: 0 8px 40px rgba(20, 30, 40, 0.35);
            text-align: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.4, 0.64, 1);
            max-width: 260px;
            border: 2px solid rgba(60, 50, 40, 0.2);
        }

        #plant-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        #tooltip-icon { font-size: 32px; margin-bottom: 8px; }
        #tooltip-title { font-size: 16px; font-weight: 600; color: #2a3040; margin-bottom: 6px; }
        #tooltip-message { font-size: 13px; color: #4a5060; line-height: 1.5; font-style: italic; }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="print-texture"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <div id="plant-tooltip">
        <div id="tooltip-icon"></div>
        <div id="tooltip-title"></div>
        <div id="tooltip-message"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUSHFUL SECRET GARDEN - Intimate, lush, immersive
        // Low viewpoint, dense plantings, grass path through
        // Kawase bold colors with secret garden proportions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let tg = null;
        try {
            tg = window.Telegram?.WebApp;
            if (tg) {
                tg.ready();
                tg.expand();
                document.body.style.background = tg.backgroundColor || '#1a3020';
            }
        } catch (e) {
            console.log('Telegram WebApp init error:', e);
        }

        let canvas, ctx, width, height, dpr;

        function initCanvas() {
            canvas = document.getElementById('garden-canvas');
            if (!canvas) return false;
            ctx = canvas.getContext('2d');
            if (!ctx) return false;
            return true;
        }

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // KAWASE-STYLE COLOR PALETTES - Bold, saturated
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const palettes = {
            dawn: {
                // Sky peeking through canopy
                skyPeek: '#8060a0',
                canopyLight: '#4a7850',
                canopyMid: '#3a6040',
                canopyDark: '#2a4830',
                // Lush greens
                foliageBright: '#60a050',
                foliageMid: '#408838',
                foliageDark: '#286828',
                foliageDeep: '#1a4820',
                // Grass path
                grassLight: '#70b058',
                grassMid: '#509040',
                grassDark: '#387830',
                // Bold flower colors
                flowerPink: '#ff6090',
                flowerMagenta: '#e050a0',
                flowerRed: '#d04060',
                flowerOrange: '#ff8850',
                flowerYellow: '#ffc040',
                flowerBlue: '#6090d0',
                flowerPurple: '#9060c0',
                flowerWhite: '#f0e8e0',
                // Accents
                stone: '#a09080',
                bark: '#4a3828'
            },
            day: {
                skyPeek: '#50a8c0',
                canopyLight: '#58a060',
                canopyMid: '#488850',
                canopyDark: '#387040',
                foliageBright: '#70b860',
                foliageMid: '#509848',
                foliageDark: '#388030',
                foliageDeep: '#286820',
                grassLight: '#80c868',
                grassMid: '#60a850',
                grassDark: '#488838',
                flowerPink: '#ff5088',
                flowerMagenta: '#e048a0',
                flowerRed: '#e04858',
                flowerOrange: '#ff9048',
                flowerYellow: '#ffd048',
                flowerBlue: '#5090e0',
                flowerPurple: '#8858c0',
                flowerWhite: '#fff8f0',
                stone: '#b8a898',
                bark: '#5a4838'
            },
            golden: {
                skyPeek: '#e0a050',
                canopyLight: '#708848',
                canopyMid: '#607838',
                canopyDark: '#506828',
                foliageBright: '#90a850',
                foliageMid: '#709038',
                foliageDark: '#507828',
                foliageDeep: '#406018',
                grassLight: '#a0b860',
                grassMid: '#809848',
                grassDark: '#608030',
                flowerPink: '#ff7080',
                flowerMagenta: '#e06090',
                flowerRed: '#e05050',
                flowerOrange: '#ffa040',
                flowerYellow: '#ffe048',
                flowerBlue: '#7098c0',
                flowerPurple: '#9868b0',
                flowerWhite: '#fff0d8',
                stone: '#d0b898',
                bark: '#584028'
            },
            dusk: {
                skyPeek: '#8050a0',
                canopyLight: '#506868',
                canopyMid: '#405858',
                canopyDark: '#304848',
                foliageBright: '#608870',
                foliageMid: '#487058',
                foliageDark: '#385848',
                foliageDeep: '#284038',
                grassLight: '#709078',
                grassMid: '#587860',
                grassDark: '#486048',
                flowerPink: '#e080a0',
                flowerMagenta: '#c060a0',
                flowerRed: '#c06070',
                flowerOrange: '#e09060',
                flowerYellow: '#e0c060',
                flowerBlue: '#7088b0',
                flowerPurple: '#9070b0',
                flowerWhite: '#e0d8d0',
                stone: '#908888',
                bark: '#403030'
            },
            night: {
                skyPeek: '#203050',
                canopyLight: '#283838',
                canopyMid: '#202830',
                canopyDark: '#181820',
                foliageBright: '#304840',
                foliageMid: '#283830',
                foliageDark: '#202828',
                foliageDeep: '#181820',
                grassLight: '#384840',
                grassMid: '#303830',
                grassDark: '#282828',
                flowerPink: '#806070',
                flowerMagenta: '#705068',
                flowerRed: '#684050',
                flowerOrange: '#806050',
                flowerYellow: '#807050',
                flowerBlue: '#506078',
                flowerPurple: '#605070',
                flowerWhite: '#a0a098',
                stone: '#484848',
                bark: '#282020'
            }
        };

        function getTimeOfDay() {
            const hour = new Date().getHours();
            const minute = new Date().getMinutes();
            return (hour + minute / 60) / 24;
        }

        function getPalette(t) {
            if (t < 0.22) return lerpPalette(palettes.night, palettes.dawn, t / 0.22);
            if (t < 0.35) return lerpPalette(palettes.dawn, palettes.day, (t - 0.22) / 0.13);
            if (t < 0.6) return palettes.day;
            if (t < 0.72) return lerpPalette(palettes.day, palettes.golden, (t - 0.6) / 0.12);
            if (t < 0.82) return lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.1);
            if (t < 0.92) return lerpPalette(palettes.dusk, palettes.night, (t - 0.82) / 0.1);
            return palettes.night;
        }

        function lerpPalette(p1, p2, t) {
            const result = {};
            for (const key in p1) {
                if (typeof p1[key] === 'string' && p1[key].startsWith('#')) {
                    result[key] = lerpColor(p1[key], p2[key], t);
                } else {
                    result[key] = p1[key];
                }
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TREE CANOPY - Overhead branches with dappled light
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawCanopy(ctx, p, time) {
            // Sky peeking through gaps - just small patches at top
            const skyY = height * 0.12;

            // Dappled sky holes
            for (let i = 0; i < 8; i++) {
                const x = width * (0.15 + seededRandom(i * 7) * 0.7);
                const y = skyY * (0.3 + seededRandom(i * 11) * 0.7);
                const rx = 15 + seededRandom(i * 13) * 25;
                const ry = 10 + seededRandom(i * 17) * 15;

                ctx.fillStyle = p.skyPeek;
                ctx.beginPath();
                ctx.ellipse(x, y, rx, ry, seededRandom(i * 3) * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Dense canopy layers
            // Back layer - darkest
            ctx.fillStyle = p.canopyDark;
            drawCanopyLayer(ctx, 0, -height * 0.05, width, height * 0.25, 0.8, 1);

            // Mid layer
            ctx.fillStyle = p.canopyMid;
            drawCanopyLayer(ctx, 0, -height * 0.02, width, height * 0.20, 0.9, 2);

            // Front layer - brightest, with gaps
            ctx.fillStyle = p.canopyLight;
            drawCanopyLayer(ctx, 0, 0, width, height * 0.18, 1.0, 3);

            // Hanging branches on sides
            drawHangingBranches(ctx, p, time);
        }

        function drawCanopyLayer(ctx, x, y, w, h, density, seed) {
            ctx.beginPath();
            ctx.moveTo(x, y);

            // Irregular bottom edge with leaf clusters
            for (let px = 0; px <= w; px += 8) {
                const noise1 = Math.sin(px * 0.02 + seed) * 20;
                const noise2 = Math.sin(px * 0.05 + seed * 2) * 15;
                const noise3 = seededRandom(px * seed) * 25;
                const py = y + h + noise1 + noise2 + noise3 * density;
                ctx.lineTo(x + px, py);
            }

            ctx.lineTo(x + w, y);
            ctx.closePath();
            ctx.fill();

            // Add leaf cluster bumps
            for (let i = 0; i < 20; i++) {
                const cx = x + seededRandom(seed + i * 7) * w;
                const cy = y + h * 0.7 + seededRandom(seed + i * 11) * h * 0.5;
                const r = 15 + seededRandom(seed + i * 13) * 30;

                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawHangingBranches(ctx, p, time) {
            // Left side hanging foliage
            for (let i = 0; i < 5; i++) {
                const x = width * (0.02 + seededRandom(i * 5) * 0.12);
                const y = height * (0.1 + seededRandom(i * 7) * 0.15);
                const sway = Math.sin(time * 0.5 + i) * 3;

                drawFoliageClump(ctx, x + sway, y, p.canopyMid, 0.6 + seededRandom(i * 3) * 0.4, i);
            }

            // Right side hanging foliage
            for (let i = 0; i < 5; i++) {
                const x = width * (0.88 + seededRandom(i * 5 + 50) * 0.12);
                const y = height * (0.1 + seededRandom(i * 7 + 50) * 0.15);
                const sway = Math.sin(time * 0.5 + i + 2) * 3;

                drawFoliageClump(ctx, x + sway, y, p.canopyMid, 0.6 + seededRandom(i * 3 + 50) * 0.4, i + 50);
            }
        }

        function drawFoliageClump(ctx, x, y, color, scale, seed) {
            ctx.fillStyle = color;

            // Main mass
            ctx.beginPath();
            ctx.ellipse(x, y, 30 * scale, 40 * scale, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Additional blobs
            for (let i = 0; i < 4; i++) {
                const ox = (seededRandom(seed + i * 7) - 0.5) * 40 * scale;
                const oy = (seededRandom(seed + i * 11) - 0.5) * 50 * scale;
                const r = (15 + seededRandom(seed + i * 13) * 20) * scale;

                ctx.beginPath();
                ctx.ellipse(x + ox, y + oy, r, r * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GRASS PATH - Winding through the middle
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawGrassPath(ctx, p) {
            // Path recedes into distance - narrower at top
            const pathTop = height * 0.35;
            const pathBottom = height * 1.05;

            // Path shape - curves gently
            ctx.fillStyle = p.grassMid;
            ctx.beginPath();

            // Left edge
            ctx.moveTo(width * 0.35, pathBottom);
            ctx.bezierCurveTo(
                width * 0.38, height * 0.75,
                width * 0.42, height * 0.55,
                width * 0.46, pathTop
            );

            // Top (narrow)
            ctx.lineTo(width * 0.54, pathTop);

            // Right edge
            ctx.bezierCurveTo(
                width * 0.58, height * 0.55,
                width * 0.62, height * 0.75,
                width * 0.65, pathBottom
            );

            ctx.closePath();
            ctx.fill();

            // Lighter center strip
            ctx.fillStyle = p.grassLight;
            ctx.beginPath();
            ctx.moveTo(width * 0.42, pathBottom);
            ctx.bezierCurveTo(
                width * 0.44, height * 0.75,
                width * 0.46, height * 0.55,
                width * 0.48, pathTop + 10
            );
            ctx.lineTo(width * 0.52, pathTop + 10);
            ctx.bezierCurveTo(
                width * 0.54, height * 0.55,
                width * 0.56, height * 0.75,
                width * 0.58, pathBottom
            );
            ctx.closePath();
            ctx.fill();

            // Path edge shadows/definition
            ctx.strokeStyle = p.grassDark;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width * 0.35, pathBottom);
            ctx.bezierCurveTo(
                width * 0.38, height * 0.75,
                width * 0.42, height * 0.55,
                width * 0.46, pathTop
            );
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(width * 0.65, pathBottom);
            ctx.bezierCurveTo(
                width * 0.62, height * 0.75,
                width * 0.58, height * 0.55,
                width * 0.54, pathTop
            );
            ctx.stroke();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FLOWER BORDERS - Dense plantings on both sides
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawFlowerBorders(ctx, p, time) {
            // LEFT BORDER - Multiple layers of depth

            // Back layer (furthest) - darker, smaller
            drawBorderLayer(ctx, p, 'left', 0.35, 0.6, 0.28, time, 100);

            // Mid layer
            drawBorderLayer(ctx, p, 'left', 0.45, 0.75, 0.22, time, 200);

            // Front layer (closest) - brightest, largest
            drawBorderLayer(ctx, p, 'left', 0.55, 0.95, 0.15, time, 300);

            // RIGHT BORDER
            drawBorderLayer(ctx, p, 'right', 0.35, 0.6, 0.28, time, 400);
            drawBorderLayer(ctx, p, 'right', 0.45, 0.75, 0.22, time, 500);
            drawBorderLayer(ctx, p, 'right', 0.55, 0.95, 0.15, time, 600);
        }

        function drawBorderLayer(ctx, p, side, yStart, yEnd, xEdge, time, seed) {
            const isLeft = side === 'left';
            const xBase = isLeft ? 0 : width;
            const xDir = isLeft ? 1 : -1;

            // Foliage base
            const foliageDepth = (yStart < 0.5) ? p.foliageDeep :
                                 (yStart < 0.6) ? p.foliageDark : p.foliageMid;

            ctx.fillStyle = foliageDepth;
            ctx.beginPath();
            ctx.moveTo(xBase, height * yStart);

            for (let y = yStart; y <= yEnd; y += 0.02) {
                const baseX = xEdge + (y - yStart) * 0.3; // Gets wider toward bottom
                const noise = seededRandom(y * 100 + seed) * 0.08;
                const x = isLeft ? width * (baseX + noise) : width * (1 - baseX - noise);
                ctx.lineTo(x, height * y);
            }

            ctx.lineTo(xBase, height * yEnd);
            ctx.closePath();
            ctx.fill();

            // Add shrubs and flowers on top
            const flowerColors = [
                p.flowerPink, p.flowerMagenta, p.flowerRed,
                p.flowerOrange, p.flowerYellow, p.flowerBlue,
                p.flowerPurple, p.flowerWhite
            ];

            // Shrub clusters
            for (let i = 0; i < 8; i++) {
                const y = yStart + seededRandom(seed + i * 7) * (yEnd - yStart);
                const baseX = xEdge + (y - yStart) * 0.25;
                const x = isLeft ?
                    width * (baseX * 0.7 + seededRandom(seed + i * 11) * baseX * 0.5) :
                    width * (1 - baseX * 0.7 - seededRandom(seed + i * 11) * baseX * 0.5);

                const scale = 0.4 + (y - yStart) / (yEnd - yStart) * 0.8;
                const sway = Math.sin(time * 0.3 + seed + i) * 2;

                drawShrub(ctx, x + sway, height * y, scale, p, seed + i * 100);
            }

            // Flower clusters
            for (let i = 0; i < 12; i++) {
                const y = yStart + seededRandom(seed + i * 13 + 50) * (yEnd - yStart);
                const baseX = xEdge + (y - yStart) * 0.2;
                const x = isLeft ?
                    width * (baseX * 0.5 + seededRandom(seed + i * 17 + 50) * baseX * 0.8) :
                    width * (1 - baseX * 0.5 - seededRandom(seed + i * 17 + 50) * baseX * 0.8);

                const scale = 0.5 + (y - yStart) / (yEnd - yStart) * 1.0;
                const color = flowerColors[Math.floor(seededRandom(seed + i * 19) * flowerColors.length)];
                const sway = Math.sin(time * 0.5 + seed + i * 2) * 3;

                drawFlowerClump(ctx, x + sway, height * y, color, scale, p, seed + i * 200);
            }
        }

        function drawShrub(ctx, x, y, scale, p, seed) {
            // Layered round shapes
            const layers = [
                { ox: 0, oy: -20, r: 35, color: p.foliageDark },
                { ox: -15, oy: -10, r: 28, color: p.foliageMid },
                { ox: 12, oy: -25, r: 30, color: p.foliageMid },
                { ox: 5, oy: -35, r: 25, color: p.foliageBright },
            ];

            layers.forEach(layer => {
                ctx.fillStyle = layer.color;
                ctx.beginPath();
                ctx.ellipse(
                    x + layer.ox * scale,
                    y + layer.oy * scale,
                    layer.r * scale,
                    layer.r * scale * 0.8,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            });
        }

        function drawFlowerClump(ctx, x, y, flowerColor, scale, p, seed) {
            // Stems and leaves first
            ctx.strokeStyle = p.foliageDark;
            ctx.lineWidth = 2 * scale;

            const flowerCount = 3 + Math.floor(seededRandom(seed) * 4);
            const positions = [];

            for (let i = 0; i < flowerCount; i++) {
                const stemX = x + (seededRandom(seed + i * 7) - 0.5) * 30 * scale;
                const stemH = (25 + seededRandom(seed + i * 11) * 35) * scale;
                const curve = (seededRandom(seed + i * 13) - 0.5) * 15 * scale;

                ctx.beginPath();
                ctx.moveTo(stemX, y);
                ctx.quadraticCurveTo(stemX + curve, y - stemH * 0.5, stemX + curve * 0.5, y - stemH);
                ctx.stroke();

                positions.push({ x: stemX + curve * 0.5, y: y - stemH });

                // Leaves
                if (seededRandom(seed + i * 17) > 0.4) {
                    const leafY = y - stemH * 0.4;
                    const leafDir = seededRandom(seed + i * 19) > 0.5 ? 1 : -1;
                    ctx.fillStyle = p.foliageMid;
                    ctx.beginPath();
                    ctx.ellipse(stemX + leafDir * 8 * scale, leafY, 10 * scale, 5 * scale, leafDir * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Flower heads
            positions.forEach((pos, i) => {
                const petalCount = 5 + Math.floor(seededRandom(seed + i * 23) * 3);
                const petalSize = (6 + seededRandom(seed + i * 29) * 4) * scale;

                // Petals
                ctx.fillStyle = flowerColor;
                for (let j = 0; j < petalCount; j++) {
                    const angle = (j / petalCount) * Math.PI * 2;
                    const px = pos.x + Math.cos(angle) * petalSize * 0.8;
                    const py = pos.y + Math.sin(angle) * petalSize * 0.8;

                    ctx.beginPath();
                    ctx.ellipse(px, py, petalSize * 0.7, petalSize * 0.5, angle, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = p.flowerYellow;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, petalSize * 0.35, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SPECIAL FLOWERS - Large feature blooms
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawFeatureFlowers(ctx, p, time) {
            // Large rose-like blooms on left
            drawRoseCluster(ctx, width * 0.12, height * 0.45, p.flowerMagenta, 1.2, time, 1);
            drawRoseCluster(ctx, width * 0.08, height * 0.55, p.flowerPink, 1.0, time, 2);
            drawRoseCluster(ctx, width * 0.18, height * 0.62, p.flowerRed, 0.9, time, 3);

            // Purple/blue blooms on right
            drawHydrangea(ctx, width * 0.88, height * 0.48, p.flowerPurple, 1.1, time, 10);
            drawHydrangea(ctx, width * 0.92, height * 0.58, p.flowerBlue, 0.9, time, 11);

            // Hostas with big leaves near path
            drawHosta(ctx, width * 0.28, height * 0.72, p, 1.0, 20);
            drawHosta(ctx, width * 0.72, height * 0.70, p, 0.9, 21);
        }

        function drawRoseCluster(ctx, x, y, color, scale, time, seed) {
            const sway = Math.sin(time * 0.4 + seed) * 4;

            // Multiple rose blooms
            for (let i = 0; i < 4; i++) {
                const rx = x + (seededRandom(seed + i * 7) - 0.5) * 40 * scale + sway;
                const ry = y + (seededRandom(seed + i * 11) - 0.5) * 30 * scale;
                const rs = (0.6 + seededRandom(seed + i * 13) * 0.5) * scale;

                drawRose(ctx, rx, ry, color, rs, seed + i);
            }

            // Foliage behind
            ctx.fillStyle = lerpColor(color, '#2a4020', 0.7);
            for (let i = 0; i < 6; i++) {
                const lx = x + (seededRandom(seed + i * 17) - 0.5) * 50 * scale;
                const ly = y + (seededRandom(seed + i * 19) - 0.5) * 40 * scale + 10;
                ctx.beginPath();
                ctx.ellipse(lx, ly, 15 * scale, 10 * scale, seededRandom(seed + i * 23), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawRose(ctx, x, y, color, scale, seed) {
            // Layered petals from outside in
            const layers = 4;
            for (let layer = 0; layer < layers; layer++) {
                const layerScale = 1 - layer * 0.2;
                const petals = 6 - layer;
                const radius = 18 * scale * layerScale;

                ctx.fillStyle = lerpColor(color, '#ffffff', layer * 0.15);

                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2 + layer * 0.3;
                    const px = x + Math.cos(angle) * radius * 0.5;
                    const py = y + Math.sin(angle) * radius * 0.5;

                    ctx.beginPath();
                    ctx.ellipse(px, py, radius * 0.6, radius * 0.4, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Dark center
            ctx.fillStyle = lerpColor(color, '#301020', 0.5);
            ctx.beginPath();
            ctx.arc(x, y, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHydrangea(ctx, x, y, color, scale, time, seed) {
            const sway = Math.sin(time * 0.35 + seed) * 3;

            // Ball of small flowers
            for (let i = 0; i < 25; i++) {
                const angle = seededRandom(seed + i * 7) * Math.PI * 2;
                const dist = seededRandom(seed + i * 11) * 25 * scale;
                const fx = x + Math.cos(angle) * dist + sway;
                const fy = y + Math.sin(angle) * dist * 0.7;
                const fs = 4 + seededRandom(seed + i * 13) * 3;

                const shade = lerpColor(color, '#ffffff', seededRandom(seed + i * 17) * 0.3);
                ctx.fillStyle = shade;

                // Four-petal flower
                for (let j = 0; j < 4; j++) {
                    const pa = j * Math.PI / 2;
                    ctx.beginPath();
                    ctx.ellipse(
                        fx + Math.cos(pa) * fs * 0.4,
                        fy + Math.sin(pa) * fs * 0.4,
                        fs * 0.5, fs * 0.3, pa, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            // Large leaves below
            ctx.fillStyle = lerpColor(color, '#2a5030', 0.8);
            for (let i = 0; i < 3; i++) {
                const lx = x + (i - 1) * 20 * scale;
                const ly = y + 25 * scale;
                ctx.beginPath();
                ctx.ellipse(lx, ly, 20 * scale, 12 * scale, (i - 1) * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawHosta(ctx, x, y, p, scale, seed) {
            // Large decorative leaves
            const leafCount = 5;

            for (let i = 0; i < leafCount; i++) {
                const angle = (i / leafCount - 0.5) * Math.PI * 0.8;
                const len = (40 + seededRandom(seed + i * 7) * 20) * scale;

                // Leaf shape
                ctx.fillStyle = i % 2 === 0 ? p.foliageBright : p.foliageMid;
                ctx.beginPath();
                ctx.moveTo(x, y);

                const tipX = x + Math.sin(angle) * len;
                const tipY = y - Math.cos(angle) * len * 0.8;
                const bulge = len * 0.4;

                ctx.quadraticCurveTo(
                    x + Math.sin(angle - 0.3) * bulge,
                    y - Math.cos(angle - 0.3) * bulge,
                    tipX, tipY
                );
                ctx.quadraticCurveTo(
                    x + Math.sin(angle + 0.3) * bulge,
                    y - Math.cos(angle + 0.3) * bulge,
                    x, y
                );
                ctx.fill();

                // Vein
                ctx.strokeStyle = p.foliageDark;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(tipX, tipY);
                ctx.stroke();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDENER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Gardener {
            constructor() {
                this.x = width * 0.5;
                this.y = height * 0.68;
                this.facing = 1;
                this.bobOffset = 0;
            }

            update(time) {
                this.bobOffset = Math.sin(time * 2) * 1.5;
            }

            draw(ctx, p) {
                const scale = 0.55;
                const h = 50 * scale;
                const x = this.x;
                const y = this.y + this.bobOffset * 0.3;

                ctx.save();
                ctx.translate(x, y);
                ctx.scale(this.facing, 1);

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.beginPath();
                ctx.ellipse(0, 2, 14 * scale, 5 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = '#3a4858';
                ctx.fillRect(-5 * scale, -h * 0.35, 4 * scale, h * 0.35);
                ctx.fillRect(1 * scale, -h * 0.35, 4 * scale, h * 0.35);

                // Body - earthy green
                ctx.fillStyle = '#6a8860';
                ctx.beginPath();
                ctx.moveTo(-9 * scale, -h * 0.35);
                ctx.lineTo(-11 * scale, -h * 0.78);
                ctx.lineTo(11 * scale, -h * 0.78);
                ctx.lineTo(9 * scale, -h * 0.35);
                ctx.closePath();
                ctx.fill();

                // Arms
                ctx.fillStyle = '#d0a888';
                ctx.fillRect(-13 * scale, -h * 0.72, 4 * scale, 15 * scale);
                ctx.fillRect(9 * scale, -h * 0.72, 4 * scale, 15 * scale);

                // Head
                ctx.fillStyle = '#e0b898';
                ctx.beginPath();
                ctx.arc(0, -h * 0.88, 9 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#4a3828';
                ctx.beginPath();
                ctx.arc(0, -h * 0.92, 10 * scale, Math.PI, Math.PI * 2);
                ctx.fill();

                // Straw hat
                ctx.fillStyle = '#d8c090';
                ctx.beginPath();
                ctx.ellipse(0, -h * 0.98, 16 * scale, 5 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#c8b080';
                ctx.beginPath();
                ctx.ellipse(0, -h * 1.04, 9 * scale, 7 * scale, 0, Math.PI, Math.PI * 2);
                ctx.fill();

                // Watering can
                ctx.fillStyle = '#708898';
                ctx.fillRect(11 * scale, -h * 0.55, 9 * scale, 14 * scale);
                ctx.fillRect(17 * scale, -h * 0.65, 7 * scale, 5 * scale);

                ctx.restore();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FOREGROUND ELEMENTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawForeground(ctx, p, time) {
            // Large plants in extreme foreground (bottom corners)

            // Bottom left - big leaves
            ctx.fillStyle = p.foliageDeep;
            for (let i = 0; i < 4; i++) {
                const x = width * (-0.05 + i * 0.08);
                const y = height * 1.02;
                const angle = -0.3 + i * 0.15 + Math.sin(time * 0.3 + i) * 0.05;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.ellipse(0, -60, 35, 70, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Bottom right - big leaves
            ctx.fillStyle = p.foliageDark;
            for (let i = 0; i < 4; i++) {
                const x = width * (0.78 + i * 0.08);
                const y = height * 1.02;
                const angle = 0.3 - i * 0.15 + Math.sin(time * 0.3 + i + 2) * 0.05;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.ellipse(0, -55, 30, 65, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            // Some flowers peeking at very front
            const fgColors = [p.flowerPink, p.flowerWhite, p.flowerYellow];
            for (let i = 0; i < 5; i++) {
                const x = width * (0.1 + seededRandom(i * 7 + 777) * 0.15);
                const y = height * (0.92 + seededRandom(i * 11 + 777) * 0.08);
                drawFlowerClump(ctx, x, y, fgColors[i % 3], 1.2, p, 777 + i);
            }
            for (let i = 0; i < 5; i++) {
                const x = width * (0.75 + seededRandom(i * 7 + 888) * 0.15);
                const y = height * (0.92 + seededRandom(i * 11 + 888) * 0.08);
                drawFlowerClump(ctx, x, y, fgColors[i % 3], 1.2, p, 888 + i);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDEN STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const API_BASE = 'https://hushful-telegram-bot.onrender.com';

        let gardenState = {
            name: 'Your Garden',
            health: 0.5,
            status: null,
            plants: []
        };

        async function fetchGardenState() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) return;

            try {
                const response = await fetch(`${API_BASE}/api/garden/${userId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error) {
                        gardenState = data;
                        document.getElementById('garden-name').textContent = gardenState.name;
                        updateStatus();
                    }
                }
            } catch (error) {
                console.log('Using default garden');
            }
        }

        let gardener;

        function initGarden() {
            gardener = new Gardener();
            gardener.x = width * 0.5;
            gardener.y = height * 0.68;

            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            if (gardenState.status) {
                document.getElementById('garden-status').textContent = gardenState.status;
                return;
            }
            const hour = new Date().getHours();
            const messages = {
                5: 'Dawn mist in the garden...',
                9: 'Peaceful morning blooms...',
                12: 'Dappled sunlight through leaves...',
                17: 'Golden hour in the garden...',
                20: 'Evening calm settles...',
                23: 'Moonlight on the path...'
            };
            let msg = messages[23];
            for (const [h, m] of Object.entries(messages)) {
                if (hour >= parseInt(h)) msg = m;
            }
            document.getElementById('garden-status').textContent = msg;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INTERACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const tooltip = document.getElementById('plant-tooltip');

        function findInteractable(clickX, clickY) {
            // Check gardener
            const gx = gardener.x;
            const gy = gardener.y - 20;
            if (Math.sqrt((clickX - gx) ** 2 + (clickY - gy) ** 2) < 45) {
                return { type: 'gardener' };
            }

            // Check flower areas (left border)
            if (clickX < width * 0.35 && clickY > height * 0.35) {
                return { type: 'flowers', side: 'left' };
            }

            // Check flower areas (right border)
            if (clickX > width * 0.65 && clickY > height * 0.35) {
                return { type: 'flowers', side: 'right' };
            }

            // Check path
            if (clickX > width * 0.35 && clickX < width * 0.65 && clickY > height * 0.4) {
                return { type: 'path' };
            }

            return null;
        }

        const interactions = {
            gardener: {
                icon: 'ğŸ‘¨â€ğŸŒ¾',
                title: 'Your Gardener',
                messages: [
                    'Tending your garden with care...',
                    'Every healthy choice helps it grow.',
                    'This peaceful space reflects you.'
                ]
            },
            flowers: {
                icon: 'ğŸŒ¸',
                title: 'Flower Border',
                messages: [
                    'Blooming from your healthy choices!',
                    'Each flower reflects your progress.',
                    'Color and life from your care.'
                ]
            },
            path: {
                icon: 'ğŸŒ¿',
                title: 'Garden Path',
                messages: [
                    'A peaceful walk through your garden...',
                    'Each step on your wellness journey.',
                    'The path grows clearer each day.'
                ]
            }
        };

        function showTooltip(item) {
            const info = interactions[item.type] || interactions.flowers;
            document.getElementById('tooltip-icon').textContent = info.icon;
            document.getElementById('tooltip-title').textContent = info.title;
            const msg = info.messages[Math.floor(Math.random() * info.messages.length)];
            document.getElementById('tooltip-message').textContent = msg;
            tooltip.classList.add('visible');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const p = getPalette(timeOfDay);

            ctx.clearRect(0, 0, width, height);

            // Fill with deep foliage color as base
            ctx.fillStyle = p.foliageDeep;
            ctx.fillRect(0, 0, width, height);

            // Tree canopy at top
            drawCanopy(ctx, p, time);

            // Grass path through middle
            drawGrassPath(ctx, p);

            // Flower borders on both sides (back to front)
            drawFlowerBorders(ctx, p, time);

            // Feature flowers
            drawFeatureFlowers(ctx, p, time);

            // Gardener on the path
            gardener.update(time);
            gardener.draw(ctx, p);

            // Foreground elements
            drawForeground(ctx, p, time);

            requestAnimationFrame(render);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STARTUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function startApp() {
            try {
                if (!initCanvas()) {
                    console.error('Failed to initialize canvas');
                    return;
                }

                window.addEventListener('resize', () => { resizeCanvas(); initGarden(); });

                canvas.addEventListener('click', e => {
                    const rect = canvas.getBoundingClientRect();
                    const item = findInteractable(e.clientX - rect.left, e.clientY - rect.top);
                    if (item) {
                        showTooltip(item);
                    } else {
                        tooltip.classList.remove('visible');
                    }
                });

                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const item = findInteractable(touch.clientX - rect.left, touch.clientY - rect.top);
                    if (item) {
                        showTooltip(item);
                    }
                }, { passive: false });

                tooltip.addEventListener('click', () => tooltip.classList.remove('visible'));

                resizeCanvas();
                initGarden();
                requestAnimationFrame(render);

                fetchGardenState();
                setInterval(fetchGardenState, 5 * 60 * 1000);

                console.log('Secret garden initialized');
            } catch (error) {
                console.error('Error starting garden app:', error);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
    </script>
</body>
</html>
