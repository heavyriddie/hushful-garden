<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #2a3040;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Watercolor paper texture - subtle, organic */
        #paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.045;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='paper'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.04' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23paper)'/%3E%3C/svg%3E");
            z-index: 60;
            mix-blend-mode: overlay;
        }

        /* Soft vignette - Ghibli films have gentle edge darkening */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse 120% 100% at 50% 45%,
                transparent 50%,
                rgba(45, 50, 60, 0.22) 100%
            );
            z-index: 55;
        }

        /* Very subtle film grain for that hand-painted feel */
        #grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.025;
            z-index: 65;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grain'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grain)'/%3E%3C/svg%3E");
            animation: grainShift 0.8s steps(3) infinite;
        }

        @keyframes grainShift {
            0% { transform: translate(0, 0); }
            33% { transform: translate(-1px, 1px); }
            66% { transform: translate(1px, -1px); }
            100% { transform: translate(0, 0); }
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(252, 250, 245, 0.85);
            backdrop-filter: blur(12px);
            padding: 14px 28px;
            border-radius: 24px;
            box-shadow:
                0 4px 24px rgba(60, 50, 40, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            text-align: center;
            z-index: 100;
            border: 1px solid rgba(180, 170, 150, 0.12);
        }

        #garden-name {
            font-size: 17px;
            font-weight: 500;
            color: #3a3530;
            margin-bottom: 3px;
            letter-spacing: 0.3px;
        }

        #garden-status {
            font-size: 11px;
            color: #7a7065;
            font-style: italic;
            letter-spacing: 0.2px;
        }

        #plant-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(252, 250, 245, 0.92);
            backdrop-filter: blur(16px);
            padding: 22px 28px;
            border-radius: 20px;
            box-shadow:
                0 8px 40px rgba(60, 50, 40, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            text-align: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.4, 0.64, 1);
            max-width: 260px;
            border: 1px solid rgba(180, 170, 150, 0.1);
        }

        #plant-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        #tooltip-icon { font-size: 32px; margin-bottom: 8px; }
        #tooltip-title { font-size: 16px; font-weight: 600; color: #2a2520; margin-bottom: 6px; }
        #tooltip-message { font-size: 13px; color: #5a5045; line-height: 1.5; font-style: italic; }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="paper-texture"></div>
    <div id="vignette"></div>
    <div id="grain"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <div id="plant-tooltip">
        <div id="tooltip-icon"></div>
        <div id="tooltip-title"></div>
        <div id="tooltip-message"></div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // HUSHFUL GARDEN - Ghibli/Hasui Inspired Edition
        // Soft watercolor washes, atmospheric depth, dreamy tranquility
        // ═══════════════════════════════════════════════════════════════════

        // Initialize Telegram WebApp (if available)
        let tg = null;
        try {
            tg = window.Telegram?.WebApp;
            if (tg) {
                tg.ready();
                tg.expand();
                document.body.style.background = tg.backgroundColor || '#2a3040';
            }
        } catch (e) {
            console.log('Telegram WebApp init error:', e);
        }

        // Wait for DOM to be ready
        let canvas, ctx, width, height, dpr;

        function initCanvas() {
            canvas = document.getElementById('garden-canvas');
            if (!canvas) {
                console.error('Canvas not found');
                return false;
            }
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get 2d context');
                return false;
            }
            return true;
        }

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // ═══════════════════════════════════════════════════════════════════
        // GHIBLI/HASUI COLOR PALETTES
        // Muted, atmospheric, emotionally resonant
        // ═══════════════════════════════════════════════════════════════════

        const palettes = {
            dawn: {
                // Soft rose and peach - early morning mist
                skyTop: '#8090a8',
                skyMid: '#b8a8a0',
                skyLow: '#d8c4b8',
                skyHorizon: '#e8d8cc',
                mist: 'rgba(200, 185, 175, 0.35)',
                sun: '#f0e0d0',
                sunGlow: '#e8d0c0',
                // Soft sage greens with morning dew feel
                hillFar: '#889890',
                hillMid: '#708878',
                hillNear: '#607868',
                groundFar: '#6a8068',
                groundMid: '#5a7058',
                groundNear: '#4a6048',
                // Accents
                flowerWarm: '#c8a090',
                flowerCool: '#a8b0a8',
                warmth: 0.08
            },
            day: {
                // Clear but soft - never harsh
                skyTop: '#7090b0',
                skyMid: '#98b8c8',
                skyLow: '#c0d4dc',
                skyHorizon: '#d8e4e8',
                mist: 'rgba(180, 195, 205, 0.25)',
                sun: '#f8f0e0',
                sunGlow: '#f0e8d8',
                hillFar: '#90a898',
                hillMid: '#789080',
                hillNear: '#688070',
                groundFar: '#6a8868',
                groundMid: '#5a7858',
                groundNear: '#4a6848',
                flowerWarm: '#d0a898',
                flowerCool: '#98b0a0',
                warmth: 0
            },
            golden: {
                // Hasui's golden hour - rich but gentle
                skyTop: '#8898a0',
                skyMid: '#b8a890',
                skyLow: '#d8c8a0',
                skyHorizon: '#e8dcc0',
                mist: 'rgba(210, 190, 160, 0.3)',
                sun: '#f0d8a0',
                sunGlow: '#e8c888',
                hillFar: '#889078',
                hillMid: '#708060',
                hillNear: '#607050',
                groundFar: '#687858',
                groundMid: '#586848',
                groundNear: '#485838',
                flowerWarm: '#d8b088',
                flowerCool: '#a8a078',
                warmth: 0.18
            },
            dusk: {
                // Deep purples and roses - contemplative
                skyTop: '#606878',
                skyMid: '#887888',
                skyLow: '#b09898',
                skyHorizon: '#c8b0a8',
                mist: 'rgba(160, 140, 145, 0.35)',
                sun: '#e0b8a0',
                sunGlow: '#d0a088',
                hillFar: '#606858',
                hillMid: '#505848',
                hillNear: '#404840',
                groundFar: '#4a5840',
                groundMid: '#3a4830',
                groundNear: '#2a3828',
                flowerWarm: '#b89080',
                flowerCool: '#808878',
                warmth: 0.12
            },
            night: {
                // Deep blue night - Totoro forest feeling
                skyTop: '#181c28',
                skyMid: '#202838',
                skyLow: '#283040',
                skyHorizon: '#303848',
                mist: 'rgba(40, 50, 65, 0.4)',
                moon: '#d0d8e0',
                moonGlow: '#a0b0c0',
                hillFar: '#1c2420',
                hillMid: '#141c18',
                hillNear: '#0c1410',
                groundFar: '#182018',
                groundMid: '#101810',
                groundNear: '#081008',
                flowerWarm: '#484850',
                flowerCool: '#384048',
                warmth: -0.05
            }
        };

        let globalWarmth = 0;
        let currentPalette = palettes.day;

        function getTimeOfDay() {
            const now = new Date();
            return (now.getHours() + now.getMinutes() / 60) / 24;
        }

        function getPalette(t) {
            let p;
            if (t < 0.21 || t > 0.87) p = palettes.night;
            else if (t < 0.29) p = lerpPalette(palettes.night, palettes.dawn, (t - 0.21) / 0.08);
            else if (t < 0.38) p = lerpPalette(palettes.dawn, palettes.day, (t - 0.29) / 0.09);
            else if (t < 0.62) p = palettes.day;
            else if (t < 0.70) p = lerpPalette(palettes.day, palettes.golden, (t - 0.62) / 0.08);
            else if (t < 0.78) p = lerpPalette(palettes.golden, palettes.dusk, (t - 0.70) / 0.08);
            else p = lerpPalette(palettes.dusk, palettes.night, (t - 0.78) / 0.09);

            globalWarmth = p.warmth || 0;
            currentPalette = p;
            return p;
        }

        function lerpPalette(a, b, t) {
            const result = {};
            for (const key of Object.keys(a)) {
                if (typeof a[key] === 'number') {
                    result[key] = a[key] + ((b[key] || 0) - a[key]) * t;
                } else if (a[key] && b[key]) {
                    result[key] = lerpColor(a[key], b[key], t);
                } else {
                    result[key] = a[key] || b[key];
                }
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            if (!c1 || !c2) return c1 || c2;
            if (c1.startsWith('rgba') || c2.startsWith('rgba')) return t < 0.5 ? c1 : c2;
            try {
                const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
                const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
                const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
                return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
            } catch (e) { return c1; }
        }

        function hexToRgba(hex, alpha) {
            if (!hex || hex.startsWith('rgba')) return hex;
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function adjustColor(hex, hShift, sShift, lShift) {
            if (!hex || hex.startsWith('rgba')) return hex;
            let r = parseInt(hex.slice(1,3), 16) / 255;
            let g = parseInt(hex.slice(3,5), 16) / 255;
            let b = parseInt(hex.slice(5,7), 16) / 255;

            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) { h = s = 0; }
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            h = (h + hShift / 360 + 1) % 1;
            s = Math.max(0, Math.min(1, s + sShift));
            l = Math.max(0, Math.min(1, l + lShift));

            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);

            return `#${Math.round(r * 255).toString(16).padStart(2,'0')}${Math.round(g * 255).toString(16).padStart(2,'0')}${Math.round(b * 255).toString(16).padStart(2,'0')}`;
        }

        // ═══════════════════════════════════════════════════════════════════
        // UTILITIES - Organic randomness, breathing, soft edges
        // ═══════════════════════════════════════════════════════════════════

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        function noise2D(x, y, seed = 0) {
            return seededRandom(x * 12.9898 + y * 78.233 + seed);
        }

        function getBreath(time, offset = 0, intensity = 0.012) {
            return 1 + Math.sin(time * 0.6 + offset) * intensity;
        }

        function softGlow(ctx, x, y, radius, color, opacity = 0.3) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, hexToRgba(color, opacity));
            gradient.addColorStop(0.4, hexToRgba(color, opacity * 0.5));
            gradient.addColorStop(0.7, hexToRgba(color, opacity * 0.2));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // ═══════════════════════════════════════════════════════════════════
        // SKY - Ghibli's signature graduated washes
        // ═══════════════════════════════════════════════════════════════════

        function drawSky(ctx, p, time) {
            // Multi-stop gradient for that painted sky feel
            const skyGrad = ctx.createLinearGradient(0, 0, 0, height * 0.75);
            skyGrad.addColorStop(0, p.skyTop);
            skyGrad.addColorStop(0.35, p.skyMid);
            skyGrad.addColorStop(0.65, p.skyLow);
            skyGrad.addColorStop(1, p.skyHorizon);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, width, height);

            // Subtle horizontal bands like watercolor bleeding
            ctx.globalAlpha = 0.04;
            for (let i = 0; i < 5; i++) {
                const y = height * (0.1 + i * 0.12);
                const bandHeight = height * 0.08;
                ctx.fillStyle = i % 2 === 0 ? p.skyMid : p.skyLow;
                ctx.fillRect(0, y, width, bandHeight);
            }
            ctx.globalAlpha = 1;
        }

        // ═══════════════════════════════════════════════════════════════════
        // CELESTIAL - Soft, dreamy sun/moon
        // ═══════════════════════════════════════════════════════════════════

        function drawCelestial(ctx, p, timeOfDay, time) {
            const isNight = timeOfDay < 0.23 || timeOfDay > 0.82;

            // Position curves through sky based on time
            const celestialProgress = isNight
                ? (timeOfDay < 0.23 ? (timeOfDay + 0.18) / 0.41 : (timeOfDay - 0.82) / 0.41 + 0.5)
                : (timeOfDay - 0.23) / 0.59;

            const celestialX = width * (0.15 + celestialProgress * 0.7);
            const celestialArc = Math.sin(celestialProgress * Math.PI);
            const celestialY = height * (0.35 - celestialArc * 0.25);

            const breath = getBreath(time, 0, 0.015);

            if (isNight) {
                // Stars - subtle, scattered
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 80; i++) {
                    const sx = seededRandom(i * 73.156) * width;
                    const sy = seededRandom(i * 127.84) * height * 0.55;
                    const twinkle = 0.3 + Math.sin(time * 1.5 + i * 0.8) * 0.3;
                    const size = 0.5 + seededRandom(i * 234) * 1.2;

                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Moon with ethereal glow
                softGlow(ctx, celestialX, celestialY, 80 * breath, p.moonGlow, 0.15);
                softGlow(ctx, celestialX, celestialY, 45 * breath, p.moon, 0.25);
                ctx.fillStyle = p.moon;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 20 * breath, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Sun - soft and warm, not harsh
                softGlow(ctx, celestialX, celestialY, 120 * breath, p.sunGlow, 0.12);
                softGlow(ctx, celestialX, celestialY, 70 * breath, p.sun, 0.2);
                softGlow(ctx, celestialX, celestialY, 40 * breath, '#fff8f0', 0.35);
                ctx.fillStyle = p.sun;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 22 * breath, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // CLOUDS - Soft, puffy Ghibli clouds
        // ═══════════════════════════════════════════════════════════════════

        class Cloud {
            constructor(x, y, scale, seed) {
                this.x = x;
                this.baseY = y;
                this.scale = scale;
                this.seed = seed;
                this.speed = 0.03 + seededRandom(seed) * 0.04;
                this.wobbleOffset = seededRandom(seed + 1) * Math.PI * 2;
            }

            update(time) {
                this.x += this.speed;
                if (this.x > width + 200) this.x = -200;
                this.y = this.baseY + Math.sin(time * 0.1 + this.wobbleOffset) * 4;
            }

            draw(ctx, p) {
                const s = this.scale;
                const breath = getBreath(performance.now() * 0.001, this.wobbleOffset, 0.01);

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(breath, breath);
                ctx.globalAlpha = 0.7;

                // Soft layered cloud masses
                const parts = [
                    { x: 0, y: 0, r: 30 * s },
                    { x: 25 * s, y: -8 * s, r: 35 * s },
                    { x: 55 * s, y: -5 * s, r: 28 * s },
                    { x: 80 * s, y: 3 * s, r: 22 * s },
                    { x: 15 * s, y: 12 * s, r: 24 * s },
                    { x: 45 * s, y: 10 * s, r: 30 * s },
                ];

                // Shadow layer
                ctx.globalAlpha = 0.08;
                parts.forEach(part => {
                    ctx.fillStyle = '#607080';
                    ctx.beginPath();
                    ctx.arc(part.x + 3, part.y + 5, part.r * 0.95, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Main cloud - soft white
                ctx.globalAlpha = 0.65;
                parts.forEach((part, i) => {
                    const lightness = i % 2 === 0 ? '#fafafa' : '#f5f5f5';
                    ctx.fillStyle = lightness;
                    ctx.beginPath();
                    ctx.arc(part.x, part.y, part.r, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // DISTANT HILLS - Layered atmospheric perspective
        // Key to Ghibli/Hasui look: each layer fades to sky color
        // ═══════════════════════════════════════════════════════════════════

        function drawDistantHills(ctx, p, time) {
            // Layer 1: Far mountains - almost silhouette, heavily faded
            drawMountainRange(ctx, {
                baseY: height * 0.48,
                color: lerpColor(p.skyHorizon, p.hillFar, 0.25),
                amplitude: height * 0.12,
                frequency: 0.002,
                offset: time * 0.01,
                opacity: 0.4
            });

            // Layer 2: Mid mountains
            drawMountainRange(ctx, {
                baseY: height * 0.52,
                color: lerpColor(p.skyHorizon, p.hillFar, 0.45),
                amplitude: height * 0.1,
                frequency: 0.003,
                offset: time * 0.015 + 50,
                opacity: 0.55
            });

            // Layer 3: Closer hills
            drawMountainRange(ctx, {
                baseY: height * 0.57,
                color: p.hillFar,
                amplitude: height * 0.08,
                frequency: 0.004,
                offset: time * 0.02 + 100,
                opacity: 0.7
            });

            // Atmospheric mist between layers
            const mistGrad = ctx.createLinearGradient(0, height * 0.45, 0, height * 0.65);
            mistGrad.addColorStop(0, 'transparent');
            mistGrad.addColorStop(0.5, p.mist);
            mistGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = mistGrad;
            ctx.fillRect(0, height * 0.45, width, height * 0.2);
        }

        function drawMountainRange(ctx, opts) {
            ctx.save();
            ctx.globalAlpha = opts.opacity;
            ctx.fillStyle = opts.color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            for (let x = 0; x <= width; x += 3) {
                const n1 = Math.sin(x * opts.frequency + opts.offset);
                const n2 = Math.sin(x * opts.frequency * 2.5 + opts.offset * 1.3) * 0.4;
                const n3 = Math.sin(x * opts.frequency * 0.5 + opts.offset * 0.7) * 0.6;
                const wobble = (seededRandom(x * 0.1 + opts.offset) - 0.5) * 2;
                const y = opts.baseY - (n1 + n2 + n3) * opts.amplitude * 0.5 + wobble;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // ROLLING HILLS - The garden's foundation
        // Ghibli's signature soft, rounded hills
        // ═══════════════════════════════════════════════════════════════════

        function drawRollingHills(ctx, p, time) {
            // Hill layers with increasing saturation/darkness as they get closer
            const hillLayers = [
                { y: 0.62, color: p.hillMid, freq: 0.005, amp: 25, opacity: 0.75 },
                { y: 0.67, color: p.hillNear, freq: 0.007, amp: 20, opacity: 0.85 },
                { y: 0.72, color: p.groundFar, freq: 0.009, amp: 18, opacity: 0.9 },
                { y: 0.77, color: p.groundMid, freq: 0.012, amp: 15, opacity: 0.95 },
                { y: 0.82, color: p.groundNear, freq: 0.015, amp: 12, opacity: 1 },
            ];

            hillLayers.forEach((layer, i) => {
                drawSoftHill(ctx, {
                    baseY: height * layer.y,
                    color: layer.color,
                    frequency: layer.freq,
                    amplitude: layer.amp,
                    offset: time * 0.03 * (i + 1) + i * 30,
                    opacity: layer.opacity
                });
            });

            // Ground mist at the base
            const groundMist = ctx.createLinearGradient(0, height * 0.75, 0, height * 0.88);
            groundMist.addColorStop(0, 'transparent');
            groundMist.addColorStop(1, hexToRgba(p.groundNear, 0.15));
            ctx.fillStyle = groundMist;
            ctx.fillRect(0, height * 0.75, width, height * 0.13);
        }

        function drawSoftHill(ctx, opts) {
            ctx.save();
            ctx.globalAlpha = opts.opacity;
            ctx.fillStyle = opts.color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            for (let x = 0; x <= width; x += 2) {
                const n1 = Math.sin(x * opts.frequency + opts.offset);
                const n2 = Math.sin(x * opts.frequency * 2.2 + opts.offset * 1.4) * 0.35;
                const n3 = Math.sin(x * opts.frequency * 0.6 + opts.offset * 0.8) * 0.45;
                const y = opts.baseY + (n1 + n2 + n3) * opts.amplitude;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // PLANTS - Soft, organic, Ghibli-inspired
        // ═══════════════════════════════════════════════════════════════════

        class Plant {
            constructor(x, groundY, type, growth, layer) {
                this.x = x;
                this.groundY = groundY;
                this.type = type;
                this.growth = Math.max(0.15, growth);
                this.layer = layer;
                this.swayOffset = seededRandom(x * 100) * Math.PI * 2;
                this.swaySpeed = 0.3 + seededRandom(x * 200) * 0.2;
                this.seed = x * 1000 + layer * 100;
                this.hueVariation = (seededRandom(this.seed) - 0.5) * 15;
            }

            getScale() {
                return [0.55, 0.75, 1][this.layer] || 1;
            }

            getOpacity() {
                return [0.6, 0.8, 1][this.layer] || 1;
            }

            draw(ctx, time, p) {
                const sway = Math.sin(time * this.swaySpeed + this.swayOffset) * 0.015;
                const scale = this.getScale();
                const breath = getBreath(time, this.swayOffset, 0.01);

                ctx.save();
                ctx.globalAlpha = this.getOpacity();
                ctx.translate(this.x, this.groundY);
                ctx.scale(scale * breath, scale * breath);

                switch(this.type) {
                    case 'tree': this.drawTree(ctx, sway, time, p); break;
                    case 'bush': this.drawBush(ctx, sway, time, p); break;
                    case 'lavender': this.drawLavender(ctx, sway, p); break;
                    case 'tulip': this.drawTulip(ctx, sway, p); break;
                    case 'wildflower': this.drawWildflower(ctx, sway, time, p); break;
                    case 'fern': this.drawFern(ctx, sway, p); break;
                    case 'grass': this.drawGrass(ctx, sway, p); break;
                    default: this.drawGrass(ctx, sway, p);
                }

                ctx.restore();
            }

            drawTree(ctx, sway, time, p) {
                const h = 90 + this.growth * 70;
                const breath = getBreath(time, this.swayOffset + 1, 0.008);

                // Trunk - soft brown with organic shape
                ctx.fillStyle = adjustColor(p.groundNear, 20, -0.15, 0.1);
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.bezierCurveTo(-5, -h * 0.35, -4, -h * 0.55, -2, -h * 0.6);
                ctx.lineTo(2, -h * 0.6);
                ctx.bezierCurveTo(4, -h * 0.55, 5, -h * 0.35, 6, 0);
                ctx.closePath();
                ctx.fill();

                // Foliage - soft, rounded masses like Totoro's forest
                const foliage = [
                    { x: 0, y: -h * 0.55, r: h * 0.32 },
                    { x: -h * 0.15, y: -h * 0.68, r: h * 0.26 },
                    { x: h * 0.12, y: -h * 0.72, r: h * 0.24 },
                    { x: 0, y: -h * 0.82, r: h * 0.2 },
                    { x: -h * 0.08, y: -h * 0.92, r: h * 0.14 },
                ];

                // Shadow layer
                ctx.globalAlpha = 0.15;
                foliage.forEach(f => {
                    ctx.fillStyle = '#203020';
                    ctx.beginPath();
                    ctx.ellipse(f.x + sway * h * 3 + 4, f.y + 4, f.r * breath, f.r * 0.85 * breath, 0, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Main foliage
                ctx.globalAlpha = 1;
                foliage.forEach((f, i) => {
                    const color = adjustColor(p.groundMid, this.hueVariation, -0.05, i * 0.03);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.ellipse(f.x + sway * h * 3 * (i + 1), f.y, f.r * breath, f.r * 0.85 * breath, 0, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Highlight on top
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = '#c0d8c0';
                ctx.beginPath();
                ctx.ellipse(0 + sway * h * 12, -h * 0.85, h * 0.12, h * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            drawBush(ctx, sway, time, p) {
                const h = 45 + this.growth * 40;
                const w = h * 1.3;
                const breath = getBreath(time, this.swayOffset + 2, 0.01);

                const masses = [
                    { x: -w * 0.2, y: -h * 0.4, rx: w * 0.35, ry: h * 0.35 },
                    { x: w * 0.15, y: -h * 0.5, rx: w * 0.4, ry: h * 0.38 },
                    { x: -w * 0.05, y: -h * 0.6, rx: w * 0.32, ry: h * 0.3 },
                    { x: 0, y: -h * 0.35, rx: w * 0.28, ry: h * 0.28 },
                ];

                // Shadow
                ctx.globalAlpha = 0.12;
                masses.forEach(m => {
                    ctx.fillStyle = '#203020';
                    ctx.beginPath();
                    ctx.ellipse(m.x + 3, m.y + 4, m.rx * breath, m.ry * breath, 0, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.globalAlpha = 1;
                masses.forEach((m, i) => {
                    const color = adjustColor(p.groundMid, this.hueVariation, -0.03, i * 0.025 - 0.05);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.ellipse(m.x + sway * h * 8 * (i + 1), m.y, m.rx * breath, m.ry * breath, 0, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            drawLavender(ctx, sway, p) {
                const h = 50 + this.growth * 30;

                for (let stem = -1; stem <= 1; stem++) {
                    const offsetX = stem * 6;
                    const stemSway = sway * (1 + stem * 0.3);

                    // Stem
                    ctx.strokeStyle = adjustColor(p.groundMid, 10, -0.1, 0.05);
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.bezierCurveTo(
                        offsetX + stemSway * h * 15, -h * 0.4,
                        offsetX + stemSway * h * 20, -h * 0.7,
                        offsetX + stemSway * h * 15, -h
                    );
                    ctx.stroke();

                    // Buds
                    const budCount = 5 + Math.floor(this.growth * 4);
                    for (let i = 0; i < budCount; i++) {
                        const t = 0.4 + (i / budCount) * 0.55;
                        const bx = offsetX + stemSway * h * 15 * t;
                        const by = -h * t;
                        const budSize = 2 + (1 - t) * 2;

                        ctx.fillStyle = adjustColor(p.flowerCool, 240 + this.hueVariation, 0.15, i * 0.02);
                        ctx.beginPath();
                        ctx.ellipse(bx + (seededRandom(this.seed + i) - 0.5) * 2, by, budSize, budSize * 1.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            drawTulip(ctx, sway, p) {
                const h = 40 + this.growth * 35;

                // Stem
                ctx.strokeStyle = adjustColor(p.groundMid, 5, -0.08, 0.05);
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * h * 15, -h * 0.5, sway * h * 10, -h + 8);
                ctx.stroke();

                const tx = sway * h * 10;
                const ty = -h + 8;
                const size = 9 + this.growth * 8;

                // Petals - soft, rounded
                const petalColor = adjustColor(p.flowerWarm, this.hueVariation, 0.1, 0.1);
                const petalHighlight = adjustColor(p.flowerWarm, this.hueVariation + 5, 0.15, 0.18);

                ctx.fillStyle = petalColor;
                ctx.beginPath();
                ctx.ellipse(tx - 3, ty - 5, size * 0.45, size * 0.85, -0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tx + 3, ty - 5, size * 0.45, size * 0.85, 0.15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = petalHighlight;
                ctx.beginPath();
                ctx.ellipse(tx, ty - 3, size * 0.5, size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            drawWildflower(ctx, sway, time, p) {
                const h = 45 + this.growth * 35;

                // Stem
                ctx.strokeStyle = adjustColor(p.groundMid, 8, -0.1, 0.03);
                ctx.lineWidth = 1.8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(sway * h * 18, -h * 0.35, sway * h * 25, -h * 0.65, sway * h * 18, -h);
                ctx.stroke();

                const fx = sway * h * 18;
                const fy = -h;
                const petalSize = 5 + this.growth * 6;

                // Petals
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + time * 0.03;
                    const petalColor = adjustColor(p.flowerWarm, this.hueVariation + i * 8, 0.08, 0.12);
                    ctx.fillStyle = petalColor;
                    ctx.beginPath();
                    ctx.ellipse(
                        fx + Math.cos(angle) * petalSize * 0.35,
                        fy + Math.sin(angle) * petalSize * 0.35,
                        petalSize, petalSize * 0.5,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#e8d8a8';
                ctx.beginPath();
                ctx.arc(fx, fy, petalSize * 0.28, 0, Math.PI * 2);
                ctx.fill();
            }

            drawFern(ctx, sway, p) {
                const h = 35 + this.growth * 30;

                // Main stem
                ctx.strokeStyle = adjustColor(p.groundMid, 5, -0.08, 0.02);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * h * 18, -h * 0.5, sway * h * 14, -h);
                ctx.stroke();

                // Fronds
                for (let i = 0; i < 7; i++) {
                    const t = 0.2 + (i / 7) * 0.75;
                    const fx = sway * h * 18 * t;
                    const fy = -h * t;
                    const side = i % 2 === 0 ? -1 : 1;
                    const frondLen = 12 * (1 - t * 0.4) * this.growth;

                    ctx.strokeStyle = adjustColor(p.groundMid, this.hueVariation, -0.05, t * 0.08);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.quadraticCurveTo(fx + side * frondLen * 0.7, fy - frondLen * 0.3, fx + side * frondLen, fy);
                    ctx.stroke();
                }
            }

            drawGrass(ctx, sway, p) {
                const h = 20 + this.growth * 20;
                const blades = 4 + Math.floor(seededRandom(this.seed) * 3);

                for (let i = 0; i < blades; i++) {
                    const offsetX = (i - blades / 2) * 3;
                    const bladeH = h * (0.65 + seededRandom(this.seed + i) * 0.35);
                    const bladeSway = sway * (1 + i * 0.08);

                    ctx.strokeStyle = adjustColor(p.groundMid, this.hueVariation + i * 3, -0.05, i * 0.02);
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.quadraticCurveTo(
                        offsetX + bladeSway * bladeH * 30,
                        -bladeH * 0.55,
                        offsetX + bladeSway * bladeH * 25,
                        -bladeH
                    );
                    ctx.stroke();
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // AMBIENT PARTICLES - Pollen, fireflies
        // ═══════════════════════════════════════════════════════════════════

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = 1 + Math.random() * 1.5;
                this.speedX = (Math.random() - 0.5) * 0.2;
                this.speedY = -0.05 - Math.random() * 0.1;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.opacity = 0.15 + Math.random() * 0.25;
            }

            update(time, isNight) {
                this.x += this.speedX + Math.sin(time * 0.4 + this.wobbleOffset) * 0.2;
                this.y += this.speedY;
                if (isNight) {
                    this.opacity = 0.2 + Math.sin(time * 2 + this.wobbleOffset) * 0.3;
                }
                if (this.y < -10) {
                    this.y = height + 10;
                    this.x = Math.random() * width;
                }
            }

            draw(ctx, isNight) {
                if (isNight) {
                    // Firefly
                    softGlow(ctx, this.x, this.y, this.size * 5, '#ffffaa', this.opacity * 0.4);
                    ctx.fillStyle = `rgba(255, 255, 200, ${this.opacity})`;
                } else {
                    ctx.fillStyle = `rgba(255, 252, 240, ${this.opacity * 0.4})`;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // BUTTERFLY
        // ═══════════════════════════════════════════════════════════════════

        class Butterfly {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = height * 0.35 + Math.random() * height * 0.35;
                this.targetX = this.x;
                this.targetY = this.y;
                this.wingPhase = Math.random() * Math.PI * 2;
                this.hue = 200 + Math.random() * 80;
                this.size = 5 + Math.random() * 3;
                this.resting = false;
                this.restTimer = 0;
            }

            update(time) {
                this.wingPhase = time * 5;

                if (this.resting) {
                    this.restTimer--;
                    if (this.restTimer <= 0) this.resting = false;
                    return;
                }

                if (Math.random() < 0.002) {
                    this.resting = true;
                    this.restTimer = 80 + Math.random() * 150;
                }

                if (Math.random() < 0.006) {
                    this.targetX = Math.random() * width;
                    this.targetY = height * 0.3 + Math.random() * height * 0.4;
                }

                this.x += (this.targetX - this.x) * 0.012 + Math.sin(time * 1.2) * 0.3;
                this.y += (this.targetY - this.y) * 0.012 + Math.cos(time * 0.9) * 0.25;
            }

            draw(ctx, time, p) {
                const wingAngle = this.resting ? 0.1 : Math.sin(this.wingPhase) * 0.6;

                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.translate(this.x, this.y);

                // Body
                ctx.fillStyle = '#4a4540';
                ctx.beginPath();
                ctx.ellipse(0, 0, 1.2, this.size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                const wingColor = adjustColor(p.flowerCool, this.hue - 200, 0.2, 0.15);

                // Wings
                [-1, 1].forEach(side => {
                    ctx.save();
                    ctx.rotate(side * wingAngle * 0.8);
                    ctx.fillStyle = wingColor;
                    ctx.globalAlpha = 0.75;
                    ctx.beginPath();
                    ctx.ellipse(side * this.size * 0.45, -this.size * 0.1, this.size * 0.5, this.size * 0.35, side * 0.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(side * this.size * 0.32, this.size * 0.12, this.size * 0.35, this.size * 0.25, side * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // GARDEN STATE & INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════

        const API_BASE = 'https://hushful-telegram-bot.onrender.com';

        let gardenState = {
            name: tg?.initDataUnsafe?.user?.first_name
                ? `${tg.initDataUnsafe.user.first_name}'s Garden`
                : 'Your Garden',
            health: 0.5,
            status: 'Growing peacefully...',
            plants: [
                { x: 0.3, type: 'bush', growth: 0.5, layer: 0 },
                { x: 0.5, type: 'fern', growth: 0.5, layer: 1 },
                { x: 0.08, type: 'grass', growth: 0.5, layer: 2 },
                { x: 0.58, type: 'grass', growth: 0.5, layer: 2 },
                { x: 0.85, type: 'grass', growth: 0.5, layer: 2 },
            ]
        };

        async function fetchGardenState() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) return;

            try {
                const response = await fetch(`${API_BASE}/api/garden/${userId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error && data.plants) {
                        gardenState = data;
                        initGarden();
                    }
                }
            } catch (error) {
                console.log('Using default garden');
            }
        }

        let plants = [];
        let particles = [];
        let clouds = [];
        let butterflies = [];

        function initGarden() {
            plants = gardenState.plants.map(p => {
                const layerY = [height * 0.72, height * 0.78, height * 0.86][p.layer];
                return new Plant(p.x * width, layerY, p.type, p.growth, p.layer);
            });
            plants.sort((a, b) => a.layer - b.layer);

            particles = [];
            for (let i = 0; i < 18; i++) particles.push(new Particle());

            clouds = [];
            for (let i = 0; i < 5; i++) {
                clouds.push(new Cloud(
                    Math.random() * width,
                    height * (0.08 + Math.random() * 0.15),
                    0.35 + Math.random() * 0.5,
                    i * 123
                ));
            }

            butterflies = [];
            for (let i = 0; i < 2; i++) butterflies.push(new Butterfly());

            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            if (gardenState.status) {
                document.getElementById('garden-status').textContent = gardenState.status;
                return;
            }
            const hour = new Date().getHours();
            const messages = {
                5: 'Awakening in gentle dawn light...',
                9: 'Basking in soft morning glow...',
                12: 'Resting peacefully at midday...',
                17: 'Glowing in golden afternoon...',
                20: 'Settling into evening calm...',
                23: 'Dreaming under starlight...'
            };
            let msg = messages[23];
            for (const [h, m] of Object.entries(messages)) {
                if (hour >= parseInt(h)) msg = m;
            }
            document.getElementById('garden-status').textContent = msg;
        }

        // ═══════════════════════════════════════════════════════════════════
        // MAIN RENDER
        // ═══════════════════════════════════════════════════════════════════

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const p = getPalette(timeOfDay);
            const isNight = timeOfDay < 0.23 || timeOfDay > 0.82;

            ctx.clearRect(0, 0, width, height);

            drawSky(ctx, p, time);
            drawCelestial(ctx, p, timeOfDay, time);

            if (!isNight) {
                clouds.forEach(c => { c.update(time); c.draw(ctx, p); });
            }

            drawDistantHills(ctx, p, time);
            drawRollingHills(ctx, p, time);

            plants.forEach(pl => pl.draw(ctx, time, p));

            if (!isNight) {
                butterflies.forEach(b => { b.update(time); b.draw(ctx, time, p); });
            }

            particles.forEach(pt => { pt.update(time, isNight); pt.draw(ctx, isNight); });

            requestAnimationFrame(render);
        }

        // ═══════════════════════════════════════════════════════════════════
        // PLANT STORIES & INTERACTIONS
        // ═══════════════════════════════════════════════════════════════════

        const plantStories = {
            tree: { icon: '🌳', title: 'Steady Oak', messages: ['Rooted in your glucose stability.', 'Each steady day helps me grow stronger.', 'I thrive when your energy stays balanced.'] },
            bush: { icon: '🌿', title: 'Engagement Shrub', messages: ['I grow fuller with each visit.', 'Your presence nurtures me.', 'Every check-in helps me flourish.'] },
            lavender: { icon: '💜', title: 'Ketone Lavender', messages: ['I bloom with your metabolic ketones.', 'Your fat-burning fuels my fragrance.', 'In ketosis, I flourish beautifully.'] },
            tulip: { icon: '🌷', title: 'Food Log Tulip', messages: ['Each meal you log helps me bloom.', 'I open wider with your food photos.', 'Your mindful eating makes me vibrant.'] },
            wildflower: { icon: '🌸', title: 'Wellness Wildflower', messages: ['I dance with your metabolic health.', 'When you thrive, I blossom freely.', 'Your journey makes me beautiful.'] },
            fern: { icon: '🌿', title: 'Background Fern', messages: ['I provide quiet support always.', 'Steady and patient, I watch you grow.', 'Even small steps help me unfurl.'] },
            grass: { icon: '🌱', title: 'Foundation Grass', messages: ['The foundation of your garden.', "I'm always here, rooting for you.", 'Simple and steady, day by day.'] }
        };

        const tooltip = document.getElementById('plant-tooltip');
        let tooltipTimeout = null;

        function showPlantTooltip(plant) {
            const story = plantStories[plant.type] || plantStories.grass;
            document.getElementById('tooltip-icon').textContent = story.icon;
            document.getElementById('tooltip-title').textContent = story.title;
            document.getElementById('tooltip-message').textContent = story.messages[Math.floor(Math.random() * story.messages.length)];
            tooltip.classList.add('visible');
            if (tg?.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(() => tooltip.classList.remove('visible'), 3000);
        }

        function findPlantAt(x, y) {
            for (let i = plants.length - 1; i >= 0; i--) {
                const pl = plants[i];
                const scale = pl.getScale();
                const dx = x - pl.x;
                const dy = y - (pl.groundY - 30 * scale);
                if (Math.sqrt(dx * dx + dy * dy) < 40 * scale) return pl;
            }
            return null;
        }

        // ═══════════════════════════════════════════════════════════════════
        // STARTUP - Initialize everything with error handling
        // ═══════════════════════════════════════════════════════════════════

        function startApp() {
            try {
                // Initialize canvas first
                if (!initCanvas()) {
                    console.error('Failed to initialize canvas');
                    return;
                }

                // Setup resize and interaction handlers
                window.addEventListener('resize', () => { resizeCanvas(); initGarden(); });

                canvas.addEventListener('click', e => {
                    const rect = canvas.getBoundingClientRect();
                    const pl = findPlantAt(e.clientX - rect.left, e.clientY - rect.top);
                    if (pl) showPlantTooltip(pl);
                    else tooltip.classList.remove('visible');
                });

                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const pl = findPlantAt(touch.clientX - rect.left, touch.clientY - rect.top);
                    if (pl) showPlantTooltip(pl);
                }, { passive: false });

                tooltip.addEventListener('click', () => tooltip.classList.remove('visible'));

                // Initialize canvas size and start rendering
                resizeCanvas();
                initGarden();
                requestAnimationFrame(render);

                // Fetch real data from API (non-blocking)
                fetchGardenState();
                setInterval(fetchGardenState, 5 * 60 * 1000);

                console.log('Garden initialized successfully');
            } catch (error) {
                console.error('Error starting garden app:', error);
            }
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
    </script>
</body>
</html>
