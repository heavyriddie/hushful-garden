<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #1a2030;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Woodblock print texture - slight grain */
        #print-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.06;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 60;
            mix-blend-mode: multiply;
        }

        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(250, 245, 235, 0.92);
            padding: 14px 28px;
            border-radius: 20px;
            box-shadow: 0 4px 20px rgba(20, 30, 40, 0.3);
            text-align: center;
            z-index: 100;
            border: 2px solid rgba(60, 50, 40, 0.15);
        }

        #garden-name {
            font-size: 17px;
            font-weight: 600;
            color: #2a3040;
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }

        #garden-status {
            font-size: 11px;
            color: #5a6070;
            font-style: italic;
        }

        #plant-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(250, 245, 235, 0.95);
            padding: 22px 28px;
            border-radius: 16px;
            box-shadow: 0 8px 40px rgba(20, 30, 40, 0.35);
            text-align: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.34, 1.4, 0.64, 1);
            max-width: 260px;
            border: 2px solid rgba(60, 50, 40, 0.2);
        }

        #plant-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        #tooltip-icon { font-size: 32px; margin-bottom: 8px; }
        #tooltip-title { font-size: 16px; font-weight: 600; color: #2a3040; margin-bottom: 6px; }
        #tooltip-message { font-size: 13px; color: #4a5060; line-height: 1.5; font-style: italic; }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="print-texture"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <div id="plant-tooltip">
        <div id="tooltip-icon"></div>
        <div id="tooltip-title"></div>
        <div id="tooltip-message"></div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HUSHFUL GARDEN - Kawase Hasui Woodblock Print Edition
        // Bold colors, flat shapes, dramatic atmosphere
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Initialize Telegram WebApp
        let tg = null;
        try {
            tg = window.Telegram?.WebApp;
            if (tg) {
                tg.ready();
                tg.expand();
                document.body.style.background = tg.backgroundColor || '#1a2030';
            }
        } catch (e) {
            console.log('Telegram WebApp init error:', e);
        }

        let canvas, ctx, width, height, dpr;

        function initCanvas() {
            canvas = document.getElementById('garden-canvas');
            if (!canvas) return false;
            ctx = canvas.getContext('2d');
            if (!ctx) return false;
            return true;
        }

        function resizeCanvas() {
            if (!canvas || !ctx) return;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // KAWASE HASUI COLOR PALETTES
        // Bold, saturated, woodblock-print inspired
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const palettes = {
            dawn: {
                // Hot pink and coral sunrise
                skyTop: '#4a5580',
                skyMid: '#8060a0',
                skyLow: '#e080a0',
                skyHorizon: '#f8a088',
                clouds: '#ff90b0',
                cloudShadow: '#c060a0',
                sun: '#ffcc88',
                sunGlow: '#ff9060',
                // Deep forest greens
                hillFar: '#406858',
                hillMid: '#305848',
                hillNear: '#204838',
                groundFar: '#386048',
                groundMid: '#285038',
                groundNear: '#1a4030',
                // Vibrant accents
                flower1: '#ff7090',
                flower2: '#ffaa60',
                flower3: '#90d0ff',
                tree: '#1a3828',
                treeFoliage: '#2a5838',
                path: '#c8a878'
            },
            day: {
                // Bright teal and green
                skyTop: '#3080a0',
                skyMid: '#50a8c0',
                skyLow: '#80c8d8',
                skyHorizon: '#c0e0e8',
                clouds: '#f0f8ff',
                cloudShadow: '#a0c8d8',
                sun: '#fff8e0',
                sunGlow: '#ffe8b0',
                hillFar: '#508868',
                hillMid: '#407858',
                hillNear: '#306848',
                groundFar: '#488858',
                groundMid: '#387848',
                groundNear: '#286838',
                flower1: '#ff6080',
                flower2: '#ffa050',
                flower3: '#80c0ff',
                tree: '#1a3020',
                treeFoliage: '#285028',
                path: '#d8b888'
            },
            golden: {
                // Warm amber afternoon
                skyTop: '#5070a0',
                skyMid: '#a08850',
                skyLow: '#e0a050',
                skyHorizon: '#f8c060',
                clouds: '#ffd080',
                cloudShadow: '#c89040',
                sun: '#fff0a0',
                sunGlow: '#ffc040',
                hillFar: '#607048',
                hillMid: '#506038',
                hillNear: '#405028',
                groundFar: '#587040',
                groundMid: '#486030',
                groundNear: '#385020',
                flower1: '#ff8060',
                flower2: '#ffc040',
                flower3: '#a0d080',
                tree: '#283018',
                treeFoliage: '#384820',
                path: '#e0c090'
            },
            dusk: {
                // Purple and magenta twilight - like the wave image
                skyTop: '#3048a0',
                skyMid: '#6050a0',
                skyLow: '#c060a0',
                skyHorizon: '#e080a0',
                clouds: '#e888c0',
                cloudShadow: '#9050a0',
                sun: '#ffa080',
                sunGlow: '#ff7060',
                hillFar: '#484870',
                hillMid: '#383860',
                hillNear: '#282850',
                groundFar: '#404068',
                groundMid: '#303058',
                groundNear: '#202048',
                flower1: '#ff70c0',
                flower2: '#ffa080',
                flower3: '#80a0ff',
                tree: '#181830',
                treeFoliage: '#282848',
                path: '#9080a0'
            },
            night: {
                // Deep blue and purple
                skyTop: '#101830',
                skyMid: '#182040',
                skyLow: '#203050',
                skyHorizon: '#304060',
                clouds: '#384868',
                cloudShadow: '#202840',
                moon: '#e0e8ff',
                moonGlow: '#8090c0',
                hillFar: '#1a2838',
                hillMid: '#142030',
                hillNear: '#101828',
                groundFar: '#182030',
                groundMid: '#101828',
                groundNear: '#0a1020',
                flower1: '#6080a0',
                flower2: '#7090a0',
                flower3: '#5070a0',
                tree: '#0a1018',
                treeFoliage: '#101820',
                path: '#384050'
            }
        };

        function getTimeOfDay() {
            const hour = new Date().getHours();
            const minute = new Date().getMinutes();
            return (hour + minute / 60) / 24;
        }

        function getPalette(t) {
            if (t < 0.22) return lerpPalette(palettes.night, palettes.dawn, t / 0.22);
            if (t < 0.35) return lerpPalette(palettes.dawn, palettes.day, (t - 0.22) / 0.13);
            if (t < 0.6) return palettes.day;
            if (t < 0.72) return lerpPalette(palettes.day, palettes.golden, (t - 0.6) / 0.12);
            if (t < 0.82) return lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.1);
            if (t < 0.92) return lerpPalette(palettes.dusk, palettes.night, (t - 0.82) / 0.1);
            return palettes.night;
        }

        function lerpPalette(p1, p2, t) {
            const result = {};
            for (const key in p1) {
                if (typeof p1[key] === 'string' && p1[key].startsWith('#')) {
                    result[key] = lerpColor(p1[key], p2[key], t);
                } else {
                    result[key] = p1[key];
                }
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DRAWING FUNCTIONS - Bold, flat woodblock style
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawSky(ctx, p) {
            // Bold gradient bands like woodblock prints
            const gradient = ctx.createLinearGradient(0, 0, 0, height * 0.7);
            gradient.addColorStop(0, p.skyTop);
            gradient.addColorStop(0.35, p.skyMid);
            gradient.addColorStop(0.7, p.skyLow);
            gradient.addColorStop(1, p.skyHorizon);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawClouds(ctx, p, time) {
            const isNight = !p.clouds || p.clouds === p.cloudShadow;
            if (isNight) return;

            // Bold, flat cloud shapes
            const cloudData = [
                { x: 0.15, y: 0.12, scale: 1.2, seed: 1 },
                { x: 0.5, y: 0.08, scale: 1.5, seed: 2 },
                { x: 0.8, y: 0.15, scale: 1.0, seed: 3 },
                { x: 0.3, y: 0.22, scale: 0.8, seed: 4 },
            ];

            cloudData.forEach(cloud => {
                const cx = (cloud.x + time * 0.01 * (0.5 + cloud.seed * 0.2)) % 1.3 - 0.15;
                const cy = cloud.y;
                const scale = cloud.scale * 60;

                ctx.save();
                ctx.translate(cx * width, cy * height);

                // Shadow first
                ctx.fillStyle = p.cloudShadow;
                drawCloudShape(ctx, 3, 6, scale);

                // Main cloud
                ctx.fillStyle = p.clouds;
                drawCloudShape(ctx, 0, 0, scale);

                ctx.restore();
            });
        }

        function drawCloudShape(ctx, ox, oy, scale) {
            ctx.beginPath();
            // Flat, blocky cloud shape
            ctx.ellipse(ox, oy, scale * 1.2, scale * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(ox - scale * 0.6, oy + scale * 0.1, scale * 0.7, scale * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(ox + scale * 0.5, oy + scale * 0.05, scale * 0.8, scale * 0.45, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSun(ctx, p, timeOfDay) {
            const isNight = timeOfDay < 0.22 || timeOfDay > 0.85;
            const dayProgress = isNight ? 0.5 : (timeOfDay - 0.22) / 0.63;
            const sunX = width * (0.2 + dayProgress * 0.6);
            const sunY = height * (0.35 - Math.sin(dayProgress * Math.PI) * 0.25);

            if (isNight) {
                // Moon
                ctx.fillStyle = p.moonGlow || '#8090c0';
                ctx.beginPath();
                ctx.arc(width * 0.75, height * 0.15, 35, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.moon || '#e0e8ff';
                ctx.beginPath();
                ctx.arc(width * 0.75, height * 0.15, 22, 0, Math.PI * 2);
                ctx.fill();

                // Stars
                for (let i = 0; i < 40; i++) {
                    const sx = seededRandom(i * 7) * width;
                    const sy = seededRandom(i * 11) * height * 0.5;
                    const size = 1 + seededRandom(i * 3) * 2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + seededRandom(i * 5) * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Sun glow - bold and bright
                ctx.fillStyle = p.sunGlow;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = p.sun;
                ctx.beginPath();
                ctx.arc(sunX, sunY, 28, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDistantHills(ctx, p) {
            // Far hills - simple bold shapes
            ctx.fillStyle = p.hillFar;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.55);
            for (let x = 0; x <= width; x += 20) {
                const y = height * 0.55 + Math.sin(x * 0.008) * 30 + Math.sin(x * 0.003) * 50;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Mid hills
            ctx.fillStyle = p.hillMid;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.62);
            for (let x = 0; x <= width; x += 15) {
                const y = height * 0.62 + Math.sin(x * 0.01 + 1) * 25 + Math.sin(x * 0.004) * 40;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Near hills
            ctx.fillStyle = p.hillNear;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.68);
            for (let x = 0; x <= width; x += 10) {
                const y = height * 0.68 + Math.sin(x * 0.012 + 2) * 20 + Math.sin(x * 0.005) * 30;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawGround(ctx, p) {
            // Ground layers - flat color bands
            ctx.fillStyle = p.groundFar;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.75);
            for (let x = 0; x <= width; x += 8) {
                const y = height * 0.75 + Math.sin(x * 0.015 + 3) * 12;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = p.groundMid;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.82);
            for (let x = 0; x <= width; x += 6) {
                const y = height * 0.82 + Math.sin(x * 0.02 + 4) * 8;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = p.groundNear;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.88);
            for (let x = 0; x <= width; x += 4) {
                const y = height * 0.88 + Math.sin(x * 0.025 + 5) * 5;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();
        }

        function drawPath(ctx, p) {
            // Winding path through the garden
            ctx.fillStyle = p.path;
            ctx.beginPath();
            ctx.moveTo(width * 0.45, height);
            ctx.bezierCurveTo(
                width * 0.42, height * 0.92,
                width * 0.48, height * 0.85,
                width * 0.44, height * 0.78
            );
            ctx.bezierCurveTo(
                width * 0.40, height * 0.72,
                width * 0.46, height * 0.68,
                width * 0.43, height * 0.65
            );
            // Path width
            ctx.lineTo(width * 0.47, height * 0.65);
            ctx.bezierCurveTo(
                width * 0.50, height * 0.68,
                width * 0.44, height * 0.72,
                width * 0.48, height * 0.78
            );
            ctx.bezierCurveTo(
                width * 0.52, height * 0.85,
                width * 0.46, height * 0.92,
                width * 0.52, height
            );
            ctx.closePath();
            ctx.fill();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDENER CHARACTER - Small figure tending the garden
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class Gardener {
            constructor() {
                this.x = width * 0.46;
                this.y = height * 0.76;
                this.facing = 1; // 1 = right, -1 = left
                this.action = 'standing'; // standing, walking, tending
                this.bobOffset = 0;
            }

            update(time) {
                this.bobOffset = Math.sin(time * 2) * 2;
            }

            draw(ctx, p) {
                const scale = 0.7;
                const h = 45 * scale; // Height
                const x = this.x;
                const y = this.y + this.bobOffset * 0.3;

                ctx.save();
                ctx.translate(x, y);
                ctx.scale(this.facing, 1);

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(0, 2, 12 * scale, 4 * scale, 0, 0, Math.PI * 2);
                ctx.fill();

                // Legs - simple shapes
                ctx.fillStyle = '#3a4858';
                ctx.fillRect(-5 * scale, -h * 0.35, 4 * scale, h * 0.35);
                ctx.fillRect(1 * scale, -h * 0.35, 4 * scale, h * 0.35);

                // Body/dress - earthy tone
                ctx.fillStyle = '#6a8860';
                ctx.beginPath();
                ctx.moveTo(-8 * scale, -h * 0.35);
                ctx.lineTo(-10 * scale, -h * 0.75);
                ctx.lineTo(10 * scale, -h * 0.75);
                ctx.lineTo(8 * scale, -h * 0.35);
                ctx.closePath();
                ctx.fill();

                // Arms
                ctx.fillStyle = '#d0a888';
                ctx.fillRect(-12 * scale, -h * 0.7, 4 * scale, 14 * scale);
                ctx.fillRect(8 * scale, -h * 0.7, 4 * scale, 14 * scale);

                // Head
                ctx.fillStyle = '#e0b898';
                ctx.beginPath();
                ctx.arc(0, -h * 0.85, 8 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Hair
                ctx.fillStyle = '#4a3828';
                ctx.beginPath();
                ctx.arc(0, -h * 0.88, 9 * scale, Math.PI, Math.PI * 2);
                ctx.fill();

                // Hat - straw gardening hat
                ctx.fillStyle = '#d8c090';
                ctx.beginPath();
                ctx.ellipse(0, -h * 0.95, 14 * scale, 4 * scale, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#c8b080';
                ctx.beginPath();
                ctx.ellipse(0, -h, 8 * scale, 6 * scale, 0, Math.PI, Math.PI * 2);
                ctx.fill();

                // Watering can or tool
                ctx.fillStyle = '#708898';
                ctx.fillRect(10 * scale, -h * 0.5, 8 * scale, 12 * scale);
                ctx.fillRect(15 * scale, -h * 0.6, 6 * scale, 4 * scale);

                ctx.restore();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TREES - Bold, blocky like Hasui prints
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawTree(ctx, x, y, scale, p, seed) {
            const h = 120 * scale;
            const sway = Math.sin(seed * 100) * 0.02;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(sway);

            // Trunk - dark and solid
            ctx.fillStyle = p.tree;
            ctx.beginPath();
            ctx.moveTo(-8 * scale, 0);
            ctx.lineTo(-6 * scale, -h * 0.4);
            ctx.lineTo(6 * scale, -h * 0.4);
            ctx.lineTo(8 * scale, 0);
            ctx.closePath();
            ctx.fill();

            // Foliage - bold layered shapes
            const foliageColor = p.treeFoliage;
            const layers = [
                { cy: -h * 0.5, rx: 35, ry: 25 },
                { cy: -h * 0.65, rx: 40, ry: 28 },
                { cy: -h * 0.8, rx: 32, ry: 22 },
                { cy: -h * 0.92, rx: 22, ry: 16 },
            ];

            layers.forEach((layer, i) => {
                ctx.fillStyle = lerpColor(foliageColor, p.tree, i * 0.15);
                ctx.beginPath();
                ctx.ellipse(0, layer.cy, layer.rx * scale, layer.ry * scale, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FLOWERS - Bright pops of color
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawFlower(ctx, x, y, color, scale, seed) {
            const h = 25 * scale;
            const petalSize = 6 * scale;

            ctx.save();
            ctx.translate(x, y);

            // Stem
            ctx.strokeStyle = '#2a5030';
            ctx.lineWidth = 2 * scale;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.sin(seed) * 3, -h);
            ctx.stroke();

            // Flower head - bold simple shape
            ctx.fillStyle = color;
            const petals = 5 + Math.floor(seededRandom(seed) * 3);
            for (let i = 0; i < petals; i++) {
                const angle = (i / petals) * Math.PI * 2;
                const px = Math.cos(angle) * petalSize * 0.8;
                const py = -h + Math.sin(angle) * petalSize * 0.8;
                ctx.beginPath();
                ctx.arc(px, py, petalSize * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }

            // Center
            ctx.fillStyle = '#ffc040';
            ctx.beginPath();
            ctx.arc(0, -h, petalSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawFlowerCluster(ctx, x, y, p, count, seed) {
            const colors = [p.flower1, p.flower2, p.flower3];
            for (let i = 0; i < count; i++) {
                const fx = x + (seededRandom(seed + i) - 0.5) * 40;
                const fy = y + (seededRandom(seed + i + 100) - 0.5) * 15;
                const color = colors[Math.floor(seededRandom(seed + i + 50) * 3)];
                const scale = 0.6 + seededRandom(seed + i + 200) * 0.5;
                drawFlower(ctx, fx, fy, color, scale, seed + i);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BUSHES - Round, bold shapes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function drawBush(ctx, x, y, scale, p, seed) {
            const colors = [p.groundNear, p.groundMid, p.hillNear];

            ctx.save();
            ctx.translate(x, y);

            // Multiple overlapping circles
            const blobs = [
                { ox: -15, oy: -10, r: 22 },
                { ox: 10, oy: -15, r: 25 },
                { ox: -5, oy: -25, r: 20 },
                { ox: 15, oy: -8, r: 18 },
            ];

            blobs.forEach((blob, i) => {
                ctx.fillStyle = colors[i % 3];
                ctx.beginPath();
                ctx.arc(blob.ox * scale, blob.oy * scale, blob.r * scale, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GARDEN STATE & PLANT MANAGEMENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const API_BASE = 'https://hushful-telegram-bot.onrender.com';

        let gardenState = {
            name: 'Your Garden',
            health: 0.5,
            status: null,
            plants: [
                { x: 0.15, type: 'tree', growth: 0.8, layer: 0 },
                { x: 0.85, type: 'tree', growth: 0.6, layer: 0 },
                { x: 0.3, type: 'bush', growth: 0.7, layer: 1 },
                { x: 0.7, type: 'bush', growth: 0.6, layer: 1 },
                { x: 0.2, type: 'flowers', growth: 0.8, layer: 2 },
                { x: 0.5, type: 'flowers', growth: 0.7, layer: 2 },
                { x: 0.75, type: 'flowers', growth: 0.9, layer: 2 },
            ]
        };

        async function fetchGardenState() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) return;

            try {
                const response = await fetch(`${API_BASE}/api/garden/${userId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error && data.plants) {
                        gardenState = data;
                        document.getElementById('garden-name').textContent = gardenState.name;
                        updateStatus();
                    }
                }
            } catch (error) {
                console.log('Using default garden');
            }
        }

        let gardener;
        let plantObjects = [];

        function initGarden() {
            gardener = new Gardener();
            gardener.x = width * 0.46;
            gardener.y = height * 0.76;

            plantObjects = gardenState.plants.map((p, i) => ({
                ...p,
                seed: i * 137 + p.x * 1000
            }));

            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            if (gardenState.status) {
                document.getElementById('garden-status').textContent = gardenState.status;
                return;
            }
            const hour = new Date().getHours();
            const messages = {
                5: 'Dawn breaks over the garden...',
                9: 'A peaceful morning...',
                12: 'Basking in warm sunlight...',
                17: 'Golden afternoon glow...',
                20: 'Evening calm settles in...',
                23: 'Resting under the stars...'
            };
            let msg = messages[23];
            for (const [h, m] of Object.entries(messages)) {
                if (hour >= parseInt(h)) msg = m;
            }
            document.getElementById('garden-status').textContent = msg;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PLANT INTERACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const plantStories = {
            tree: {
                icon: 'ğŸŒ³',
                title: 'Ancient Oak',
                messages: [
                    'Steady glucose brings steady growth...',
                    'Your consistency shows in every ring.',
                    'Deep roots come from daily care.'
                ]
            },
            bush: {
                icon: 'ğŸŒ¿',
                title: 'Garden Shrub',
                messages: [
                    'Thriving from your engagement!',
                    'Each check-in helps me grow.',
                    'Your attention makes me flourish.'
                ]
            },
            flowers: {
                icon: 'ğŸŒ¸',
                title: 'Wildflowers',
                messages: [
                    'Blooming from your ketone balance!',
                    'Good food choices made these petals.',
                    'Your metabolic health is beautiful.'
                ]
            }
        };

        const tooltip = document.getElementById('plant-tooltip');

        function showPlantTooltip(plant) {
            const story = plantStories[plant.type] || plantStories.flowers;
            document.getElementById('tooltip-icon').textContent = story.icon;
            document.getElementById('tooltip-title').textContent = story.title;
            const msg = story.messages[Math.floor(Math.random() * story.messages.length)];
            document.getElementById('tooltip-message').textContent = msg;
            tooltip.classList.add('visible');
        }

        function findPlantAt(clickX, clickY) {
            // Check each plant area
            for (const plant of plantObjects) {
                const px = plant.x * width;
                const py = height * (0.78 - plant.layer * 0.08);
                const hitRadius = 50;

                const dx = clickX - px;
                const dy = clickY - py;
                if (Math.sqrt(dx * dx + dy * dy) < hitRadius) {
                    return plant;
                }
            }

            // Check gardener
            const gx = gardener.x;
            const gy = gardener.y - 20;
            if (Math.sqrt((clickX - gx) ** 2 + (clickY - gy) ** 2) < 40) {
                return { type: 'gardener' };
            }

            return null;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAIN RENDER LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const p = getPalette(timeOfDay);

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Background layers
            drawSky(ctx, p);
            drawSun(ctx, p, timeOfDay);
            drawClouds(ctx, p, time);
            drawDistantHills(ctx, p);
            drawGround(ctx, p);
            drawPath(ctx, p);

            // Trees in back
            plantObjects.filter(pl => pl.type === 'tree').forEach(pl => {
                drawTree(ctx, pl.x * width, height * 0.72, pl.growth * 0.8, p, pl.seed);
            });

            // Bushes
            plantObjects.filter(pl => pl.type === 'bush').forEach(pl => {
                drawBush(ctx, pl.x * width, height * 0.80, pl.growth * 0.8, p, pl.seed);
            });

            // Gardener
            gardener.update(time);
            gardener.draw(ctx, p);

            // Flowers in front
            plantObjects.filter(pl => pl.type === 'flowers').forEach(pl => {
                drawFlowerCluster(ctx, pl.x * width, height * 0.86, p, 5 + Math.floor(pl.growth * 5), pl.seed);
            });

            requestAnimationFrame(render);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STARTUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function startApp() {
            try {
                if (!initCanvas()) {
                    console.error('Failed to initialize canvas');
                    return;
                }

                window.addEventListener('resize', () => { resizeCanvas(); initGarden(); });

                canvas.addEventListener('click', e => {
                    const rect = canvas.getBoundingClientRect();
                    const plant = findPlantAt(e.clientX - rect.left, e.clientY - rect.top);
                    if (plant) {
                        if (plant.type === 'gardener') {
                            document.getElementById('tooltip-icon').textContent = 'ğŸ‘¨â€ğŸŒ¾';
                            document.getElementById('tooltip-title').textContent = 'Your Gardener';
                            document.getElementById('tooltip-message').textContent = 'Tending your garden with care. Every healthy choice you make helps the garden grow!';
                            tooltip.classList.add('visible');
                        } else {
                            showPlantTooltip(plant);
                        }
                    } else {
                        tooltip.classList.remove('visible');
                    }
                });

                canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const plant = findPlantAt(touch.clientX - rect.left, touch.clientY - rect.top);
                    if (plant) {
                        if (plant.type === 'gardener') {
                            document.getElementById('tooltip-icon').textContent = 'ğŸ‘¨â€ğŸŒ¾';
                            document.getElementById('tooltip-title').textContent = 'Your Gardener';
                            document.getElementById('tooltip-message').textContent = 'Tending your garden with care. Every healthy choice you make helps the garden grow!';
                            tooltip.classList.add('visible');
                        } else {
                            showPlantTooltip(plant);
                        }
                    }
                }, { passive: false });

                tooltip.addEventListener('click', () => tooltip.classList.remove('visible'));

                resizeCanvas();
                initGarden();
                requestAnimationFrame(render);

                fetchGardenState();
                setInterval(fetchGardenState, 5 * 60 * 1000);

                console.log('Garden initialized successfully');
            } catch (error) {
                console.error('Error starting garden app:', error);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
    </script>
</body>
</html>
