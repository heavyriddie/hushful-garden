<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #1a1a2e;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 252, 247, 0.92);
            backdrop-filter: blur(12px);
            padding: 14px 28px;
            border-radius: 24px;
            box-shadow:
                0 4px 24px rgba(107, 91, 74, 0.15),
                0 1px 3px rgba(107, 91, 74, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            text-align: center;
            z-index: 100;
            border: 1px solid rgba(107, 91, 74, 0.08);
        }

        #garden-name {
            font-size: 17px;
            font-weight: 500;
            color: #5a4a3a;
            margin-bottom: 3px;
            letter-spacing: 0.3px;
        }

        #garden-status {
            font-size: 12px;
            color: #8a7a6a;
            font-style: italic;
            letter-spacing: 0.2px;
        }

        /* Soft vignette overlay */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse at center,
                transparent 50%,
                rgba(42, 36, 56, 0.3) 100%
            );
            z-index: 50;
        }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="vignette"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════
        // HUSHFUL GARDEN - Soft Watercolor Style
        // A cozy, dreamy metabolic garden visualization
        // ═══════════════════════════════════════════════════════════

        // Initialize Telegram Web App
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            // Match Telegram theme
            document.body.style.background = tg.backgroundColor || '#1a1a2e';
        }

        // Canvas setup with high DPI support
        const canvas = document.getElementById('garden-canvas');
        const ctx = canvas.getContext('2d');
        let width, height, dpr;

        function resizeCanvas() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        resizeCanvas();

        // ═══════════════════════════════════════════════════════════
        // COLOR PALETTES - Soft, muted, watercolor-inspired
        // ═══════════════════════════════════════════════════════════

        const palettes = {
            dawn: {
                skyTop: '#c9b8d4',      // Soft lavender
                skyMid: '#e8d4c4',      // Warm cream
                skyBottom: '#f5e6d3',   // Peachy white
                sun: '#ffe8c4',
                sunGlow: 'rgba(255, 220, 180, 0.4)',
                groundFar: '#a8c4a0',   // Sage green
                groundMid: '#8fb087',   // Soft forest
                groundNear: '#7a9a72',  // Deeper sage
                accent: '#d4a5a5'       // Dusty rose
            },
            day: {
                skyTop: '#a8c8dc',      // Soft sky blue
                skyMid: '#d4e4ec',      // Pale blue
                skyBottom: '#e8f0f4',   // Almost white blue
                sun: '#fff8e8',
                sunGlow: 'rgba(255, 248, 220, 0.5)',
                groundFar: '#9cb894',   // Light sage
                groundMid: '#7fa078',   // Medium sage
                groundNear: '#6a8a64',  // Forest sage
                accent: '#c4d4b4'       // Soft lime
            },
            golden: {
                skyTop: '#d4c4a8',      // Warm beige
                skyMid: '#e8d8b8',      // Golden cream
                skyBottom: '#f4e8c8',   // Butter yellow
                sun: '#ffe4a8',
                sunGlow: 'rgba(255, 210, 140, 0.5)',
                groundFar: '#a8b894',   // Warm sage
                groundMid: '#8a9a78',   // Golden green
                groundNear: '#6a7a5a',  // Olive sage
                accent: '#d4c494'       // Warm gold
            },
            dusk: {
                skyTop: '#8a7a9a',      // Dusty purple
                skyMid: '#c4a8b4',      // Mauve
                skyBottom: '#e4c8c4',   // Blush
                sun: '#f4d4b4',
                sunGlow: 'rgba(244, 180, 140, 0.4)',
                groundFar: '#7a8a74',   // Muted sage
                groundMid: '#5a6a54',   // Deep sage
                groundNear: '#4a5a44',  // Dark sage
                accent: '#b4949a'       // Dusty rose
            },
            night: {
                skyTop: '#2a2438',      // Deep purple
                skyMid: '#3a3448',      // Soft purple
                skyBottom: '#4a4458',   // Lighter purple
                moon: '#e8e4f0',
                moonGlow: 'rgba(200, 190, 220, 0.3)',
                groundFar: '#3a4438',   // Night sage
                groundMid: '#2a3428',   // Deep forest
                groundNear: '#1a2418',  // Almost black green
                accent: '#6a5a7a'       // Night purple
            }
        };

        function getTimeOfDay() {
            const now = new Date();
            return (now.getHours() + now.getMinutes() / 60) / 24;
        }

        function getPalette(t) {
            if (t < 0.22 || t > 0.88) return palettes.night;
            if (t < 0.32) return lerpPalette(palettes.night, palettes.dawn, (t - 0.22) / 0.1);
            if (t < 0.42) return lerpPalette(palettes.dawn, palettes.day, (t - 0.32) / 0.1);
            if (t < 0.65) return palettes.day;
            if (t < 0.72) return lerpPalette(palettes.day, palettes.golden, (t - 0.65) / 0.07);
            if (t < 0.80) return lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.08);
            return lerpPalette(palettes.dusk, palettes.night, (t - 0.80) / 0.08);
        }

        function lerpPalette(a, b, t) {
            const result = {};
            for (const key of Object.keys(a)) {
                result[key] = lerpColor(a[key], b[key], t);
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            if (c1.startsWith('rgba')) return c1; // Skip rgba
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        // ═══════════════════════════════════════════════════════════
        // AMBIENT PARTICLES - Pollen, dust motes, fireflies
        // ═══════════════════════════════════════════════════════════

        class AmbientParticle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = 1 + Math.random() * 2.5;
                this.speedX = (Math.random() - 0.5) * 0.3;
                this.speedY = -0.1 - Math.random() * 0.2;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.5 + Math.random() * 0.5;
                this.opacity = 0.2 + Math.random() * 0.4;
                this.fadeSpeed = 0.002 + Math.random() * 0.003;
            }

            update(time, isNight) {
                this.x += this.speedX + Math.sin(time * this.wobbleSpeed + this.wobbleOffset) * 0.3;
                this.y += this.speedY;

                if (isNight) {
                    // Fireflies pulse
                    this.opacity = 0.3 + Math.sin(time * 2 + this.wobbleOffset) * 0.3;
                }

                if (this.y < -10 || this.x < -10 || this.x > width + 10) {
                    this.y = height + 10;
                    this.x = Math.random() * width;
                }
            }

            draw(ctx, isNight, palette) {
                ctx.save();
                if (isNight) {
                    // Firefly glow
                    ctx.shadowColor = '#ffffa0';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = `rgba(255, 255, 200, ${this.opacity})`;
                } else {
                    // Pollen/dust mote
                    ctx.fillStyle = `rgba(255, 252, 240, ${this.opacity * 0.6})`;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════
        // CLOUDS - Soft, painterly clouds
        // ═══════════════════════════════════════════════════════════

        class Cloud {
            constructor(x, y, scale) {
                this.x = x;
                this.baseY = y;
                this.scale = scale;
                this.speed = 0.05 + Math.random() * 0.1;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.opacity = 0.3 + Math.random() * 0.3;
            }

            update(time) {
                this.x += this.speed;
                if (this.x > width + 200) this.x = -200;
                this.y = this.baseY + Math.sin(time * 0.2 + this.wobbleOffset) * 5;
            }

            draw(ctx, palette) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = '#fff';

                // Soft cloud shape using multiple circles
                const s = this.scale;
                const circles = [
                    { x: 0, y: 0, r: 30 * s },
                    { x: 25 * s, y: -10 * s, r: 35 * s },
                    { x: 55 * s, y: -5 * s, r: 28 * s },
                    { x: 80 * s, y: 5 * s, r: 22 * s },
                    { x: 15 * s, y: 15 * s, r: 20 * s },
                    { x: 50 * s, y: 12 * s, r: 25 * s },
                ];

                circles.forEach(c => {
                    ctx.beginPath();
                    ctx.arc(this.x + c.x, this.y + c.y, c.r, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════
        // PLANTS - Organic, soft-edged flora
        // ═══════════════════════════════════════════════════════════

        class Plant {
            constructor(x, groundY, type, growth, layer) {
                this.x = x;
                this.groundY = groundY;
                this.type = type;
                this.growth = Math.max(0.1, growth);
                this.layer = layer; // 0=far, 1=mid, 2=near (affects size/color)
                this.swayOffset = Math.random() * Math.PI * 2;
                this.swaySpeed = 0.4 + Math.random() * 0.3;
                this.swayAmount = 0.015 + Math.random() * 0.015;
                this.hueShift = (Math.random() - 0.5) * 15;
            }

            getLayerScale() {
                return [0.5, 0.75, 1][this.layer] || 1;
            }

            draw(ctx, time, palette) {
                const sway = Math.sin(time * this.swaySpeed + this.swayOffset) * this.swayAmount;
                const scale = this.getLayerScale();

                // Atmospheric perspective - far layers are slightly faded
                const layerOpacity = [0.7, 0.85, 1][this.layer] || 1;

                ctx.save();
                ctx.globalAlpha = layerOpacity;
                ctx.translate(this.x, this.groundY);
                ctx.scale(scale, scale);

                switch(this.type) {
                    case 'wildflower': this.drawWildflower(ctx, sway, time, palette); break;
                    case 'tulip': this.drawTulip(ctx, sway, palette); break;
                    case 'lavender': this.drawLavender(ctx, sway, time, palette); break;
                    case 'grass': this.drawGrass(ctx, sway, palette); break;
                    case 'fern': this.drawFern(ctx, sway, palette); break;
                    case 'bush': this.drawBush(ctx, sway, palette); break;
                    case 'tree': this.drawTree(ctx, sway, palette); break;
                    default: this.drawGrass(ctx, sway, palette);
                }

                ctx.restore();
            }

            drawWildflower(ctx, sway, time, palette) {
                const h = 50 + this.growth * 40;

                // Stem - organic curve
                ctx.strokeStyle = this.adjustColor('#7a9a6a', -10);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    sway * h * 20, -h * 0.3,
                    sway * h * 25 + 5, -h * 0.6,
                    sway * h * 20, -h
                );
                ctx.stroke();

                // Flower head
                const fx = sway * h * 20;
                const fy = -h;
                const petalSize = 6 + this.growth * 6;

                // Soft petals
                const petalColors = ['#e8b4b4', '#d4a0a0', '#c8a0b0', '#d8b8b8', '#e0c0c0'];
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + time * 0.05;
                    ctx.fillStyle = petalColors[i];
                    ctx.beginPath();
                    ctx.ellipse(
                        fx + Math.cos(angle) * petalSize * 0.4,
                        fy + Math.sin(angle) * petalSize * 0.4,
                        petalSize, petalSize * 0.5,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Center
                ctx.fillStyle = '#f4e4b4';
                ctx.beginPath();
                ctx.arc(fx, fy, petalSize * 0.35, 0, Math.PI * 2);
                ctx.fill();
            }

            drawTulip(ctx, sway, palette) {
                const h = 45 + this.growth * 35;

                // Stem
                ctx.strokeStyle = '#6a8a5a';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * h * 15, -h * 0.5, sway * h * 10, -h + 10);
                ctx.stroke();

                // Tulip cup - layered petals
                const tx = sway * h * 10;
                const ty = -h + 10;
                const size = 10 + this.growth * 8;

                // Back petals
                ctx.fillStyle = '#c89090';
                ctx.beginPath();
                ctx.ellipse(tx - 4, ty - 5, size * 0.5, size * 0.9, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tx + 4, ty - 5, size * 0.5, size * 0.9, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Front petal
                ctx.fillStyle = '#d8a0a0';
                ctx.beginPath();
                ctx.ellipse(tx, ty - 3, size * 0.6, size * 0.85, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            drawLavender(ctx, sway, time, palette) {
                const h = 55 + this.growth * 30;

                // Multiple stems
                for (let s = -1; s <= 1; s++) {
                    const offsetX = s * 6;
                    const stemSway = sway + s * 0.01;

                    // Stem
                    ctx.strokeStyle = '#7a9070';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.bezierCurveTo(
                        offsetX + stemSway * h * 15, -h * 0.4,
                        offsetX + stemSway * h * 20, -h * 0.7,
                        offsetX + stemSway * h * 15, -h
                    );
                    ctx.stroke();

                    // Lavender buds
                    const budCount = 6 + Math.floor(this.growth * 4);
                    for (let i = 0; i < budCount; i++) {
                        const t = 0.4 + (i / budCount) * 0.6;
                        const bx = offsetX + stemSway * h * 15 * t;
                        const by = -h * t;
                        const budSize = 2 + (1 - t) * 2;

                        ctx.fillStyle = `hsl(${270 + this.hueShift}, 40%, ${55 + i * 2}%)`;
                        ctx.beginPath();
                        ctx.ellipse(bx + (Math.random() - 0.5) * 3, by, budSize, budSize * 1.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            drawGrass(ctx, sway, palette) {
                const h = 25 + this.growth * 20;
                const blades = 5 + Math.floor(Math.random() * 3);

                for (let i = 0; i < blades; i++) {
                    const offsetX = (i - blades / 2) * 3;
                    const bladeH = h * (0.7 + Math.random() * 0.3);
                    const bladeSway = sway * (1 + i * 0.08);

                    const hue = 95 + this.hueShift + i * 3;
                    ctx.strokeStyle = `hsl(${hue}, 35%, ${35 + this.layer * 8}%)`;
                    ctx.lineWidth = 1.5;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.quadraticCurveTo(
                        offsetX + bladeSway * bladeH * 30,
                        -bladeH * 0.6,
                        offsetX + bladeSway * bladeH * 25,
                        -bladeH
                    );
                    ctx.stroke();
                }
            }

            drawFern(ctx, sway, palette) {
                const h = 40 + this.growth * 30;

                // Main stem
                ctx.strokeStyle = '#5a7a50';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * h * 20, -h * 0.5, sway * h * 15, -h);
                ctx.stroke();

                // Fronds
                const frondCount = 8;
                for (let i = 0; i < frondCount; i++) {
                    const t = 0.2 + (i / frondCount) * 0.75;
                    const fx = sway * h * 20 * t;
                    const fy = -h * t;
                    const side = i % 2 === 0 ? -1 : 1;
                    const frondLen = 15 * (1 - t * 0.5) * this.growth;

                    ctx.strokeStyle = `hsl(${100 + this.hueShift}, 35%, ${40 + i * 2}%)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.quadraticCurveTo(
                        fx + side * frondLen * 0.7, fy - frondLen * 0.3,
                        fx + side * frondLen, fy - frondLen * 0.1
                    );
                    ctx.stroke();
                }
            }

            drawBush(ctx, sway, palette) {
                const h = 50 + this.growth * 40;
                const w = h * 1.3;

                // Layered foliage blobs
                const layers = [
                    { x: -w * 0.2, y: -h * 0.4, w: w * 0.5, h: h * 0.5, hue: 95 },
                    { x: w * 0.1, y: -h * 0.5, w: w * 0.55, h: h * 0.55, hue: 100 },
                    { x: -w * 0.1, y: -h * 0.6, w: w * 0.45, h: h * 0.45, hue: 105 },
                    { x: 0, y: -h * 0.35, w: w * 0.4, h: h * 0.4, hue: 98 },
                ];

                layers.forEach((l, i) => {
                    ctx.fillStyle = `hsl(${l.hue + this.hueShift}, 30%, ${32 + i * 5 + this.layer * 5}%)`;
                    ctx.beginPath();
                    ctx.ellipse(
                        l.x + sway * h * 8 * (i + 1),
                        l.y,
                        l.w, l.h,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
            }

            drawTree(ctx, sway, palette) {
                const h = 100 + this.growth * 60;

                // Trunk
                ctx.fillStyle = '#5a4a3a';
                ctx.beginPath();
                ctx.moveTo(-6, 0);
                ctx.bezierCurveTo(-5, -h * 0.3, -4, -h * 0.5, -3, -h * 0.6);
                ctx.lineTo(3, -h * 0.6);
                ctx.bezierCurveTo(4, -h * 0.5, 5, -h * 0.3, 6, 0);
                ctx.closePath();
                ctx.fill();

                // Foliage - soft layered blobs
                const foliage = [
                    { x: 0, y: -h * 0.55, r: h * 0.35, hue: 95 },
                    { x: -h * 0.15, y: -h * 0.7, r: h * 0.28, hue: 100 },
                    { x: h * 0.12, y: -h * 0.72, r: h * 0.25, hue: 98 },
                    { x: 0, y: -h * 0.85, r: h * 0.22, hue: 105 },
                    { x: -h * 0.08, y: -h * 0.95, r: h * 0.15, hue: 102 },
                ];

                foliage.forEach((f, i) => {
                    ctx.fillStyle = `hsl(${f.hue + this.hueShift}, 28%, ${30 + i * 4 + this.layer * 5}%)`;
                    ctx.beginPath();
                    ctx.ellipse(
                        f.x + sway * h * 3 * (i + 1),
                        f.y,
                        f.r, f.r * 0.85,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                });
            }

            adjustColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.min(255, Math.max(0, (num >> 16) + amount));
                const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
                const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
                return `#${(1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1)}`;
            }
        }

        // ═══════════════════════════════════════════════════════════
        // BUTTERFLY - Delicate, floating visitor
        // ═══════════════════════════════════════════════════════════

        class Butterfly {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = height * 0.3 + Math.random() * height * 0.4;
                this.targetX = this.x;
                this.targetY = this.y;
                this.wingPhase = Math.random() * Math.PI * 2;
                this.hue = 280 + Math.random() * 60; // Purple to pink range
                this.size = 6 + Math.random() * 4;
                this.restTimer = 0;
                this.isResting = false;
            }

            update(time) {
                this.wingPhase = time * 6;

                if (this.isResting) {
                    this.restTimer--;
                    if (this.restTimer <= 0) this.isResting = false;
                    return;
                }

                // Occasionally rest on a flower
                if (Math.random() < 0.002) {
                    this.isResting = true;
                    this.restTimer = 120 + Math.random() * 180;
                }

                // Pick new target occasionally
                if (Math.random() < 0.008) {
                    this.targetX = Math.random() * width;
                    this.targetY = height * 0.25 + Math.random() * height * 0.45;
                }

                // Float toward target
                this.x += (this.targetX - this.x) * 0.012 + Math.sin(time * 1.5) * 0.4;
                this.y += (this.targetY - this.y) * 0.012 + Math.cos(time * 1.2) * 0.3;
            }

            draw(ctx) {
                const wingAngle = this.isResting
                    ? 0.1
                    : Math.sin(this.wingPhase) * 0.6;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Body
                ctx.fillStyle = '#4a3a3a';
                ctx.beginPath();
                ctx.ellipse(0, 0, 1.5, this.size * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings - soft watercolor effect
                const wingColor = `hsla(${this.hue}, 50%, 65%, 0.8)`;
                const wingHighlight = `hsla(${this.hue + 20}, 60%, 75%, 0.6)`;

                // Left wings
                ctx.save();
                ctx.rotate(-wingAngle * 0.8);
                ctx.fillStyle = wingColor;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.5, -this.size * 0.15, this.size * 0.55, this.size * 0.35, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = wingHighlight;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.35, this.size * 0.15, this.size * 0.35, this.size * 0.25, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Right wings
                ctx.save();
                ctx.rotate(wingAngle * 0.8);
                ctx.fillStyle = wingColor;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.5, -this.size * 0.15, this.size * 0.55, this.size * 0.35, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = wingHighlight;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.35, this.size * 0.15, this.size * 0.35, this.size * 0.25, 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════
        // SCENE RENDERING
        // ═══════════════════════════════════════════════════════════

        function drawSky(ctx, palette, time) {
            // Multi-stop gradient for depth
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, palette.skyTop);
            gradient.addColorStop(0.4, palette.skyMid);
            gradient.addColorStop(1, palette.skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawCelestial(ctx, palette, timeOfDay, time) {
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;
            const celestialX = width * 0.75;
            const celestialY = height * 0.12;

            ctx.save();

            if (isNight) {
                // Stars
                for (let i = 0; i < 60; i++) {
                    const sx = (Math.sin(i * 73.156) * 0.5 + 0.5) * width;
                    const sy = (Math.cos(i * 127.84) * 0.5 + 0.5) * height * 0.5;
                    const twinkle = Math.sin(time * 1.5 + i * 0.5) * 0.3 + 0.5;
                    const starSize = 0.5 + Math.random() * 1;

                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.7})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, starSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Moon
                ctx.fillStyle = palette.moon;
                ctx.shadowColor = palette.moonGlow;
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 22, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Sun with soft glow
                ctx.fillStyle = palette.sunGlow;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 50, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = palette.sun;
                ctx.shadowColor = palette.sun;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawHills(ctx, palette, time, timeOfDay) {
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;

            // Distant mountains - very faded silhouettes
            const mountainColor = isNight
                ? 'rgba(60, 55, 80, 0.4)'
                : lerpColor(palette.skyBottom, palette.groundFar, 0.3);
            drawMountainSilhouette(ctx, height * 0.55, mountainColor, 0.003, 60, time * 0.02, 0.35);
            drawMountainSilhouette(ctx, height * 0.60, lerpColor(mountainColor, palette.groundFar, 0.3), 0.004, 45, time * 0.03 + 1, 0.45);

            // Atmospheric haze layer behind far hills
            const hazeGradient = ctx.createLinearGradient(0, height * 0.5, 0, height * 0.75);
            hazeGradient.addColorStop(0, 'transparent');
            hazeGradient.addColorStop(1, isNight ? 'rgba(42, 36, 56, 0.3)' : 'rgba(200, 210, 220, 0.25)');
            ctx.fillStyle = hazeGradient;
            ctx.fillRect(0, height * 0.5, width, height * 0.25);

            // Far hills - most faded, slow parallax, gentle waves
            drawHillLayer(ctx, height * 0.68, palette.groundFar, 0.006, 30, time * 0.05, 0.7);

            // Mid-far hills
            const midFarColor = lerpColor(palette.groundFar, palette.groundMid, 0.5);
            drawHillLayer(ctx, height * 0.73, midFarColor, 0.009, 22, time * 0.08 + 0.5, 0.85);

            // Mid hills
            drawHillLayer(ctx, height * 0.78, palette.groundMid, 0.012, 18, time * 0.12 + 1.2, 0.92);

            // Near-mid hills
            const nearMidColor = lerpColor(palette.groundMid, palette.groundNear, 0.5);
            drawHillLayer(ctx, height * 0.82, nearMidColor, 0.014, 14, time * 0.16 + 2, 0.96);

            // Near ground - sharpest, fastest parallax
            drawHillLayer(ctx, height * 0.86, palette.groundNear, 0.018, 10, time * 0.2 + 2.8, 1);
        }

        function drawMountainSilhouette(ctx, baseY, color, freq, amplitude, offset, opacity) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            // Jagged mountain peaks with varying heights
            for (let x = 0; x <= width; x += 4) {
                const peakNoise = Math.sin(x * 0.02 + offset * 3) * 0.5 + 0.5;
                const y = baseY +
                    Math.sin(x * freq + offset) * amplitude * peakNoise +
                    Math.abs(Math.sin(x * freq * 3 + offset * 2)) * amplitude * 0.3;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawHillLayer(ctx, baseY, color, freq, amplitude, offset, opacity = 1) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            // More organic hill shape with multiple sine waves
            for (let x = 0; x <= width; x += 2) {
                const y = baseY +
                    Math.sin(x * freq + offset) * amplitude +
                    Math.sin(x * freq * 2.3 + offset * 1.5) * amplitude * 0.4 +
                    Math.sin(x * freq * 0.5 + offset * 0.7) * amplitude * 0.6;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════
        // GARDEN STATE & INITIALIZATION
        // ═══════════════════════════════════════════════════════════

        // This would come from your backend API
        const gardenState = {
            name: tg?.initDataUnsafe?.user?.first_name
                ? `${tg.initDataUnsafe.user.first_name}'s Garden`
                : 'Your Garden',
            growthLevel: 0.7,
            plants: [
                // Layer 0 (far) - smaller, more muted
                { x: 0.1, type: 'tree', growth: 0.8, layer: 0 },
                { x: 0.3, type: 'bush', growth: 0.7, layer: 0 },
                { x: 0.7, type: 'tree', growth: 0.6, layer: 0 },
                { x: 0.9, type: 'bush', growth: 0.8, layer: 0 },

                // Layer 1 (mid)
                { x: 0.15, type: 'fern', growth: 0.9, layer: 1 },
                { x: 0.25, type: 'lavender', growth: 0.8, layer: 1 },
                { x: 0.4, type: 'tulip', growth: 0.9, layer: 1 },
                { x: 0.55, type: 'wildflower', growth: 1, layer: 1 },
                { x: 0.65, type: 'lavender', growth: 0.85, layer: 1 },
                { x: 0.8, type: 'fern', growth: 0.7, layer: 1 },

                // Layer 2 (near) - larger, more vibrant
                { x: 0.08, type: 'grass', growth: 1, layer: 2 },
                { x: 0.2, type: 'wildflower', growth: 0.9, layer: 2 },
                { x: 0.32, type: 'grass', growth: 0.95, layer: 2 },
                { x: 0.45, type: 'tulip', growth: 1, layer: 2 },
                { x: 0.58, type: 'grass', growth: 0.9, layer: 2 },
                { x: 0.72, type: 'wildflower', growth: 0.85, layer: 2 },
                { x: 0.85, type: 'grass', growth: 1, layer: 2 },
                { x: 0.95, type: 'fern', growth: 0.8, layer: 2 },
            ]
        };

        let plants = [];
        let particles = [];
        let clouds = [];
        let butterflies = [];

        function initGarden() {
            const groundY = height * 0.85;

            // Create plants sorted by layer
            plants = gardenState.plants.map(p => {
                const layerGroundY = [height * 0.74, height * 0.80, height * 0.87][p.layer];
                return new Plant(p.x * width, layerGroundY, p.type, p.growth, p.layer);
            });

            // Sort by layer (far to near) then by y position
            plants.sort((a, b) => a.layer - b.layer || a.groundY - b.groundY);

            // Ambient particles
            particles = [];
            for (let i = 0; i < 25; i++) {
                particles.push(new AmbientParticle());
            }

            // Clouds
            clouds = [];
            for (let i = 0; i < 4; i++) {
                clouds.push(new Cloud(
                    Math.random() * width,
                    height * (0.08 + Math.random() * 0.15),
                    0.4 + Math.random() * 0.6
                ));
            }

            // Butterflies
            butterflies = [];
            for (let i = 0; i < 2; i++) {
                butterflies.push(new Butterfly());
            }

            // Update UI
            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            const hour = new Date().getHours();
            const statuses = {
                5: 'Waking gently with the dawn...',
                9: 'Basking in soft morning light...',
                12: 'Peaceful in the afternoon glow...',
                17: 'Settling into golden hour...',
                20: 'Resting under twilight skies...',
                23: 'Dreaming beneath the stars...'
            };

            let status = statuses[23];
            for (const [h, s] of Object.entries(statuses)) {
                if (hour >= parseInt(h)) status = s;
            }

            document.getElementById('garden-status').textContent = status;
        }

        // ═══════════════════════════════════════════════════════════
        // MAIN RENDER LOOP
        // ═══════════════════════════════════════════════════════════

        let lastStatusUpdate = 0;

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const palette = getPalette(timeOfDay);
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;

            // Clear
            ctx.clearRect(0, 0, width, height);

            // Sky
            drawSky(ctx, palette, time);

            // Celestial body (sun/moon)
            drawCelestial(ctx, palette, timeOfDay, time);

            // Clouds (daytime only)
            if (!isNight) {
                clouds.forEach(c => {
                    c.update(time);
                    c.draw(ctx, palette);
                });
            }

            // Hills (parallax ground layers with atmospheric depth)
            drawHills(ctx, palette, time, timeOfDay);

            // Plants by layer
            plants.forEach(p => p.draw(ctx, time, palette));

            // Butterflies (daytime)
            if (!isNight) {
                butterflies.forEach(b => {
                    b.update(time);
                    b.draw(ctx);
                });
            }

            // Ambient particles
            particles.forEach(p => {
                p.update(time, isNight);
                p.draw(ctx, isNight, palette);
            });

            // Update status periodically
            if (timestamp - lastStatusUpdate > 60000) {
                updateStatus();
                lastStatusUpdate = timestamp;
            }

            requestAnimationFrame(render);
        }

        // ═══════════════════════════════════════════════════════════
        // EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════

        window.addEventListener('resize', () => {
            resizeCanvas();
            initGarden();
        });

        // Initialize and start
        initGarden();
        requestAnimationFrame(render);
    </script>
</body>
</html>
