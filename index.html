<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hushful Garden</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            touch-action: none;
            font-family: 'Georgia', serif;
            background: #1a1a2e;
        }

        #garden-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Paper texture overlay - creates handcrafted feel */
        #paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 60;
            mix-blend-mode: overlay;
        }

        /* Warm vignette with color */
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(
                ellipse at 50% 60%,
                transparent 40%,
                rgba(60, 40, 30, 0.25) 100%
            );
            z-index: 55;
        }

        /* Subtle film grain overlay */
        #grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.035;
            z-index: 65;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='grain'%3E%3CfeTurbulence type='turbulence' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23grain)'/%3E%3C/svg%3E");
            animation: grainShift 0.5s steps(4) infinite;
        }

        @keyframes grainShift {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 1px); }
            50% { transform: translate(1px, -1px); }
            75% { transform: translate(-1px, -2px); }
            100% { transform: translate(0, 0); }
        }

        #info-panel {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 252, 245, 0.88);
            backdrop-filter: blur(16px);
            padding: 16px 32px;
            border-radius: 28px;
            box-shadow:
                0 6px 32px rgba(80, 60, 40, 0.18),
                0 2px 8px rgba(80, 60, 40, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.9),
                inset 0 -1px 0 rgba(200, 180, 160, 0.1);
            text-align: center;
            z-index: 100;
            border: 1px solid rgba(200, 180, 160, 0.15);
        }

        #garden-name {
            font-size: 18px;
            font-weight: 500;
            color: #4a3a2a;
            margin-bottom: 4px;
            letter-spacing: 0.4px;
        }

        #garden-status {
            font-size: 12px;
            color: #8a7a6a;
            font-style: italic;
            letter-spacing: 0.3px;
        }

        /* Plant tooltip */
        #plant-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(255, 252, 245, 0.94);
            backdrop-filter: blur(20px);
            padding: 24px 32px;
            border-radius: 24px;
            box-shadow:
                0 12px 48px rgba(80, 60, 40, 0.22),
                0 4px 12px rgba(80, 60, 40, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.95);
            text-align: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.35s ease, transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            max-width: 280px;
            border: 1px solid rgba(200, 180, 160, 0.12);
        }

        #plant-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1);
        }

        #tooltip-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        #tooltip-title {
            font-size: 17px;
            font-weight: 600;
            color: #3a2a1a;
            margin-bottom: 8px;
            letter-spacing: 0.4px;
        }

        #tooltip-message {
            font-size: 14px;
            color: #6a5a4a;
            line-height: 1.6;
            font-style: italic;
        }
    </style>
</head>
<body>
    <canvas id="garden-canvas"></canvas>
    <div id="paper-texture"></div>
    <div id="vignette"></div>
    <div id="grain"></div>

    <div id="info-panel">
        <div id="garden-name">Your Garden</div>
        <div id="garden-status">Growing peacefully...</div>
    </div>

    <div id="plant-tooltip">
        <div id="tooltip-icon"></div>
        <div id="tooltip-title"></div>
        <div id="tooltip-message"></div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // HUSHFUL GARDEN - Artisanal Watercolor Edition
        // "Each frame worthy of display" - inspired by Monument Valley
        // ═══════════════════════════════════════════════════════════════════

        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            document.body.style.background = tg.backgroundColor || '#1a1a2e';
        }

        // ═══════════════════════════════════════════════════════════════════
        // CANVAS SETUP
        // ═══════════════════════════════════════════════════════════════════

        const canvas = document.getElementById('garden-canvas');
        const ctx = canvas.getContext('2d');
        let width, height, dpr;

        function resizeCanvas() {
            dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap for performance
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        resizeCanvas();

        // ═══════════════════════════════════════════════════════════════════
        // CURATED COLOR PALETTES - Limited, intentional, warm
        // Inspired by GRIS: color as emotional storytelling
        // ═══════════════════════════════════════════════════════════════════

        const palettes = {
            dawn: {
                skyTop: '#bfa8c4',
                skyMid: '#e0c8b8',
                skyBottom: '#f0dcc8',
                sun: '#ffecd4',
                sunGlow: 'rgba(255, 230, 200, 0.5)',
                groundFar: '#98b090',
                groundMid: '#7a9870',
                groundNear: '#5c8058',
                accent: '#c8a0a0',
                warmth: 0.15
            },
            day: {
                skyTop: '#94b8c8',
                skyMid: '#c8dce4',
                skyBottom: '#e4eff4',
                sun: '#fff8e0',
                sunGlow: 'rgba(255, 250, 230, 0.6)',
                groundFar: '#88a880',
                groundMid: '#6c9064',
                groundNear: '#547850',
                accent: '#b8c8a8',
                warmth: 0
            },
            golden: {
                skyTop: '#c8b898',
                skyMid: '#e0d0a8',
                skyBottom: '#f0e4c0',
                sun: '#ffe0a0',
                sunGlow: 'rgba(255, 200, 120, 0.55)',
                groundFar: '#90a078',
                groundMid: '#788860',
                groundNear: '#586848',
                accent: '#d0c090',
                warmth: 0.25
            },
            dusk: {
                skyTop: '#786888',
                skyMid: '#b898a0',
                skyBottom: '#d8b8b0',
                sun: '#f0c8a8',
                sunGlow: 'rgba(240, 160, 120, 0.45)',
                groundFar: '#687860',
                groundMid: '#485840',
                groundNear: '#384830',
                accent: '#a88090',
                warmth: 0.2
            },
            night: {
                skyTop: '#1c1828',
                skyMid: '#282438',
                skyBottom: '#383450',
                moon: '#e0dce8',
                moonGlow: 'rgba(180, 170, 200, 0.35)',
                groundFar: '#283828',
                groundMid: '#182818',
                groundNear: '#0c180c',
                accent: '#584868',
                warmth: -0.1
            }
        };

        // Global warmth modifier - affects overall color temperature
        let globalWarmth = 0;

        function getTimeOfDay() {
            const now = new Date();
            return (now.getHours() + now.getMinutes() / 60) / 24;
        }

        function getPalette(t) {
            let palette;
            if (t < 0.22 || t > 0.88) palette = palettes.night;
            else if (t < 0.32) palette = lerpPalette(palettes.night, palettes.dawn, (t - 0.22) / 0.1);
            else if (t < 0.42) palette = lerpPalette(palettes.dawn, palettes.day, (t - 0.32) / 0.1);
            else if (t < 0.65) palette = palettes.day;
            else if (t < 0.72) palette = lerpPalette(palettes.day, palettes.golden, (t - 0.65) / 0.07);
            else if (t < 0.80) palette = lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.08);
            else palette = lerpPalette(palettes.dusk, palettes.night, (t - 0.80) / 0.08);

            globalWarmth = palette.warmth || 0;
            return palette;
        }

        function lerpPalette(a, b, t) {
            const result = {};
            for (const key of Object.keys(a)) {
                if (typeof a[key] === 'number') {
                    result[key] = a[key] + (b[key] - a[key]) * t;
                } else {
                    result[key] = lerpColor(a[key], b[key], t);
                }
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            if (!c1 || !c2 || c1.startsWith('rgba') || c2.startsWith('rgba')) return c1 || c2;
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        // Apply warmth tint to colors
        function applyWarmth(color, amount) {
            if (!color || color.startsWith('rgba')) return color;
            const r = parseInt(color.slice(1,3), 16);
            const g = parseInt(color.slice(3,5), 16);
            const b = parseInt(color.slice(5,7), 16);
            const warmR = Math.min(255, Math.max(0, r + amount * 30));
            const warmG = Math.min(255, Math.max(0, g + amount * 10));
            const warmB = Math.min(255, Math.max(0, b - amount * 15));
            return `rgb(${Math.round(warmR)}, ${Math.round(warmG)}, ${Math.round(warmB)})`;
        }

        // ═══════════════════════════════════════════════════════════════════
        // PROCEDURAL WOBBLE - Hand-drawn imperfection
        // Nothing perfectly straight - organic, alive
        // ═══════════════════════════════════════════════════════════════════

        // Seeded random for consistent wobble per-element
        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        // Add organic wobble to a path
        function wobbleLine(ctx, x1, y1, x2, y2, seed, intensity = 1) {
            const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
            const steps = Math.max(3, Math.floor(dist / 15));
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const x = x1 + (x2 - x1) * t;
                const y = y1 + (y2 - y1) * t;
                const wobbleX = (seededRandom(seed + i * 0.1) - 0.5) * 2 * intensity;
                const wobbleY = (seededRandom(seed + i * 0.2 + 100) - 0.5) * 2 * intensity;
                ctx.lineTo(x + wobbleX, y + wobbleY);
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // BREATHING ANIMATION - Everything gently pulses
        // Creates subconscious sense of life
        // ═══════════════════════════════════════════════════════════════════

        function getBreath(time, offset = 0, intensity = 0.015) {
            return 1 + Math.sin(time * 0.8 + offset) * intensity;
        }

        // ═══════════════════════════════════════════════════════════════════
        // SOFT GLOW EFFECT - Radial gradient bloom
        // ═══════════════════════════════════════════════════════════════════

        function drawGlow(ctx, x, y, radius, color, opacity = 0.3) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, color.replace(')', `, ${opacity})`).replace('rgb', 'rgba'));
            gradient.addColorStop(0.5, color.replace(')', `, ${opacity * 0.4})`).replace('rgb', 'rgba'));
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // ═══════════════════════════════════════════════════════════════════
        // AMBIENT PARTICLES - Pollen, dust motes, fireflies
        // ═══════════════════════════════════════════════════════════════════

        class AmbientParticle {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.size = 1 + Math.random() * 2;
                this.speedX = (Math.random() - 0.5) * 0.25;
                this.speedY = -0.08 - Math.random() * 0.15;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.wobbleSpeed = 0.4 + Math.random() * 0.4;
                this.opacity = 0.15 + Math.random() * 0.35;
                this.seed = Math.random() * 1000;
            }

            update(time, isNight) {
                this.x += this.speedX + Math.sin(time * this.wobbleSpeed + this.wobbleOffset) * 0.25;
                this.y += this.speedY;

                if (isNight) {
                    this.opacity = 0.25 + Math.sin(time * 2.5 + this.wobbleOffset) * 0.35;
                }

                if (this.y < -10 || this.x < -10 || this.x > width + 10) {
                    this.y = height + 10;
                    this.x = Math.random() * width;
                }
            }

            draw(ctx, isNight) {
                ctx.save();
                if (isNight) {
                    // Firefly with soft glow
                    drawGlow(ctx, this.x, this.y, this.size * 6, 'rgb(255, 255, 180)', this.opacity * 0.5);
                    ctx.fillStyle = `rgba(255, 255, 200, ${this.opacity})`;
                } else {
                    // Soft pollen mote
                    ctx.fillStyle = `rgba(255, 252, 235, ${this.opacity * 0.5})`;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // CLOUDS - Soft, painterly, breathing
        // ═══════════════════════════════════════════════════════════════════

        class Cloud {
            constructor(x, y, scale) {
                this.x = x;
                this.baseY = y;
                this.scale = scale;
                this.speed = 0.04 + Math.random() * 0.08;
                this.wobbleOffset = Math.random() * Math.PI * 2;
                this.opacity = 0.25 + Math.random() * 0.25;
                this.seed = Math.random() * 1000;
            }

            update(time) {
                this.x += this.speed;
                if (this.x > width + 250) this.x = -250;
                this.y = this.baseY + Math.sin(time * 0.15 + this.wobbleOffset) * 6;
                this.breathScale = getBreath(time, this.wobbleOffset, 0.02);
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.scale(this.breathScale, this.breathScale);

                const s = this.scale;
                const cloudParts = [
                    { x: 0, y: 0, rx: 32 * s, ry: 24 * s },
                    { x: 28 * s, y: -12 * s, rx: 38 * s, ry: 28 * s },
                    { x: 60 * s, y: -6 * s, rx: 30 * s, ry: 22 * s },
                    { x: 85 * s, y: 6 * s, rx: 24 * s, ry: 18 * s },
                    { x: 18 * s, y: 16 * s, rx: 22 * s, ry: 16 * s },
                    { x: 55 * s, y: 14 * s, rx: 28 * s, ry: 18 * s },
                ];

                // Soft white with slight color variation
                cloudParts.forEach((c, i) => {
                    const tint = i % 2 === 0 ? 255 : 250;
                    ctx.fillStyle = `rgb(${tint}, ${tint}, ${tint - 5})`;
                    ctx.beginPath();
                    ctx.ellipse(c.x, c.y, c.rx, c.ry, 0, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // PLANTS - Organic, breathing, hand-drawn feel
        // ═══════════════════════════════════════════════════════════════════

        class Plant {
            constructor(x, groundY, type, growth, layer) {
                this.x = x;
                this.groundY = groundY;
                this.type = type;
                this.growth = Math.max(0.1, growth);
                this.layer = layer;
                this.swayOffset = Math.random() * Math.PI * 2;
                this.swaySpeed = 0.35 + Math.random() * 0.25;
                this.swayAmount = 0.012 + Math.random() * 0.012;
                this.hueShift = (Math.random() - 0.5) * 12;
                this.seed = Math.random() * 10000;
                this.breathOffset = Math.random() * Math.PI * 2;
            }

            getLayerScale() {
                return [0.5, 0.75, 1][this.layer] || 1;
            }

            draw(ctx, time, palette) {
                const sway = Math.sin(time * this.swaySpeed + this.swayOffset) * this.swayAmount;
                const scale = this.getLayerScale();
                const breath = getBreath(time, this.breathOffset, 0.012);

                // Atmospheric perspective
                const layerOpacity = [0.65, 0.82, 1][this.layer] || 1;
                const layerDesaturation = [0.25, 0.1, 0][this.layer] || 0;

                ctx.save();
                ctx.globalAlpha = layerOpacity;
                ctx.translate(this.x, this.groundY);
                ctx.scale(scale * breath, scale * breath);

                switch(this.type) {
                    case 'wildflower': this.drawWildflower(ctx, sway, time, palette, layerDesaturation); break;
                    case 'tulip': this.drawTulip(ctx, sway, palette, layerDesaturation); break;
                    case 'lavender': this.drawLavender(ctx, sway, time, palette, layerDesaturation); break;
                    case 'grass': this.drawGrass(ctx, sway, palette, layerDesaturation); break;
                    case 'fern': this.drawFern(ctx, sway, palette, layerDesaturation); break;
                    case 'bush': this.drawBush(ctx, sway, time, palette, layerDesaturation); break;
                    case 'tree': this.drawTree(ctx, sway, time, palette, layerDesaturation); break;
                    default: this.drawGrass(ctx, sway, palette, layerDesaturation);
                }

                ctx.restore();
            }

            desaturate(hsl, amount) {
                return `hsl(${hsl.h}, ${Math.max(0, hsl.s - amount * 30)}%, ${hsl.l}%)`;
            }

            drawWildflower(ctx, sway, time, palette, desat) {
                const h = 50 + this.growth * 40;

                // Stem with wobble
                ctx.strokeStyle = applyWarmth(`hsl(${95 + this.hueShift}, ${32 - desat * 25}%, 38%)`, globalWarmth);
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(
                    sway * h * 22 + seededRandom(this.seed) * 3, -h * 0.3,
                    sway * h * 28 + seededRandom(this.seed + 1) * 3, -h * 0.65,
                    sway * h * 22, -h
                );
                ctx.stroke();

                // Flower
                const fx = sway * h * 22;
                const fy = -h;
                const petalSize = 6 + this.growth * 7;

                // Soft petals with variation
                const baseHue = 350 + this.hueShift;
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + time * 0.04 + seededRandom(this.seed + i) * 0.3;
                    const saturation = 35 - desat * 20 + seededRandom(this.seed + i + 10) * 10;
                    const lightness = 72 + seededRandom(this.seed + i + 20) * 8;
                    ctx.fillStyle = applyWarmth(`hsl(${baseHue + i * 5}, ${saturation}%, ${lightness}%)`, globalWarmth);
                    ctx.beginPath();
                    ctx.ellipse(
                        fx + Math.cos(angle) * petalSize * 0.4,
                        fy + Math.sin(angle) * petalSize * 0.4,
                        petalSize, petalSize * 0.55,
                        angle, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Glowing center
                drawGlow(ctx, fx, fy, petalSize * 0.8, 'rgb(255, 240, 180)', 0.3);
                ctx.fillStyle = applyWarmth('#f8e8b8', globalWarmth);
                ctx.beginPath();
                ctx.arc(fx, fy, petalSize * 0.32, 0, Math.PI * 2);
                ctx.fill();
            }

            drawTulip(ctx, sway, palette, desat) {
                const h = 45 + this.growth * 35;

                // Stem
                ctx.strokeStyle = applyWarmth(`hsl(${100 + this.hueShift}, ${30 - desat * 20}%, 35%)`, globalWarmth);
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(
                    sway * h * 18 + seededRandom(this.seed) * 2,
                    -h * 0.5,
                    sway * h * 12, -h + 10
                );
                ctx.stroke();

                const tx = sway * h * 12;
                const ty = -h + 10;
                const size = 10 + this.growth * 9;

                // Tulip petals with soft edges
                const baseHue = 355 + this.hueShift;

                // Back petals
                ctx.fillStyle = applyWarmth(`hsl(${baseHue}, ${40 - desat * 25}%, 62%)`, globalWarmth);
                ctx.beginPath();
                ctx.ellipse(tx - 4, ty - 6, size * 0.52, size * 0.95, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(tx + 4, ty - 6, size * 0.52, size * 0.95, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Front petal with highlight
                ctx.fillStyle = applyWarmth(`hsl(${baseHue + 5}, ${45 - desat * 25}%, 68%)`, globalWarmth);
                ctx.beginPath();
                ctx.ellipse(tx, ty - 4, size * 0.62, size * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Inner glow
                drawGlow(ctx, tx, ty - 8, size * 0.5, 'rgb(255, 220, 200)', 0.2);
            }

            drawLavender(ctx, sway, time, palette, desat) {
                const h = 55 + this.growth * 30;

                for (let s = -1; s <= 1; s++) {
                    const offsetX = s * 7;
                    const stemSway = sway + s * 0.008;

                    // Stem
                    ctx.strokeStyle = applyWarmth(`hsl(${105 + this.hueShift}, ${28 - desat * 20}%, 40%)`, globalWarmth);
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.bezierCurveTo(
                        offsetX + stemSway * h * 16, -h * 0.4,
                        offsetX + stemSway * h * 22, -h * 0.7,
                        offsetX + stemSway * h * 16, -h
                    );
                    ctx.stroke();

                    // Lavender buds
                    const budCount = 6 + Math.floor(this.growth * 5);
                    for (let i = 0; i < budCount; i++) {
                        const t = 0.35 + (i / budCount) * 0.65;
                        const bx = offsetX + stemSway * h * 16 * t;
                        const by = -h * t;
                        const budSize = 2.2 + (1 - t) * 2.2;

                        const hue = 268 + this.hueShift + seededRandom(this.seed + i) * 15;
                        const sat = 42 - desat * 25 + seededRandom(this.seed + i + 50) * 8;
                        const light = 58 + i * 2 + seededRandom(this.seed + i + 100) * 5;

                        ctx.fillStyle = applyWarmth(`hsl(${hue}, ${sat}%, ${light}%)`, globalWarmth);
                        ctx.beginPath();
                        ctx.ellipse(
                            bx + (seededRandom(this.seed + i * 2) - 0.5) * 3,
                            by,
                            budSize, budSize * 1.6, 0, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }

            drawGrass(ctx, sway, palette, desat) {
                const h = 25 + this.growth * 22;
                const blades = 5 + Math.floor(seededRandom(this.seed) * 3);

                for (let i = 0; i < blades; i++) {
                    const offsetX = (i - blades / 2) * 3.5;
                    const bladeH = h * (0.7 + seededRandom(this.seed + i) * 0.3);
                    const bladeSway = sway * (1 + i * 0.06);

                    const hue = 95 + this.hueShift + i * 3;
                    const sat = 32 - desat * 22;
                    const light = 32 + this.layer * 8 + seededRandom(this.seed + i + 20) * 6;

                    ctx.strokeStyle = applyWarmth(`hsl(${hue}, ${sat}%, ${light}%)`, globalWarmth);
                    ctx.lineWidth = 1.8;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(offsetX, 0);
                    ctx.quadraticCurveTo(
                        offsetX + bladeSway * bladeH * 32 + seededRandom(this.seed + i) * 2,
                        -bladeH * 0.6,
                        offsetX + bladeSway * bladeH * 28,
                        -bladeH
                    );
                    ctx.stroke();
                }
            }

            drawFern(ctx, sway, palette, desat) {
                const h = 40 + this.growth * 32;

                // Main stem
                ctx.strokeStyle = applyWarmth(`hsl(${100 + this.hueShift}, ${30 - desat * 20}%, 36%)`, globalWarmth);
                ctx.lineWidth = 2.2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(sway * h * 22, -h * 0.5, sway * h * 17, -h);
                ctx.stroke();

                // Fronds
                const frondCount = 8;
                for (let i = 0; i < frondCount; i++) {
                    const t = 0.18 + (i / frondCount) * 0.78;
                    const fx = sway * h * 22 * t;
                    const fy = -h * t;
                    const side = i % 2 === 0 ? -1 : 1;
                    const frondLen = 16 * (1 - t * 0.5) * this.growth;

                    const hue = 98 + this.hueShift + seededRandom(this.seed + i) * 8;
                    const sat = 32 - desat * 22;
                    const light = 38 + i * 2.5;

                    ctx.strokeStyle = applyWarmth(`hsl(${hue}, ${sat}%, ${light}%)`, globalWarmth);
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.quadraticCurveTo(
                        fx + side * frondLen * 0.72, fy - frondLen * 0.28,
                        fx + side * frondLen, fy - frondLen * 0.08
                    );
                    ctx.stroke();
                }
            }

            drawBush(ctx, sway, time, palette, desat) {
                const h = 50 + this.growth * 45;
                const w = h * 1.35;
                const breath = getBreath(time, this.breathOffset + 1, 0.008);

                // Layered foliage with soft edges
                const layers = [
                    { x: -w * 0.22, y: -h * 0.42, w: w * 0.52, h: h * 0.52, hue: 95 },
                    { x: w * 0.12, y: -h * 0.52, w: w * 0.58, h: h * 0.56, hue: 100 },
                    { x: -w * 0.12, y: -h * 0.62, w: w * 0.48, h: h * 0.48, hue: 105 },
                    { x: 0, y: -h * 0.38, w: w * 0.42, h: h * 0.42, hue: 98 },
                ];

                layers.forEach((l, i) => {
                    const sat = 28 - desat * 18;
                    const light = 30 + i * 5 + this.layer * 5;
                    ctx.fillStyle = applyWarmth(`hsl(${l.hue + this.hueShift}, ${sat}%, ${light}%)`, globalWarmth);
                    ctx.beginPath();
                    ctx.ellipse(
                        l.x + sway * h * 9 * (i + 1) * breath,
                        l.y,
                        l.w * breath, l.h * breath,
                        seededRandom(this.seed + i) * 0.15,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });

                // Subtle highlight
                drawGlow(ctx, 0, -h * 0.5, h * 0.3, 'rgb(200, 220, 180)', 0.08);
            }

            drawTree(ctx, sway, time, palette, desat) {
                const h = 100 + this.growth * 65;
                const breath = getBreath(time, this.breathOffset + 2, 0.006);

                // Trunk with organic shape
                ctx.fillStyle = applyWarmth('#4a3a2a', globalWarmth);
                ctx.beginPath();
                ctx.moveTo(-7, 0);
                ctx.bezierCurveTo(
                    -6 + seededRandom(this.seed) * 2, -h * 0.3,
                    -5 + seededRandom(this.seed + 1) * 2, -h * 0.5,
                    -3, -h * 0.62
                );
                ctx.lineTo(3, -h * 0.62);
                ctx.bezierCurveTo(
                    5 + seededRandom(this.seed + 2) * 2, -h * 0.5,
                    6 + seededRandom(this.seed + 3) * 2, -h * 0.3,
                    7, 0
                );
                ctx.closePath();
                ctx.fill();

                // Foliage masses
                const foliage = [
                    { x: 0, y: -h * 0.56, r: h * 0.36, hue: 95 },
                    { x: -h * 0.16, y: -h * 0.72, r: h * 0.30, hue: 100 },
                    { x: h * 0.13, y: -h * 0.74, r: h * 0.27, hue: 98 },
                    { x: 0, y: -h * 0.88, r: h * 0.23, hue: 105 },
                    { x: -h * 0.09, y: -h * 0.98, r: h * 0.16, hue: 102 },
                ];

                foliage.forEach((f, i) => {
                    const sat = 26 - desat * 18;
                    const light = 28 + i * 4 + this.layer * 5;
                    ctx.fillStyle = applyWarmth(`hsl(${f.hue + this.hueShift}, ${sat}%, ${light}%)`, globalWarmth);
                    ctx.beginPath();
                    ctx.ellipse(
                        f.x + sway * h * 3.5 * (i + 1) * breath,
                        f.y,
                        f.r * breath, f.r * 0.88 * breath,
                        seededRandom(this.seed + i + 10) * 0.1,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                });

                // Canopy glow
                drawGlow(ctx, 0, -h * 0.75, h * 0.35, 'rgb(180, 210, 160)', 0.06);
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // BUTTERFLY - Soft, dreamy visitor
        // ═══════════════════════════════════════════════════════════════════

        class Butterfly {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = height * 0.28 + Math.random() * height * 0.42;
                this.targetX = this.x;
                this.targetY = this.y;
                this.wingPhase = Math.random() * Math.PI * 2;
                this.hue = 275 + Math.random() * 65;
                this.size = 6 + Math.random() * 4;
                this.restTimer = 0;
                this.isResting = false;
                this.opacity = 0.85;
            }

            update(time) {
                this.wingPhase = time * 5.5;

                if (this.isResting) {
                    this.restTimer--;
                    if (this.restTimer <= 0) this.isResting = false;
                    return;
                }

                if (Math.random() < 0.002) {
                    this.isResting = true;
                    this.restTimer = 100 + Math.random() * 200;
                }

                if (Math.random() < 0.007) {
                    this.targetX = Math.random() * width;
                    this.targetY = height * 0.22 + Math.random() * height * 0.48;
                }

                this.x += (this.targetX - this.x) * 0.01 + Math.sin(time * 1.3) * 0.35;
                this.y += (this.targetY - this.y) * 0.01 + Math.cos(time * 1.1) * 0.28;
            }

            draw(ctx, time) {
                const wingAngle = this.isResting ? 0.1 : Math.sin(this.wingPhase) * 0.65;
                const breath = getBreath(time, this.wingPhase, 0.02);

                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.translate(this.x, this.y);
                ctx.scale(breath, breath);

                // Soft glow around butterfly
                drawGlow(ctx, 0, 0, this.size * 2.5, `hsl(${this.hue}, 50%, 75%)`, 0.15);

                // Body
                ctx.fillStyle = '#3a2a2a';
                ctx.beginPath();
                ctx.ellipse(0, 0, 1.5, this.size * 0.38, 0, 0, Math.PI * 2);
                ctx.fill();

                const wingColor = `hsla(${this.hue}, 55%, 68%, 0.85)`;
                const wingHighlight = `hsla(${this.hue + 20}, 60%, 78%, 0.65)`;

                // Left wings
                ctx.save();
                ctx.rotate(-wingAngle * 0.85);
                ctx.fillStyle = wingColor;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.52, -this.size * 0.15, this.size * 0.58, this.size * 0.38, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = wingHighlight;
                ctx.beginPath();
                ctx.ellipse(-this.size * 0.38, this.size * 0.15, this.size * 0.38, this.size * 0.27, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Right wings
                ctx.save();
                ctx.rotate(wingAngle * 0.85);
                ctx.fillStyle = wingColor;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.52, -this.size * 0.15, this.size * 0.58, this.size * 0.38, 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = wingHighlight;
                ctx.beginPath();
                ctx.ellipse(this.size * 0.38, this.size * 0.15, this.size * 0.38, this.size * 0.27, 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }
        }

        // ═══════════════════════════════════════════════════════════════════
        // SCENE RENDERING
        // ═══════════════════════════════════════════════════════════════════

        function drawSky(ctx, palette, time) {
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, applyWarmth(palette.skyTop, globalWarmth));
            gradient.addColorStop(0.45, applyWarmth(palette.skyMid, globalWarmth));
            gradient.addColorStop(1, applyWarmth(palette.skyBottom, globalWarmth));
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        }

        function drawCelestial(ctx, palette, timeOfDay, time) {
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;
            const celestialX = width * 0.72;
            const celestialY = height * 0.11;
            const breath = getBreath(time, 0, 0.008);

            ctx.save();

            if (isNight) {
                // Stars with twinkle
                for (let i = 0; i < 55; i++) {
                    const sx = (Math.sin(i * 73.156) * 0.5 + 0.5) * width;
                    const sy = (Math.cos(i * 127.84) * 0.5 + 0.5) * height * 0.5;
                    const twinkle = Math.sin(time * 1.8 + i * 0.6) * 0.35 + 0.45;
                    const starSize = 0.5 + seededRandom(i * 123) * 1.2;

                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, starSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Moon with soft glow
                drawGlow(ctx, celestialX, celestialY, 55 * breath, 'rgb(200, 195, 220)', 0.25);
                ctx.fillStyle = palette.moon;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 22 * breath, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Sun with bloom
                drawGlow(ctx, celestialX, celestialY, 85 * breath, 'rgb(255, 240, 200)', 0.35);
                drawGlow(ctx, celestialX, celestialY, 55 * breath, 'rgb(255, 250, 220)', 0.45);
                ctx.fillStyle = palette.sun;
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 26 * breath, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawHills(ctx, palette, time, timeOfDay) {
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;

            // Distant mountains
            const mountainColor = isNight
                ? 'rgba(50, 45, 70, 0.45)'
                : applyWarmth(lerpColor(palette.skyBottom, palette.groundFar, 0.32), globalWarmth);
            drawMountainSilhouette(ctx, height * 0.54, mountainColor, 0.003, 65, time * 0.018, 0.32);
            drawMountainSilhouette(ctx, height * 0.59, lerpColor(mountainColor, palette.groundFar, 0.35), 0.004, 48, time * 0.025 + 1, 0.42);

            // Atmospheric haze
            const hazeGradient = ctx.createLinearGradient(0, height * 0.48, 0, height * 0.76);
            hazeGradient.addColorStop(0, 'transparent');
            hazeGradient.addColorStop(1, isNight ? 'rgba(35, 30, 50, 0.32)' : `rgba(200, 210, 220, ${0.22 + globalWarmth * 0.1})`);
            ctx.fillStyle = hazeGradient;
            ctx.fillRect(0, height * 0.48, width, height * 0.28);

            // Rolling hills with depth
            drawHillLayer(ctx, height * 0.67, applyWarmth(palette.groundFar, globalWarmth), 0.006, 32, time * 0.045, 0.68);
            drawHillLayer(ctx, height * 0.72, applyWarmth(lerpColor(palette.groundFar, palette.groundMid, 0.5), globalWarmth), 0.009, 24, time * 0.07 + 0.5, 0.82);
            drawHillLayer(ctx, height * 0.77, applyWarmth(palette.groundMid, globalWarmth), 0.012, 19, time * 0.1 + 1.2, 0.9);
            drawHillLayer(ctx, height * 0.82, applyWarmth(lerpColor(palette.groundMid, palette.groundNear, 0.5), globalWarmth), 0.015, 15, time * 0.14 + 2, 0.95);
            drawHillLayer(ctx, height * 0.87, applyWarmth(palette.groundNear, globalWarmth), 0.019, 11, time * 0.18 + 2.8, 1);
        }

        function drawMountainSilhouette(ctx, baseY, color, freq, amplitude, offset, opacity) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            for (let x = 0; x <= width; x += 4) {
                const peakNoise = Math.sin(x * 0.02 + offset * 3) * 0.5 + 0.5;
                const wobble = seededRandom(x * 0.1 + offset) * 3;
                const y = baseY +
                    Math.sin(x * freq + offset) * amplitude * peakNoise +
                    Math.abs(Math.sin(x * freq * 3 + offset * 2)) * amplitude * 0.32 +
                    wobble;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawHillLayer(ctx, baseY, color, freq, amplitude, offset, opacity = 1) {
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);

            for (let x = 0; x <= width; x += 2) {
                const wobble = seededRandom(x * 0.05 + offset * 10) * 1.5;
                const y = baseY +
                    Math.sin(x * freq + offset) * amplitude +
                    Math.sin(x * freq * 2.3 + offset * 1.5) * amplitude * 0.42 +
                    Math.sin(x * freq * 0.5 + offset * 0.7) * amplitude * 0.58 +
                    wobble;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ═══════════════════════════════════════════════════════════════════
        // GARDEN STATE & INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════

        const API_BASE = 'https://hushful-telegram-bot.onrender.com';

        let gardenState = {
            name: tg?.initDataUnsafe?.user?.first_name
                ? `${tg.initDataUnsafe.user.first_name}'s Garden`
                : 'Your Garden',
            health: 0.5,
            status: 'Growing peacefully...',
            plants: [
                { x: 0.3, type: 'bush', growth: 0.5, layer: 0 },
                { x: 0.5, type: 'fern', growth: 0.5, layer: 1 },
                { x: 0.08, type: 'grass', growth: 0.5, layer: 2 },
                { x: 0.58, type: 'grass', growth: 0.5, layer: 2 },
                { x: 0.85, type: 'grass', growth: 0.5, layer: 2 },
            ]
        };

        async function fetchGardenState() {
            const userId = tg?.initDataUnsafe?.user?.id;
            if (!userId) return;

            try {
                const response = await fetch(`${API_BASE}/api/garden/${userId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (!data.error && data.plants) {
                        gardenState = data;
                        initGarden();
                    }
                }
            } catch (error) {
                console.log('Using default garden');
            }
        }

        let plants = [];
        let particles = [];
        let clouds = [];
        let butterflies = [];

        function initGarden() {
            plants = gardenState.plants.map(p => {
                const layerGroundY = [height * 0.73, height * 0.79, height * 0.87][p.layer];
                return new Plant(p.x * width, layerGroundY, p.type, p.growth, p.layer);
            });
            plants.sort((a, b) => a.layer - b.layer || a.groundY - b.groundY);

            particles = [];
            for (let i = 0; i < 22; i++) {
                particles.push(new AmbientParticle());
            }

            clouds = [];
            for (let i = 0; i < 4; i++) {
                clouds.push(new Cloud(
                    Math.random() * width,
                    height * (0.07 + Math.random() * 0.14),
                    0.4 + Math.random() * 0.6
                ));
            }

            butterflies = [];
            for (let i = 0; i < 2; i++) {
                butterflies.push(new Butterfly());
            }

            document.getElementById('garden-name').textContent = gardenState.name;
            updateStatus();
        }

        function updateStatus() {
            if (gardenState.status) {
                document.getElementById('garden-status').textContent = gardenState.status;
                return;
            }

            const hour = new Date().getHours();
            const statuses = {
                5: 'Waking gently with the dawn...',
                9: 'Basking in soft morning light...',
                12: 'Peaceful in the afternoon glow...',
                17: 'Settling into golden hour...',
                20: 'Resting under twilight skies...',
                23: 'Dreaming beneath the stars...'
            };

            let status = statuses[23];
            for (const [h, s] of Object.entries(statuses)) {
                if (hour >= parseInt(h)) status = s;
            }
            document.getElementById('garden-status').textContent = status;
        }

        // ═══════════════════════════════════════════════════════════════════
        // MAIN RENDER LOOP
        // ═══════════════════════════════════════════════════════════════════

        let lastStatusUpdate = 0;

        function render(timestamp) {
            const time = timestamp * 0.001;
            const timeOfDay = getTimeOfDay();
            const palette = getPalette(timeOfDay);
            const isNight = timeOfDay < 0.25 || timeOfDay > 0.8;

            ctx.clearRect(0, 0, width, height);

            drawSky(ctx, palette, time);
            drawCelestial(ctx, palette, timeOfDay, time);

            if (!isNight) {
                clouds.forEach(c => {
                    c.update(time);
                    c.draw(ctx);
                });
            }

            drawHills(ctx, palette, time, timeOfDay);
            plants.forEach(p => p.draw(ctx, time, palette));

            if (!isNight) {
                butterflies.forEach(b => {
                    b.update(time);
                    b.draw(ctx, time);
                });
            }

            particles.forEach(p => {
                p.update(time, isNight);
                p.draw(ctx, isNight);
            });

            if (timestamp - lastStatusUpdate > 60000) {
                updateStatus();
                lastStatusUpdate = timestamp;
            }

            requestAnimationFrame(render);
        }

        // ═══════════════════════════════════════════════════════════════════
        // PLANT STORIES
        // ═══════════════════════════════════════════════════════════════════

        const plantStories = {
            tree: {
                icon: '🌳',
                title: 'Steady Oak',
                messages: [
                    'Rooted in your glucose stability.',
                    'Each steady day helps me grow stronger.',
                    'I thrive when your energy stays balanced.'
                ]
            },
            bush: {
                icon: '🌿',
                title: 'Engagement Shrub',
                messages: [
                    'I grow fuller with each visit.',
                    'Your presence nurtures me.',
                    'Every check-in helps me flourish.'
                ]
            },
            lavender: {
                icon: '💜',
                title: 'Ketone Lavender',
                messages: [
                    'I bloom with your metabolic ketones.',
                    'Your fat-burning fuels my fragrance.',
                    'In ketosis, I flourish beautifully.'
                ]
            },
            tulip: {
                icon: '🌷',
                title: 'Food Log Tulip',
                messages: [
                    'Each meal you log helps me bloom.',
                    'I open wider with your food photos.',
                    'Your mindful eating makes me vibrant.'
                ]
            },
            wildflower: {
                icon: '🌸',
                title: 'Wellness Wildflower',
                messages: [
                    'I dance with your metabolic health.',
                    'When you thrive, I blossom freely.',
                    'Your journey makes me beautiful.'
                ]
            },
            fern: {
                icon: '🌿',
                title: 'Background Fern',
                messages: [
                    'I provide quiet support always.',
                    'Steady and patient, I watch you grow.',
                    'Even small steps help me unfurl.'
                ]
            },
            grass: {
                icon: '🌱',
                title: 'Foundation Grass',
                messages: [
                    'The foundation of your garden.',
                    "I'm always here, rooting for you.",
                    'Simple and steady, day by day.'
                ]
            }
        };

        const tooltip = document.getElementById('plant-tooltip');
        const tooltipIcon = document.getElementById('tooltip-icon');
        const tooltipTitle = document.getElementById('tooltip-title');
        const tooltipMessage = document.getElementById('tooltip-message');
        let tooltipTimeout = null;

        function showPlantTooltip(plant) {
            const story = plantStories[plant.type] || plantStories.grass;
            const randomMessage = story.messages[Math.floor(Math.random() * story.messages.length)];

            tooltipIcon.textContent = story.icon;
            tooltipTitle.textContent = story.title;
            tooltipMessage.textContent = randomMessage;
            tooltip.classList.add('visible');

            if (tg?.HapticFeedback) {
                tg.HapticFeedback.impactOccurred('light');
            }

            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(hideTooltip, 3500);
        }

        function hideTooltip() {
            tooltip.classList.remove('visible');
        }

        function findPlantAtPosition(x, y) {
            for (let i = plants.length - 1; i >= 0; i--) {
                const plant = plants[i];
                const scale = plant.getLayerScale();
                const hitRadius = 45 * scale;
                const plantCenterY = plant.groundY - 35 * scale;
                const dx = x - plant.x;
                const dy = y - plantCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hitRadius) return plant;
            }
            return null;
        }

        // ═══════════════════════════════════════════════════════════════════
        // EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════════════

        window.addEventListener('resize', () => {
            resizeCanvas();
            initGarden();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const plant = findPlantAtPosition(x, y);
            if (plant) showPlantTooltip(plant);
            else hideTooltip();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const plant = findPlantAtPosition(x, y);
            if (plant) showPlantTooltip(plant);
        }, { passive: false });

        tooltip.addEventListener('click', hideTooltip);

        // Initialize and start
        initGarden();
        requestAnimationFrame(render);
        fetchGardenState();
        setInterval(fetchGardenState, 5 * 60 * 1000);
    </script>
</body>
</html>
