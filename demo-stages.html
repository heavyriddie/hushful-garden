<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hushful Garden - Stage Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #1a1a2e;
            color: #f0e8d8;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #d4c4a8;
            margin-bottom: 10px;
            font-weight: 400;
        }

        .subtitle {
            text-align: center;
            color: #8a7a6a;
            margin-bottom: 30px;
            font-style: italic;
        }

        .stages {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .stage {
            background: rgba(40, 35, 50, 0.6);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(100, 90, 80, 0.2);
        }

        .stage-header {
            padding: 16px 20px;
            background: rgba(60, 50, 70, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stage-title {
            font-size: 18px;
            color: #e0d0c0;
        }

        .stage-number {
            background: rgba(200, 180, 150, 0.15);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            color: #c8b898;
        }

        .stage-metrics {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .metric {
            font-size: 11px;
            color: #9a8a7a;
        }

        .metric span {
            color: #c8b898;
        }

        .canvas-container {
            position: relative;
            height: 280px;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .stage-description {
            padding: 16px 20px;
            background: rgba(50, 45, 60, 0.3);
            font-size: 13px;
            color: #a09080;
            line-height: 1.6;
        }

        .stage-description strong {
            color: #c8b898;
        }

        .controls {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls button {
            background: rgba(200, 180, 150, 0.15);
            border: 1px solid rgba(200, 180, 150, 0.3);
            color: #d4c4a8;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            margin: 0 5px;
            transition: all 0.2s;
        }

        .controls button:hover {
            background: rgba(200, 180, 150, 0.25);
        }

        .controls button.active {
            background: rgba(200, 180, 150, 0.3);
            border-color: rgba(200, 180, 150, 0.5);
        }

        @media (max-width: 600px) {
            .stage-header {
                flex-direction: column;
                align-items: flex-start;
            }
            .canvas-container {
                height: 220px;
            }
        }
    </style>
</head>
<body>
    <h1>Hushful Garden Stages</h1>
    <p class="subtitle">How the garden evolves based on user metabolic data and engagement</p>

    <div class="controls">
        <button onclick="setTimeOfDay(0.35)" class="active">Dawn</button>
        <button onclick="setTimeOfDay(0.5)">Day</button>
        <button onclick="setTimeOfDay(0.7)">Golden</button>
        <button onclick="setTimeOfDay(0.78)">Dusk</button>
        <button onclick="setTimeOfDay(0.1)">Night</button>
    </div>

    <div class="stages" id="stages"></div>

    <script>
        // ═══════════════════════════════════════════════════════════════════
        // GARDEN STAGES CONFIGURATION
        // ═══════════════════════════════════════════════════════════════════

        const stages = [
            {
                title: "1. New User - Just Started",
                description: "<strong>Just onboarded:</strong> Basic grass foundation only. The garden awaits nurturing through engagement, food logging, and connecting health devices.",
                health: 0.15,
                metrics: { engagement: 0.05, food: 0.0, ketone: 0.0, glucose: 0.5 },
                plants: [
                    { x: 0.15, type: 'grass', growth: 0.4, layer: 2 },
                    { x: 0.4, type: 'grass', growth: 0.35, layer: 2 },
                    { x: 0.65, type: 'grass', growth: 0.4, layer: 2 },
                    { x: 0.85, type: 'grass', growth: 0.3, layer: 2 },
                ]
            },
            {
                title: "2. Early Engagement - First Week",
                description: "<strong>Starting to engage:</strong> A few check-ins, maybe uploaded first food photo. Small bush emerging, ferns appearing. Garden starting to take shape.",
                health: 0.35,
                metrics: { engagement: 0.25, food: 0.2, ketone: 0.0, glucose: 0.5 },
                plants: [
                    { x: 0.3, type: 'bush', growth: 0.35, layer: 0 },
                    { x: 0.5, type: 'fern', growth: 0.4, layer: 1 },
                    { x: 0.7, type: 'fern', growth: 0.3, layer: 1 },
                    { x: 0.1, type: 'grass', growth: 0.5, layer: 2 },
                    { x: 0.4, type: 'grass', growth: 0.5, layer: 2 },
                    { x: 0.6, type: 'grass', growth: 0.5, layer: 2 },
                    { x: 0.9, type: 'grass', growth: 0.45, layer: 2 },
                ]
            },
            {
                title: "3. Active User - Logging Food",
                description: "<strong>Regular food logging:</strong> Tulips blooming from meal photos. Bushes growing fuller. First wildflowers appearing. Connected CGM shows stable glucose = healthy tree.",
                health: 0.55,
                metrics: { engagement: 0.45, food: 0.5, ketone: 0.0, glucose: 0.6 },
                plants: [
                    { x: 0.15, type: 'tree', growth: 0.5, layer: 0 },
                    { x: 0.5, type: 'bush', growth: 0.55, layer: 0 },
                    { x: 0.8, type: 'bush', growth: 0.45, layer: 0 },
                    { x: 0.3, type: 'tulip', growth: 0.55, layer: 1 },
                    { x: 0.55, type: 'tulip', growth: 0.45, layer: 1 },
                    { x: 0.7, type: 'fern', growth: 0.5, layer: 1 },
                    { x: 0.2, type: 'wildflower', growth: 0.4, layer: 1 },
                    { x: 0.08, type: 'grass', growth: 0.6, layer: 2 },
                    { x: 0.4, type: 'grass', growth: 0.6, layer: 2 },
                    { x: 0.65, type: 'grass', growth: 0.55, layer: 2 },
                    { x: 0.9, type: 'grass', growth: 0.6, layer: 2 },
                ]
            },
            {
                title: "4. Thriving - Ketones + CGM Active",
                description: "<strong>Full metabolic tracking:</strong> Ketone data triggers lavender blooms. Stable glucose grows strong trees. Tulips flourish from consistent food logging. Wildflowers dance everywhere.",
                health: 0.75,
                metrics: { engagement: 0.7, food: 0.65, ketone: 0.6, glucose: 0.75 },
                plants: [
                    { x: 0.1, type: 'tree', growth: 0.75, layer: 0 },
                    { x: 0.7, type: 'tree', growth: 0.65, layer: 0 },
                    { x: 0.35, type: 'bush', growth: 0.7, layer: 0 },
                    { x: 0.85, type: 'bush', growth: 0.6, layer: 0 },
                    { x: 0.25, type: 'lavender', growth: 0.65, layer: 1 },
                    { x: 0.6, type: 'lavender', growth: 0.55, layer: 1 },
                    { x: 0.4, type: 'tulip', growth: 0.7, layer: 1 },
                    { x: 0.75, type: 'tulip', growth: 0.6, layer: 1 },
                    { x: 0.5, type: 'fern', growth: 0.65, layer: 1 },
                    { x: 0.15, type: 'wildflower', growth: 0.6, layer: 1 },
                    { x: 0.8, type: 'wildflower', growth: 0.55, layer: 1 },
                    { x: 0.08, type: 'grass', growth: 0.7, layer: 2 },
                    { x: 0.32, type: 'grass', growth: 0.7, layer: 2 },
                    { x: 0.58, type: 'grass', growth: 0.65, layer: 2 },
                    { x: 0.85, type: 'grass', growth: 0.7, layer: 2 },
                    { x: 0.2, type: 'wildflower', growth: 0.6, layer: 2 },
                    { x: 0.72, type: 'wildflower', growth: 0.55, layer: 2 },
                ]
            },
            {
                title: "5. Flourishing - Optimal Metabolic Health",
                description: "<strong>Peak garden state:</strong> Deep ketosis blooms abundant lavender and wildflowers. Rock-solid glucose stability = majestic trees. Consistent logging = vibrant tulips. The garden radiates wellness.",
                health: 0.92,
                metrics: { engagement: 0.9, food: 0.85, ketone: 0.85, glucose: 0.9 },
                plants: [
                    { x: 0.08, type: 'tree', growth: 0.95, layer: 0 },
                    { x: 0.65, type: 'tree', growth: 0.88, layer: 0 },
                    { x: 0.35, type: 'bush', growth: 0.9, layer: 0 },
                    { x: 0.85, type: 'bush', growth: 0.85, layer: 0 },
                    { x: 0.5, type: 'bush', growth: 0.75, layer: 0 },
                    { x: 0.2, type: 'lavender', growth: 0.9, layer: 1 },
                    { x: 0.55, type: 'lavender', growth: 0.85, layer: 1 },
                    { x: 0.78, type: 'lavender', growth: 0.8, layer: 1 },
                    { x: 0.35, type: 'tulip', growth: 0.9, layer: 1 },
                    { x: 0.6, type: 'tulip', growth: 0.85, layer: 1 },
                    { x: 0.45, type: 'fern', growth: 0.85, layer: 1 },
                    { x: 0.9, type: 'fern', growth: 0.75, layer: 1 },
                    { x: 0.12, type: 'wildflower', growth: 0.85, layer: 1 },
                    { x: 0.7, type: 'wildflower', growth: 0.8, layer: 1 },
                    { x: 0.28, type: 'wildflower', growth: 0.75, layer: 1 },
                    { x: 0.05, type: 'grass', growth: 0.9, layer: 2 },
                    { x: 0.25, type: 'grass', growth: 0.9, layer: 2 },
                    { x: 0.48, type: 'grass', growth: 0.85, layer: 2 },
                    { x: 0.72, type: 'grass', growth: 0.9, layer: 2 },
                    { x: 0.92, type: 'grass', growth: 0.85, layer: 2 },
                    { x: 0.15, type: 'wildflower', growth: 0.85, layer: 2 },
                    { x: 0.4, type: 'wildflower', growth: 0.8, layer: 2 },
                    { x: 0.62, type: 'wildflower', growth: 0.82, layer: 2 },
                    { x: 0.82, type: 'wildflower', growth: 0.78, layer: 2 },
                ]
            }
        ];

        // ═══════════════════════════════════════════════════════════════════
        // RENDERING ENGINE (simplified from main garden)
        // ═══════════════════════════════════════════════════════════════════

        let currentTimeOfDay = 0.35; // Dawn default

        const palettes = {
            dawn: { skyTop: '#bfa8c4', skyMid: '#e0c8b8', skyBottom: '#f0dcc8', sun: '#ffecd4', groundFar: '#98b090', groundMid: '#7a9870', groundNear: '#5c8058', warmth: 0.15 },
            day: { skyTop: '#94b8c8', skyMid: '#c8dce4', skyBottom: '#e4eff4', sun: '#fff8e0', groundFar: '#88a880', groundMid: '#6c9064', groundNear: '#547850', warmth: 0 },
            golden: { skyTop: '#c8b898', skyMid: '#e0d0a8', skyBottom: '#f0e4c0', sun: '#ffe0a0', groundFar: '#90a078', groundMid: '#788860', groundNear: '#586848', warmth: 0.25 },
            dusk: { skyTop: '#786888', skyMid: '#b898a0', skyBottom: '#d8b8b0', sun: '#f0c8a8', groundFar: '#687860', groundMid: '#485840', groundNear: '#384830', warmth: 0.2 },
            night: { skyTop: '#1c1828', skyMid: '#282438', skyBottom: '#383450', moon: '#e0dce8', groundFar: '#283828', groundMid: '#182818', groundNear: '#0c180c', warmth: -0.1 }
        };

        function getPalette(t) {
            if (t < 0.22 || t > 0.88) return palettes.night;
            if (t < 0.32) return lerpPalette(palettes.night, palettes.dawn, (t - 0.22) / 0.1);
            if (t < 0.42) return lerpPalette(palettes.dawn, palettes.day, (t - 0.32) / 0.1);
            if (t < 0.65) return palettes.day;
            if (t < 0.72) return lerpPalette(palettes.day, palettes.golden, (t - 0.65) / 0.07);
            if (t < 0.80) return lerpPalette(palettes.golden, palettes.dusk, (t - 0.72) / 0.08);
            return lerpPalette(palettes.dusk, palettes.night, (t - 0.80) / 0.08);
        }

        function lerpPalette(a, b, t) {
            const result = {};
            for (const key of Object.keys(a)) {
                if (typeof a[key] === 'number') result[key] = a[key] + (b[key] - a[key]) * t;
                else result[key] = lerpColor(a[key], b[key], t);
            }
            return result;
        }

        function lerpColor(c1, c2, t) {
            if (!c1 || !c2 || c1.startsWith('rgba') || c2.startsWith('rgba')) return c1 || c2;
            const r1 = parseInt(c1.slice(1,3), 16), g1 = parseInt(c1.slice(3,5), 16), b1 = parseInt(c1.slice(5,7), 16);
            const r2 = parseInt(c2.slice(1,3), 16), g2 = parseInt(c2.slice(3,5), 16), b2 = parseInt(c2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * t), g = Math.round(g1 + (g2 - g1) * t), b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        function applyWarmth(color, amount) {
            if (!color || color.startsWith('rgba')) return color;
            const r = parseInt(color.slice(1,3), 16);
            const g = parseInt(color.slice(3,5), 16);
            const b = parseInt(color.slice(5,7), 16);
            const warmR = Math.min(255, Math.max(0, r + amount * 30));
            const warmG = Math.min(255, Math.max(0, g + amount * 10));
            const warmB = Math.min(255, Math.max(0, b - amount * 15));
            return `rgb(${Math.round(warmR)}, ${Math.round(warmG)}, ${Math.round(warmB)})`;
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 127.1 + seed * 311.7) * 43758.5453;
            return x - Math.floor(x);
        }

        function drawGlow(ctx, x, y, radius, color, opacity = 0.3) {
            try {
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                let c = color;
                if (c.startsWith('rgb(')) {
                    c = c.replace('rgb(', 'rgba(').replace(')', `, ${opacity})`);
                } else {
                    c = `rgba(255, 255, 200, ${opacity})`;
                }
                gradient.addColorStop(0, c);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            } catch (e) {}
        }

        // ═══════════════════════════════════════════════════════════════════
        // PLANT DRAWING
        // ═══════════════════════════════════════════════════════════════════

        function drawPlant(ctx, plant, width, height, time, palette) {
            const layerGroundY = [height * 0.73, height * 0.79, height * 0.87][plant.layer];
            const x = plant.x * width;
            const growth = plant.growth;
            const scale = [0.5, 0.75, 1][plant.layer];
            const sway = Math.sin(time * 0.5 + plant.x * 10) * 0.01;
            const warmth = palette.warmth || 0;
            const seed = plant.x * 1000;

            ctx.save();
            ctx.globalAlpha = [0.65, 0.82, 1][plant.layer];
            ctx.translate(x, layerGroundY);
            ctx.scale(scale, scale);

            switch (plant.type) {
                case 'grass': drawGrass(ctx, sway, growth, warmth, seed); break;
                case 'fern': drawFern(ctx, sway, growth, warmth, seed); break;
                case 'wildflower': drawWildflower(ctx, sway, growth, warmth, seed, time); break;
                case 'tulip': drawTulip(ctx, sway, growth, warmth, seed); break;
                case 'lavender': drawLavender(ctx, sway, growth, warmth, seed); break;
                case 'bush': drawBush(ctx, sway, growth, warmth, seed); break;
                case 'tree': drawTree(ctx, sway, growth, warmth, seed); break;
            }

            ctx.restore();
        }

        function drawGrass(ctx, sway, growth, warmth, seed) {
            const h = 25 + growth * 22;
            for (let i = 0; i < 5; i++) {
                const offsetX = (i - 2) * 3.5;
                const bladeH = h * (0.7 + seededRandom(seed + i) * 0.3);
                ctx.strokeStyle = applyWarmth(`hsl(${95 + i * 3}, 32%, ${32 + seededRandom(seed + i) * 6}%)`, warmth);
                ctx.lineWidth = 1.8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(offsetX, 0);
                ctx.quadraticCurveTo(offsetX + sway * bladeH * 30, -bladeH * 0.6, offsetX + sway * bladeH * 28, -bladeH);
                ctx.stroke();
            }
        }

        function drawFern(ctx, sway, growth, warmth, seed) {
            const h = 40 + growth * 32;
            ctx.strokeStyle = applyWarmth(`hsl(100, 30%, 36%)`, warmth);
            ctx.lineWidth = 2.2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(sway * h * 22, -h * 0.5, sway * h * 17, -h);
            ctx.stroke();

            for (let i = 0; i < 8; i++) {
                const t = 0.18 + (i / 8) * 0.78;
                const fx = sway * h * 22 * t;
                const fy = -h * t;
                const side = i % 2 === 0 ? -1 : 1;
                const frondLen = 16 * (1 - t * 0.5) * growth;
                ctx.strokeStyle = applyWarmth(`hsl(${98 + seededRandom(seed + i) * 8}, 32%, ${38 + i * 2.5}%)`, warmth);
                ctx.lineWidth = 1.2;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.quadraticCurveTo(fx + side * frondLen * 0.72, fy - frondLen * 0.28, fx + side * frondLen, fy - frondLen * 0.08);
                ctx.stroke();
            }
        }

        function drawWildflower(ctx, sway, growth, warmth, seed, time) {
            const h = 50 + growth * 40;
            ctx.strokeStyle = applyWarmth(`hsl(95, 32%, 38%)`, warmth);
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(sway * h * 22, -h * 0.3, sway * h * 28, -h * 0.65, sway * h * 22, -h);
            ctx.stroke();

            const fx = sway * h * 22;
            const fy = -h;
            const petalSize = 6 + growth * 7;
            const baseHue = 350 + seed * 0.05;

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 + time * 0.04;
                ctx.fillStyle = applyWarmth(`hsl(${baseHue + i * 5}, 35%, ${72 + seededRandom(seed + i) * 8}%)`, warmth);
                ctx.beginPath();
                ctx.ellipse(fx + Math.cos(angle) * petalSize * 0.4, fy + Math.sin(angle) * petalSize * 0.4, petalSize, petalSize * 0.55, angle, 0, Math.PI * 2);
                ctx.fill();
            }

            drawGlow(ctx, fx, fy, petalSize * 0.8, 'rgb(255, 240, 180)', 0.3);
            ctx.fillStyle = applyWarmth('#f8e8b8', warmth);
            ctx.beginPath();
            ctx.arc(fx, fy, petalSize * 0.32, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTulip(ctx, sway, growth, warmth, seed) {
            const h = 45 + growth * 35;
            ctx.strokeStyle = applyWarmth(`hsl(100, 30%, 35%)`, warmth);
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(sway * h * 18, -h * 0.5, sway * h * 12, -h + 10);
            ctx.stroke();

            const tx = sway * h * 12;
            const ty = -h + 10;
            const size = 10 + growth * 9;
            const baseHue = 355 + seed * 0.02;

            ctx.fillStyle = applyWarmth(`hsl(${baseHue}, 40%, 62%)`, warmth);
            ctx.beginPath();
            ctx.ellipse(tx - 4, ty - 6, size * 0.52, size * 0.95, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(tx + 4, ty - 6, size * 0.52, size * 0.95, 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = applyWarmth(`hsl(${baseHue + 5}, 45%, 68%)`, warmth);
            ctx.beginPath();
            ctx.ellipse(tx, ty - 4, size * 0.62, size * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawLavender(ctx, sway, growth, warmth, seed) {
            const h = 55 + growth * 30;
            for (let s = -1; s <= 1; s++) {
                const offsetX = s * 7;
                ctx.strokeStyle = applyWarmth(`hsl(105, 28%, 40%)`, warmth);
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(offsetX, 0);
                ctx.bezierCurveTo(offsetX + sway * h * 16, -h * 0.4, offsetX + sway * h * 22, -h * 0.7, offsetX + sway * h * 16, -h);
                ctx.stroke();

                const budCount = 6 + Math.floor(growth * 5);
                for (let i = 0; i < budCount; i++) {
                    const t = 0.35 + (i / budCount) * 0.65;
                    const bx = offsetX + sway * h * 16 * t;
                    const by = -h * t;
                    const budSize = 2.2 + (1 - t) * 2.2;
                    ctx.fillStyle = applyWarmth(`hsl(${268 + seededRandom(seed + i) * 15}, ${42 + seededRandom(seed + i + 50) * 8}%, ${58 + i * 2}%)`, warmth);
                    ctx.beginPath();
                    ctx.ellipse(bx + (seededRandom(seed + i * 2) - 0.5) * 3, by, budSize, budSize * 1.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawBush(ctx, sway, growth, warmth, seed) {
            const h = 50 + growth * 45;
            const w = h * 1.35;
            const layers = [
                { x: -w * 0.22, y: -h * 0.42, w: w * 0.52, h: h * 0.52, hue: 95 },
                { x: w * 0.12, y: -h * 0.52, w: w * 0.58, h: h * 0.56, hue: 100 },
                { x: -w * 0.12, y: -h * 0.62, w: w * 0.48, h: h * 0.48, hue: 105 },
                { x: 0, y: -h * 0.38, w: w * 0.42, h: h * 0.42, hue: 98 },
            ];

            layers.forEach((l, i) => {
                ctx.fillStyle = applyWarmth(`hsl(${l.hue}, 28%, ${30 + i * 5}%)`, warmth);
                ctx.beginPath();
                ctx.ellipse(l.x + sway * h * 9, l.y, l.w, l.h, seededRandom(seed + i) * 0.15, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawTree(ctx, sway, growth, warmth, seed) {
            const h = 100 + growth * 65;

            ctx.fillStyle = applyWarmth('#4a3a2a', warmth);
            ctx.beginPath();
            ctx.moveTo(-7, 0);
            ctx.bezierCurveTo(-6, -h * 0.3, -5, -h * 0.5, -3, -h * 0.62);
            ctx.lineTo(3, -h * 0.62);
            ctx.bezierCurveTo(5, -h * 0.5, 6, -h * 0.3, 7, 0);
            ctx.closePath();
            ctx.fill();

            const foliage = [
                { x: 0, y: -h * 0.56, r: h * 0.36, hue: 95 },
                { x: -h * 0.16, y: -h * 0.72, r: h * 0.30, hue: 100 },
                { x: h * 0.13, y: -h * 0.74, r: h * 0.27, hue: 98 },
                { x: 0, y: -h * 0.88, r: h * 0.23, hue: 105 },
                { x: -h * 0.09, y: -h * 0.98, r: h * 0.16, hue: 102 },
            ];

            foliage.forEach((f, i) => {
                ctx.fillStyle = applyWarmth(`hsl(${f.hue}, 26%, ${28 + i * 4}%)`, warmth);
                ctx.beginPath();
                ctx.ellipse(f.x + sway * h * 3.5, f.y, f.r, f.r * 0.88, 0, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ═══════════════════════════════════════════════════════════════════
        // SCENE DRAWING
        // ═══════════════════════════════════════════════════════════════════

        function drawScene(canvas, stage, time) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const palette = getPalette(currentTimeOfDay);
            const warmth = palette.warmth || 0;
            const isNight = currentTimeOfDay < 0.22 || currentTimeOfDay > 0.88;

            // Sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height);
            skyGradient.addColorStop(0, applyWarmth(palette.skyTop, warmth));
            skyGradient.addColorStop(0.45, applyWarmth(palette.skyMid, warmth));
            skyGradient.addColorStop(1, applyWarmth(palette.skyBottom, warmth));
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height);

            // Sun/Moon
            const celestialX = width * 0.72;
            const celestialY = height * 0.11;

            if (isNight) {
                // Stars
                for (let i = 0; i < 30; i++) {
                    const sx = (Math.sin(i * 73.156) * 0.5 + 0.5) * width;
                    const sy = (Math.cos(i * 127.84) * 0.5 + 0.5) * height * 0.5;
                    const twinkle = Math.sin(time * 1.8 + i * 0.6) * 0.35 + 0.45;
                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 0.8, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Moon
                drawGlow(ctx, celestialX, celestialY, 35, 'rgb(200, 195, 220)', 0.25);
                ctx.fillStyle = palette.moon || '#e0dce8';
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 14, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Sun
                drawGlow(ctx, celestialX, celestialY, 55, 'rgb(255, 240, 200)', 0.35);
                drawGlow(ctx, celestialX, celestialY, 35, 'rgb(255, 250, 220)', 0.45);
                ctx.fillStyle = palette.sun || '#fff8e0';
                ctx.beginPath();
                ctx.arc(celestialX, celestialY, 16, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hills
            drawHillLayer(ctx, width, height, height * 0.67, applyWarmth(palette.groundFar, warmth), 0.006, 32, time * 0.045);
            drawHillLayer(ctx, width, height, height * 0.72, applyWarmth(lerpColor(palette.groundFar, palette.groundMid, 0.5), warmth), 0.009, 24, time * 0.07);
            drawHillLayer(ctx, width, height, height * 0.77, applyWarmth(palette.groundMid, warmth), 0.012, 19, time * 0.1);
            drawHillLayer(ctx, width, height, height * 0.82, applyWarmth(lerpColor(palette.groundMid, palette.groundNear, 0.5), warmth), 0.015, 15, time * 0.14);
            drawHillLayer(ctx, width, height, height * 0.87, applyWarmth(palette.groundNear, warmth), 0.019, 11, time * 0.18);

            // Plants sorted by layer
            const sortedPlants = [...stage.plants].sort((a, b) => a.layer - b.layer);
            sortedPlants.forEach(plant => drawPlant(ctx, plant, width, height, time, palette));
        }

        function drawHillLayer(ctx, width, height, baseY, color, freq, amplitude, offset) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, height);
            for (let x = 0; x <= width; x += 3) {
                const y = baseY +
                    Math.sin(x * freq + offset) * amplitude +
                    Math.sin(x * freq * 2.3 + offset * 1.5) * amplitude * 0.42 +
                    Math.sin(x * freq * 0.5 + offset * 0.7) * amplitude * 0.58;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.closePath();
            ctx.fill();
        }

        // ═══════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════

        const canvases = [];

        function initStages() {
            const container = document.getElementById('stages');
            container.innerHTML = '';

            stages.forEach((stage, index) => {
                const div = document.createElement('div');
                div.className = 'stage';
                div.innerHTML = `
                    <div class="stage-header">
                        <div>
                            <span class="stage-number">Stage ${index + 1}</span>
                            <span class="stage-title">${stage.title.split(' - ')[1]}</span>
                        </div>
                        <div class="stage-metrics">
                            <div class="metric">Health: <span>${Math.round(stage.health * 100)}%</span></div>
                            <div class="metric">Engagement: <span>${Math.round(stage.metrics.engagement * 100)}%</span></div>
                            <div class="metric">Food Logging: <span>${Math.round(stage.metrics.food * 100)}%</span></div>
                            <div class="metric">Ketones: <span>${Math.round(stage.metrics.ketone * 100)}%</span></div>
                            <div class="metric">Glucose: <span>${Math.round(stage.metrics.glucose * 100)}%</span></div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas-${index}"></canvas>
                    </div>
                    <div class="stage-description">${stage.description}</div>
                `;
                container.appendChild(div);

                const canvas = document.getElementById(`canvas-${index}`);
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * 2;
                canvas.height = 280 * 2;
                canvas.style.width = '100%';
                canvas.style.height = '280px';
                canvas.getContext('2d').scale(2, 2);
                canvases.push({ canvas, stage });
            });
        }

        function render(timestamp) {
            const time = timestamp * 0.001;
            canvases.forEach(({ canvas, stage }) => {
                const ctx = canvas.getContext('2d');
                ctx.save();
                ctx.setTransform(2, 0, 0, 2, 0, 0);
                drawScene(canvas, stage, time);
                ctx.restore();
            });
            requestAnimationFrame(render);
        }

        function setTimeOfDay(t) {
            currentTimeOfDay = t;
            document.querySelectorAll('.controls button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // Start
        initStages();
        requestAnimationFrame(render);
        window.addEventListener('resize', initStages);
    </script>
</body>
</html>
